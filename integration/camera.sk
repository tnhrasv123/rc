# File: camera.sk
# Path: race-clicker/integration/camera.sk
# Description: 3rd person camera integration

options:
    prefix: &6&lRaceClicker &8Â» # Example prefix
    camera_distance: 5 # Default distance behind player/citizen
    camera_height: 2   # Default height above player/citizen

# --- Phase 1: Fix and Complete Core Systems ---
# Complete Missing Race Mechanics
# - Integrated 3rd person camera with race system
#   - Camera follows citizen's race position
#   - Smooth transitions at race start/end
#   - Dynamic camera angles based on race state

# --- Phase 2: Enhance Visual Systems ---
# Improve 3rd Person Integration
# - Citizen positioning for races
#   - Camera follows citizen's movement
#   - Dynamic camera angles based on race progress
#   - Smooth transitions between camera modes

# --- Phase 6: Complete Multiplayer Features ---
# Fix Race Lobby System
# - TODO: Complete countdown system integration with 3rd person
#   - Synchronize camera positions at starting line

# --- Phase 9: Integration and Polish ---
# Seamless 3rd Person Race Integration
# - TODO: Perfect camera-citizen synchronization
# - TODO: Smooth race transitions (pre-race positioning, post-race, lobby return)
# - TODO: Dynamic camera effects (speed shake, zoom, cinematic finishes)

# Variables:
# {player::%player's uuid%::in_3rd_person_race_mode} = true/false
# {player::%player's uuid%::camera_target_entity} = the citizen entity the camera should follow
# {player::%player's uuid%::camera_offset_vector} = custom vector for camera position relative to target

# Command to toggle 3rd person (for testing, actual use is automated by race start/end)
command /toggle3rdpersonrace:
    permission: raceclicker.debug
    trigger:
        if {player::%player's uuid%::in_3rd_person_race_mode} is true:
            disableRaceCamera(player)
        else:
            # For testing, we need a dummy target if not in a race
            # In a real scenario, racing.sk would provide the citizen
            if {player::%player's uuid%::race_citizen} is set:
                enableRaceCamera(player, {player::%player's uuid%::race_citizen})
            else:
                send "{@prefix} &cNo race citizen target set for you. Start a race first."

# Function to enable 3rd person race camera for a player
function enableRaceCamera(p: player, target_entity: entity):
    if not {_target_entity} is set:
        return
    
    # Set camera variables
    set {player::%{_p}'s uuid%::in_3rd_person_race_mode} to true
    set {player::%{_p}'s uuid%::camera_target_entity} to {_target_entity}
    set {player::%{_p}'s uuid%::camera_offset_vector} to vector(0, {@camera_height}, -{@camera_distance})
    set {player::%{_p}'s uuid%::camera_mode} to "start"
    
    # Apply camera effects
    applyScreenShake(p, 1, 1)
    setPlayerFOV(p, 0.5, 5)
    
    # Set spectator mode
    set gamemode of {_p} to spectator
    make {_p} spectate {_target_entity}
    
    # Send feedback
    send "{@prefix} &a3rd person race camera enabled. (Spectating your racer)" to {_p}

# Function to disable 3rd person race camera
function disableRaceCamera(p: player):
    if not {player::%{_p}'s uuid%::in_3rd_person_race_mode} is true:
        return
    
    # Clean up variables
    set {player::%{_p}'s uuid%::in_3rd_person_race_mode} to false
    delete {player::%{_p}'s uuid%::camera_target_entity}
    delete {player::%{_p}'s uuid%::camera_offset_vector}
    delete {player::%{_p}'s uuid%::camera_mode}
    
    # Reset camera effects
    clearPlayerFOV(p)
    
    # Restore player state
    set gamemode of {_p} to survival
    
    # Send feedback
    send "{@prefix} &c3rd person race camera disabled." to {_p}

# Dynamic camera update loop
every 2 ticks:
    loop all players:
        set {_p} to loop-value
        if not {player::%{_p}'s uuid%::in_3rd_person_race_mode} is true:
            continue
            
        set {_target} to {player::%{_p}'s uuid%::camera_target_entity}
        if not {_target} is set or not {_target} is online:
            continue
            
        # Get race progress and calculate position
        set {_progress} to {player::%{_p}'s uuid%::race_progress_current_race}
        if not {_progress} is set:
            continue
            
        # Calculate camera position
        set {_citizen_loc} to location of {_target}
        set {_camera_loc} to {_citizen_loc} with offset vector(0, {@camera_height}, -{@camera_distance})
        
        # Apply camera effects based on race state
        if {race::status} is "countdown":
            applyScreenShake(p, 1, 1)
        else if {race::status} is "inprogress":
            setPlayerFOV(p, 0.5, 5)
        else if {race::status} is "finished":
            clearPlayerFOV(p)
            
        # Update player's position
        teleport {_p} to {_camera_loc}
        function updateCameraView(p: player):
            set {_current_mode} to {player::%{_p}'s uuid%::camera_mode} ? "normal"
            
            # Camera mode handling
            if {_current_mode} is "start":
                # Zoom in at race start
                setPlayerFOV(p, 0.5, 1)
                if {player::%{_p}'s uuid%::race_progress_current_race} >= 50: # After first 50 units
                    set {player::%{_p}'s uuid%::camera_mode} to "normal"
                    setPlayerFOV(p, 0, 1) # Reset FOV
            
            else if {_current_mode} is "normal":
                # Dynamic camera positioning based on race progress
                set {_progress} to {player::%{_p}'s uuid%::race_progress_current_race}
                set {_track_length} to {tracks::%{player::%{_p}'s uuid%::current_track_id}%::length}
                set {_percentage} to {_progress} / {_track_length}
                
                # Adjust camera distance based on progress
                if {_percentage} < 0.25:
                    set {player::%{_p}'s uuid%::camera_offset_vector} to vector(0, {@camera_height}, -{@camera_distance})
                else if {_percentage} < 0.75:
                    set {player::%{_p}'s uuid%::camera_offset_vector} to vector(0, {@camera_height}, -{@camera_distance} * 1.5)
                else:
                    set {player::%{_p}'s uuid%::camera_offset_vector} to vector(0, {@camera_height}, -{@camera_distance} * 2)
            
            else if {_current_mode} is "finish":
                # Zoom out at finish
                setPlayerFOV(p, -0.5, 1)
                if now - {player::%{_p}'s uuid%::race_start_time_personal} > 5 seconds:
                    set {player::%{_p}'s uuid%::camera_mode} to "normal"
                    setPlayerFOV(p, 0, 1)
            
            # Apply screen effects based on obstacles/boosts
            if {player::%{_p}'s uuid%::active_obstacle_effect::type} is "slow_down":
                applyScreenShake(p, 2, 0.5) # Strong shake for slowdown
            else if {player::%{_p}'s uuid%::active_boost_effect::end_time} is set and {player::%{_p}'s uuid%::active_boost_effect::end_time} > now:
                applyScreenShake(p, 1, 0.3) # Light shake for boost
# 
#                     # Convert yaw to radians for trigonometric functions
#                     set {_yaw_radians} to ({_target_yaw} + 90) * (pi / 180) # Adding 90 because Minecraft yaw is 0 for south
# 
#                     # Rotate the offset vector
#                     set {_rotated_dx} to ({_dx_offset} * cos({_yaw_radians})) - ({_dz_offset} * sin({_yaw_radians}))
#                     set {_rotated_dz} to ({_dx_offset} * sin({_yaw_radians})) + ({_dz_offset} * cos({_yaw_radians}))
# 
#                     set {_camera_loc} to {_target_loc} ~ vector({_rotated_dx}, {_dy_offset}, {_rotated_dz})
#                     teleport {_p} to {_camera_loc} facing {_target_loc}
#                 else:
#                     # Target lost or invalid, disable manual camera, fallback to spectator or disable full camera
#                     send "{@prefix} &cManual camera target lost, attempting to re-spectate or disable." to {_p}
#                     disableRaceCamera({_p}) # This will try to set to survival
#                     # Optionally, re-enable spectator if citizen still exists
#                     if {_target} is set and {_target} is online:
#                         enableRaceCamera({_p}, {_target}) # Re-enable to go back to spectator
#                     else:
#                         send "{@prefix} &cCamera target completely lost." to {_p}
#             else:
#                 disableRaceCamera({_p})
#                 send "{@prefix} &cNo camera target UUID set." to {_p}

# Function from plan.md (Phase 2: Improve 3rd Person Integration)
# function movePlayerInRace(p: player, progress: number):
#     # This function seems to be about moving the CITIZEN, not the player's camera directly.
#     # The camera (this script) would then follow the citizen.
#     # So, this function would likely be in citizens.sk or racing.sk.
#     # It would calculate the citizen's new position on the track.
#     # Then, the camera loop (or spectator mode) ensures the player's view follows.
#     pass

# Function from plan.md (Phase 9: Seamless 3rd Person Race Integration)
# function updateRaceCamera(p: player):
#     # This function is essentially what the `every tick` loop above does.
#     # It's called to reposition the player's camera to follow the citizen.
#     set {_progress} to {race.progress::%uuid of {_p}%} # This var needs to be from data.sk
#     # {_citizen_loc} = calculateTrackPosition({_progress}) # This function would be in racing.sk or track logic
#     # set {_camera_loc} to {_citizen_loc} with offset vector(0, 2, -5) # Simplified offset
#     # teleport {_p} to {_camera_loc}
#     # This is a simplified version. The `every tick` loop is more robust if not using spectator.
#     pass

# --- Race Start/End Integration (called by racing.sk) ---
function onRaceStartForPlayer(p: player, citizen_racer: entity):
    enableRaceCamera({_p}, {_citizen_racer})
    # TODO: Position camera at starting line view, e.g., slightly zoomed out or a different angle
    # Example: set {player::%{_p}'s uuid%::camera_offset_vector} to vector(0, {@camera_height} + 1, -{@camera_distance} - 2)
    send debug "%{options.prefix}% Camera adjusted for race start for %{_p}%."

function onRaceEndForPlayer(p: player):
    # disableRaceCamera({_p}) # This is already called by racing.sk in playerFinishRace
    # TODO: Transition camera to a podium view, results screen, or back to a standard lobby view.
    # This might involve teleporting the player if they are not spectating, or changing spectator target.
    send debug "%{options.prefix}% Camera transitioning for race end for %{_p}%."
    # Example: if a podium location is defined:
    # if {podium_location_for_winner} is set:
    #    make {_p} spectate some_entity_at_podium or teleport {_p} to a viewing spot

# --- Dynamic Camera Effects (Phase 9) ---
# TODO: Speed-based camera shake (e.g., apply small random offsets to camera_offset_vector)
# TODO: Zoom effects (e.g., change the Z component of camera_offset_vector)
# TODO: Cinematic finish sequences (pre-defined camera paths or movements)

# Note: True 3rd person camera systems in Minecraft without client mods are challenging.
# Using spectator mode is the easiest. Manual camera control via teleportation is more flexible
# but can be jittery and requires careful handling of player visibility and interaction.
# Consider addons if more advanced camera controls are needed (e.g., CamUtils, ReplayMod-like features for Skript).