# File: citizens.sk
# Path: race-clicker/integration/citizens.sk
# Description: Citizen management for racing

options:
    prefix: &6&lRaceClicker &8Â» # Example prefix
    citizen_type: VILLAGER # Default entity type for racers, can be ZOMBIE, ARMOR_STAND etc.
    # Ensure Citizens2 plugin is installed and functional if using its API.
    # This script will assume basic entity manipulation if Citizens2 is not directly used by Skript commands.

# --- Phase 1: Fix and Complete Core Systems ---
# Complete Missing Race Mechanics
# - TODO: Update citizen movement to follow race progress (function moveCitizenOnTrack)
# - TODO: Replace player teleportation with citizen movement

# --- Phase 2: Enhance Visual Systems ---
# Improve 3rd Person Integration
# - TODO: Modify citizen positioning for races (this script handles the actual moving)
# Implement citizen racing animations
# - TODO: Running animations during races (e.g., by changing pose for armor stands, or particle effects)
# - TODO: Victory poses for winners
# - TODO: Idle animations during waiting

# Variables:
# {player::%player's uuid%::race_citizen_entity_id} - Stores the UUID of the spawned entity representing the player.
# {race_citizens::%entity_uuid%::owner_player_uuid} - Maps a citizen entity back to its player owner.
# {player::%player's uuid%::race_indicator_entity_id} - Stores the UUID of an entity used for displaying race position (e.g., an armor stand).

# Function to spawn a race citizen for a player
function spawnRaceCitizen(p: player, spawn_location: location) :: entity:
    # Spawn a basic entity for racing
    spawn 1 of {@citizen_type} at {_spawn_location}
    set {_citizen} to last spawned entity
    if not {_citizen} is set:
        return null
    
    # Set entity properties
    set name of {_citizen} to "&7%name of {_p}%'s Racer"
    set AI of {_citizen} to false
    set gravity of {_citizen} to false
    set silent of {_citizen} to true
    
    # Store entity reference
    set {player::%{_p}'s uuid%::race_citizen_entity_id} to uuid of {_citizen}
    set {race_citizens::%uuid of {_citizen}%::owner_player_uuid} to uuid of {_p}
    return {_citizen}

# Function to remove a player's race citizen
function removeRaceCitizen(p: player):
    set {_citizen_uuid} to {player::%{_p}'s uuid%::race_citizen_entity_id}
    if not {_citizen_uuid} is set:
        return
    
    set {_citizen_entity} to entity from uuid {_citizen_uuid}
    if not {_citizen_entity} is set:
        return
    
    # Remove the entity
    delete {_citizen_entity}
    
    # Clean up variables
    delete {race_citizens::%{_citizen_uuid}%::owner_player_uuid}
    delete {player::%{_p}'s uuid%::race_citizen_entity_id}
    
    # Clean up race indicator if any
    execute function "removeCitizenRaceIndicator" with argument {_p}

# Function to move a citizen along a predefined race track based on progress
function moveCitizenOnTrack(citizen_entity: entity, start_location: location, waypoints: list of locations, progress: number, total_track_length: number):
    if not {_citizen_entity} is set:
        return
    
    # Validate track data
    if not {_start_location} is set or size of {_waypoints::*} = 0:
        if {_start_location} is set:
            teleport {_citizen_entity} to {_start_location}
        return
    
    # Validate track length
    if {_total_track_length} <= 0:
        teleport {_citizen_entity} to {_start_location}
        return
    
    # Build full path
    set {_full_path::*} to {_start_location}
    add all {_waypoints::*} to {_full_path::*}
    
    # Calculate segment information
    set {_num_segments} to size of {_full_path::*} - 1
    if {_num_segments} <= 0:
        set {_target_loc} to {_start_location}
        if {_progress} / {_total_track_length} >= 1 and size of {_full_path::*} > 0:
            set {_target_loc} to last element of {_full_path::*}
        teleport {_citizen_entity} to {_target_loc}
        return
    
    # Calculate progress
    set {_progress_percentage} to {_progress} / {_total_track_length}
    if {_progress_percentage} < 0:
        set {_progress_percentage} to 0
    if {_progress_percentage} > 1:
        set {_progress_percentage} to 1
    
    set {_target_segment_float} to {_progress_percentage} * {_num_segments}
    set {_current_segment_index} to floor({_target_segment_float})
    set {_ratio_in_segment} to {_target_segment_float} - {_current_segment_index}

    # Ensure segment index is valid
    if {_current_segment_index} >= {_num_segments}: # Happens at 100% progress
        set {_current_segment_index} to {_num_segments} - 1
        set {_ratio_in_segment} to 1
    if {_current_segment_index} < 0:
        set {_current_segment_index} to 0
        set {_ratio_in_segment} to 0
        
    set {_p1} to {_full_path::%{_current_segment_index} + 1%}
    set {_p2} to {_full_path::%{_current_segment_index} + 2%}

    if {_p1} is not set or {_p2} is not set: # Should not happen if logic above is correct
        send debug "[Citizens] Error calculating path points for %{_citizen_entity}% (p1 or p2 not set)"
        teleport {_citizen_entity} to last element of {_full_path::*} # Failsafe
        return

    set {_final_pos} to location between {_p1} and {_p2} at ratio {_ratio_in_segment}
    teleport {_citizen_entity} to {_final_pos}
    if y-coordinate of direction from {_p1} to {_p2} is not 0: # Avoid looking straight up/down if moving vertically, keep horizontal orientation
        make {_citizen_entity} look at location {_p2}.x, {_final_pos}.y, {_p2}.z
    else:
        make {_citizen_entity} look at {_p2}
    # send debug "[Citizens] Moved %{_citizen_entity}% to %{_final_pos}%, looking at %{_p2}% (Segment: %{_current_segment_index}%/%{_num_segments}%, Ratio: %{_ratio_in_segment}%)%"
    execute function "playCitizenRunningAnimation" with argument {_citizen_entity} # Play running animation
    # Potentially call updateCitizenRaceIndicator here if rank is passed or can be derived globally
    # For now, racing.sk will call it after ranks are known.

# Function to update or create a race position indicator above the citizen
function updateCitizenRaceIndicator(p: player, rank: integer, total_racers: integer):
    set {_citizen_uuid} to {player::%{_p}'s uuid%::race_citizen_entity_id}
    if {_citizen_uuid} is not set:
        return
    set {_citizen_entity} to entity from uuid {_citizen_uuid}
    if {_citizen_entity} is not set or {_citizen_entity} is not online:
        return

    # Option 1: Update citizen's name (simplest)
    set {_rank_color} to "&a"
    if {_rank} is 1:
        set {_rank_color} to "&6&l"
    else if {_rank} is 2:
        set {_rank_color} to "&e&l"
    else if {_rank} is 3:
        set {_rank_color} to "&c&l"
    else if {_rank} > (round({_total_racers} / 2)):
        set {_rank_color} to "&7"
    
    set name of {_citizen_entity} to "%name of {_p}% - %{_rank_color}##%{_rank}%"
    # Make nameplate always visible if possible (depends on entity type and server settings)
    # For armor stands, you can set customNameVisible to true.
    # For other entities, it's often default or controlled by client settings.

    # Option 2: Use a separate armor stand (more complex, better visuals)
    # This is a placeholder for future enhancement if direct name update is insufficient.
    # delete {player::%{_p}'s uuid%::race_indicator_entity_id} # remove old one
    # spawn armor stand at location of {_citizen_entity} ~ vector(0, 0.5, 0) # Spawn above citizen
    # set {_indicator_entity} to last spawned entity
    # set custom name of {_indicator_entity} to "%name of {_p}% - Rank: %{_rank}%"
    # set custom name visible of {_indicator_entity} to true
    # set visible of {_indicator_entity} to false # Make armor stand invisible
    # set gravity of {_indicator_entity} to false
    # set marker of {_indicator_entity} to true # Make it non-interactive
    # set {player::%{_p}'s uuid%::race_indicator_entity_id} to uuid of {_indicator_entity}
    # Periodically teleport this indicator to follow the main citizen.

# Function to remove the race position indicator
function removeCitizenRaceIndicator(p: player):
    # If using Option 1 (name update), reset name or let spawnRaceCitizen handle it.
    set {_citizen_uuid} to {player::%{_p}'s uuid%::race_citizen_entity_id}
    if {_citizen_uuid} is set:
        set {_citizen_entity} to entity from uuid {_citizen_uuid}
        if {_citizen_entity} is set:
            set name of {_citizen_entity} to "&7%name of {_p}%'s Racer" # Reset to default

    # If using Option 2 (separate armor stand):
    # set {_indicator_uuid} to {player::%{_p}'s uuid%::race_indicator_entity_id}
    # if {_indicator_uuid} is set:
    #    set {_indicator_entity} to entity from uuid {_indicator_uuid}
    #    if {_indicator_entity} is set:
    #        delete {_indicator_entity}
    #    delete {player::%{_p}'s uuid%::race_indicator_entity_id}

# --- Animations (Conceptual) ---
# These would be called at appropriate times by racing.sk or other scripts.

# Variable to control running animation state
# {citizen_animation_state::%entity_uuid%::running_leg} - stores 0 or 1 to alternate legs/arms

function playCitizenRunningAnimation(citizen_entity: entity):
    if {_citizen_entity} is not set or {_citizen_entity} is not online:
        return

    # For Armor Stands: change pose (right arm, left arm, etc.) periodically.
    if type of {_citizen_entity} is armor stand:
        set {_state} to {citizen_animation_state::%uuid of {_citizen_entity}%::running_leg} ? 0
        if {_state} is 0:
            set pose of {_citizen_entity} to (0, 0, 0, -20, 20, 0) # Right arm forward, Left arm back
            set {citizen_animation_state::%uuid of {_citizen_entity}%::running_leg} to 1
        else:
            set pose of {_citizen_entity} to (0, 0, 0, 20, -20, 0) # Left arm forward, Right arm back
            set {citizen_animation_state::%uuid of {_citizen_entity}%::running_leg} to 0
    # For other entities: spawn particles (e.g., footstep dust) or play sounds.
    else:
        spawn 1 of cloud at location of {_citizen_entity} ~ vector(random double between -0.2 and 0.2, 0.1, random double between -0.2 and 0.2) with speed 0
    # send debug "[Citizens] Playing running animation for %{_citizen_entity}%" 

# Function to be called within moveCitizenOnTrack or a separate loop
function triggerCitizenRunningAnimation(citizen_entity: entity):
    # This function is a wrapper that could be used if running animation needs its own tick loop
    # For now, we'll integrate directly into moveCitizenOnTrack for simplicity
    execute function "playCitizenRunningAnimation" with argument {_citizen_entity}

# function playCitizenRunningAnimation(citizen_entity: entity):
    # For Armor Stands: change pose (right arm, left arm, etc.) periodically.
    # For other entities: spawn particles (e.g., footstep dust) or play sounds.
    # if type of {_citizen_entity} is armor stand:
    #    set pose of {_citizen_entity} to (0, 0, 0, -20, 0, 0) # Example: one arm forward
    #    wait 5 ticks
    #    set pose of {_citizen_entity} to (0, 0, 0, 0, -20, 0) # Example: other arm forward
    #    # Loop this with a flag
    # else:
    #    spawn 1 of cloud at location of {_citizen_entity} ~ vector(0, 0.1, 0)
    # send debug "[Citizens] Playing running animation for %{_citizen_entity}%"

function playCitizenIdleAnimation(citizen_entity: entity):
    if {_citizen_entity} is not set or {_citizen_entity} is not online:
        return
    # For Armor Stands: subtle head movement or arm twitch.
    if type of {_citizen_entity} is armor stand:
        if random integer between 1 and 100 <= 5: # 5% chance each time called
            set {_rand} to random integer between 1 and 3
            if {_rand} is 1:
                set pose of {_citizen_entity} to (random integer between -5 and 5, 0, 0, 0, 0, 0) # Head tilt
            else if {_rand} is 2:
                set pose of {_citizen_entity} to (0, 0, 0, random integer between -5 and 5, 0, 0) # Slight arm move
            else:
                set pose of {_citizen_entity} to (0,0,0,0,0,0) # Reset to default
            wait 10 ticks
            set pose of {_citizen_entity} to (0,0,0,0,0,0) # Ensure reset to default pose
    # For other entities: occasional particle puff or sound.
    else:
        if random integer between 1 and 200 <= 2: # 1% chance
            spawn 1 of crit at location of {_citizen_entity} ~ vector(0, 0.5, 0) with speed 0.05
    # send debug "[Citizens] Playing idle animation for %{_citizen_entity}%"

function playCitizenVictoryPose(citizen_entity: entity):
    if {_citizen_entity} is not set or {_citizen_entity} is not online:
        return
    # For Armor Stands: set a specific victory pose.
    if type of {_citizen_entity} is armor stand:
        set pose of {_citizen_entity} to (0, 0, 0, -140, 140, 0) # Example: Arms raised
        # Play a particle effect like fireworks or totems
        loop 5 times:
            spawn 1 of totem_of_undying at location of {_citizen_entity} ~ vector(random double between -0.5 and 0.5, 1.5 + random double between -0.2 and 0.2, random double between -0.5 and 0.5) with speed 0.1
            wait 2 ticks
    # For other entities: spawn celebratory particles.
    else:
        loop 10 times:
            spawn 1 of fireworks_spark at location of {_citizen_entity} ~ vector(random double between -0.5 and 0.5, 1, random double between -0.5 and 0.5) with speed 0.2
            wait 1 tick
    send debug "[Citizens] Playing victory pose for %{_citizen_entity}%"

# function playCitizenVictoryPose(citizen_entity: entity):
    # For Armor Stands: set a specific victory pose.
    # For other entities: spawn celebration particles (fireworks), play sounds.
    # spawn 1 of fireworks at location of {_citizen_entity}
    # send debug "[Citizens] Playing victory pose for %{_citizen_entity}%"

# function playCitizenIdleAnimation(citizen_entity: entity):
    # Small movements, looking around, etc.
    # send debug "[Citizens] Playing idle animation for %{_citizen_entity}%"

# --- Integration with Racing System (called by racing.sk) ---

# When a race starts for a player:
# racing.sk -> spawnRaceCitizen(player, start_location) -> returns citizen entity
# racing.sk -> stores this entity, passes it to camera.sk for 3rd person view

# During the race, as player's progress changes:
# racing.sk -> calculates new progress -> calls moveCitizenOnTrack(citizen_entity, track, new_progress)

# When a race ends:
# racing.sk -> removeRaceCitizen(player)

# Note: If not using the Citizens2 plugin, entity management (especially for non-living entities
# like Armor Stands) requires careful handling of persistence, chunk loading, and removal.
# Living entities like Villagers or Zombies will have their own AI unless fully disabled,
# which might interfere with precise movement control.