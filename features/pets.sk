# File: pets.sk
# Path: race-clicker/features/pets.sk
# Description: Pet system for Race Clicker

options:
    prefix: &8[&6RaceClickerPets&8]&r
    debug_mode: {rc.debug_mode} # Inherit from a global debug mode if available, else set to false
    max_active_pets: 1 # Default max active pets if player-specific variable isn't set
    pet_follow_distance: 3 # Default distance before pets try to pathfind (pathfinding is basic)
    pet_follow_distance_teleport: 15 # Distance at which pets will teleport to the player

# --- Pet Definitions ---
# Structure: {pet::type::name}, {pet::type::entity_type}, {pet::type::skin_data} (e.g., for player heads)
#            {pet::type::bonus::type} (e.g., "click_multiplier", "autoclick_boost", "luck_increase")
#            {pet::type::bonus::value} (e.g., 1.1 for 10% boost, 5 for +5 autoclick)
#            {pet::type::rarity} (e.g., "common", "rare", "epic", "legendary")

variables:
    {player::%uuid%::pets::owned::*} # List of pet types owned by the player
    {player::%uuid%::pets::active::*} # List of currently active pet types for the player
    {player::%uuid%::pets::max_active} = integer # Player's personal max active pets limit
    {pet_entities::%uuid_of_pet_entity%} = text # Stores the pet type for a spawned entity

variables:
    {pet_types_list::*} # List of all defined pet IDs for easier iteration

on load:
    delete {pet_types_list::*}
    # Define pets
    # (id, display name, entity type, skin data (for heads), bonus type, bonus value, rarity)
    definePet("common_dog", "&7Common Dog", "WOLF", null, "click_multiplier_percent", 5, "common") # 5% click boost
    definePet("rare_cat", "&9Rare Cat", "CAT", null, "autoclick_add", 2, "rare") # +2 autoclicks/sec
    definePet("epic_fox", "&5Epic Fox", "FOX", null, "race_speed_boost_percent", 3, "epic") # 3% race speed boost
    definePet("legendary_dragon_head", "&6Legendary Dragon", "PLAYER_HEAD", "eyJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvYjc4ZWYyZTRjZDBhZDRlYjViNDEwYjY1ZGU1NmMyOWE2YjhiMGIyYzQyNWZhZGU0NGFhNWM0NzY0M2VmZDAifX19", "prestige_points_multiplier_percent", 10, "legendary") # 10% more prestige points
    definePet("common_chicken", "&fCommon Chicken", "CHICKEN", null, "click_multiplier_percent", 2, "common")
    definePet("rare_pig", "&dRare Pig", "PIG", null, "autoclick_add", 1, "rare")

    if {rc.debug_mode} is true:
        broadcast "&7[Debug] Pet definitions loaded: %size of {pet_types_list::*}% pets defined."

function definePet(id: text, name: text, entityType: text, skinData: text, bonusType: text, bonusValue: number, rarity: text):
    set {pet::%{_id}%::name} to {_name}
    set {pet::%{_id}%::entity_type} to {_entityType}
    if {_skinData} is set:
        set {pet::%{_id}%::skin_data} to {_skinData} # For custom player head pets or textured mobs
    set {pet::%{_id}%::bonus::type} to {_bonusType}
    set {pet::%{_id}%::bonus::value} to {_bonusValue}
    set {pet::%{_id}%::rarity} to {_rarity}
    add {_id} to {pet_types_list::*}

# --- Pet Management --- 
# Implemented basic summon/desummon and effect application placeholders
# Following behavior is conceptual (see end of file)

command /pet [<text>] [<text>]:
    aliases: /pets, /rcpet
    trigger:
        if arg-1 is not set:
            openPetInventory(player)
            # Implemented openPetInventory(player) function
        else if arg-1 is "summon" or "activate":
            if arg-2 is set:
                activatePet(player, arg-2)
                # Implemented activatePet(player, pet_id) function
            else:
                send "{@prefix} &cUsage: /pet %arg-1% <pet_id>"
        else if arg-1 is "unsummon" or "deactivate":
            if arg-2 is set:
                deactivatePet(player, arg-2)
                # Implemented deactivatePet(player, pet_id) function
            else:
                send "{@prefix} &cUsage: /pet %arg-1% <pet_id>"
        else if arg-1 is "list":
            listOwnedPets(player)
            # Implemented listOwnedPets(player) function
        else:
            send "{@prefix} &cUnknown pet command. Use /pet [summon|unsummon|list] [pet_id] or /pet to open inventory."

# --- Pet Inventory GUI ---
# Implemented basic GUI for managing owned pets

# --- Pet Acquisition ---
# TODO: Implement pet egg/hatching system (could be in a separate 'hatching.sk' or here)
# TODO: Implement pet merging/evolution system
# TODO: Implement pet egg/hatching system (could be in a separate 'hatching.sk' or here)
# TODO: Implement pet merging/evolution system
# TODO: Add a way for players to get pets (e.g. /buypetegg command, drops from races, achievement rewards, shop purchase)

# --- Event Handlers ---
on quit:
    # Despawn active pets for the player
    despawnActivePets(player) # Implemented basic version

on damage:
    # Prevent pets from taking damage or being targeted by mobs
    if {pet_entities::%victim's uuid%} is set:
        cancel event

# --- Utility Functions (Placeholders) ---
function activatePet(p: player, pet_id: text):
    set {_uuid} to {_p}'s uuid
    if {_pet_id} is not in {player::%{_uuid}%::pets::owned::*}:
        send "{@prefix} &cYou do not own the pet '%{_pet_id}%'." to {_p}
        return

    set {_max_pets} to {player::%{_uuid}%::pets::max_active} ? {@max_active_pets}
    if size of {player::%{_uuid}%::pets::active::*} >= {_max_pets}:
        send "{@prefix} &cYou have reached your maximum number of active pets (%{_max_pets}%)." to {_p}
        return

    if {_pet_id} is in {player::%{_uuid}%::pets::active::*}:
        send "{@prefix} &cPet '%{_pet_id}%' is already active." to {_p}
        return

    set {_pet_entity_type_str} to {pet::%{_pet_id}%::entity_type}
    set {_pet_entity_type} to {_pet_entity_type_str} parsed as entity type
    if {_pet_entity_type} is not set:
        send "{@prefix} &cError: Invalid entity type for pet %{_pet_id}%: %{_pet_entity_type_str}%" to {_p}
        if {rc.debug_mode} is true:
            send "&c[Debug] Pet %{_pet_id}% has invalid entity type: %{_pet_entity_type_str}%" to console
        return

    set {_spawn_loc} to location of {_p}
    add 0.5 to y-coordinate of {_spawn_loc} # Spawn slightly above to prevent getting stuck in floor
    spawn {_pet_entity_type} at {_spawn_loc}
    set {_last_spawned_pet} to last spawned entity
    set name of {_last_spawned_pet} to "%{pet::%{_pet_id}%::name}% &7(&e%{_p}'s&7)"
:start_line:128
-------
    set {_last_spawned_pet} to tame # Fix invalid expression 'set ... to be tame'
    set owner of {_last_spawned_pet} to {_p}
    set {pet_entities::%{_last_spawned_pet}'s uuid%} to "%{_uuid}%:%{_pet_id}%" # Store playerUUID:petID

    # Apply skin for player heads
    if {_pet_entity_type_str} is "PLAYER_HEAD" or {_pet_entity_type_str} is "player_head":
        if {pet::%{_pet_id}%::skin_data} is set:
            # Skript alone cannot easily set player head skin on a live armor stand or mob.
            # This usually requires plugins like Citizens or custom NBT manipulation.
            # For simplicity, we'll assume if it's a PLAYER_HEAD type, the icon in GUI is sufficient.
            # If using an Armor Stand with a head, you'd set the head item.
            # If it's an actual mob, this part is more complex.
            # For now, we'll just use the entity type and name.
            # Example for armor stand: make {_last_spawned_pet} wear skull of "{pet::%{_pet_id}%::skin_data}"
            pass

    add {_pet_id} to {player::%{_uuid}%::pets::active::*}
    send "{@prefix} &aPet %{pet::%{_pet_id}%::name}% &aactivated!" to {_p}
:start_line:146
-------
    play sound "minecraft:entity.wolf.howl" to {_p} with volume 0.8 pitch 1.2
    # TODO: Update player stats/bonuses based on new active pet (call a refresh function)
    refreshPlayerPetBonuses({_p})

function deactivatePet(p: player, pet_id: text, silent: boolean = false):
    set {_uuid} to {_p}'s uuid
    if {_pet_id} is not in {player::%{_uuid}%::pets::active::*}:
        if {_silent} is false:
            send "{@prefix} &cPet '%{_pet_id}%' is not active." to {_p}
        return

    :start_line:157
    -------
    # Find and remove the pet entity
    loop all entities:
        if {pet_entities::%loop-entity's uuid%} is "%{_uuid}%:%{_pet_id}%":
            remove loop-entity # Replace delete with 'remove', proper entity removal effect in Skript
            delete {pet_entities::%loop-entity's uuid%}
            exit loop

    remove {_pet_id} from {player::%{_uuid}%::pets::active::*}
    if {_silent} is false:
        send "{@prefix} &ePet %{pet::%{_pet_id}%::name}% &edeactivated." to {_p}
        play sound "minecraft:entity.wolf.whine" to {_p} with pitch 1 volume 0.8
    # TODO: Update player stats/bonuses to remove pet's effect (call a refresh function)
    refreshPlayerPetBonuses({_p})

function despawnActivePets(p: player):
    set {_uuid} to {_p}'s uuid
    loop {player::%{_uuid}%::pets::active::*} an NBT list:
        set {_pet_id_to_despawn} to loop-value
        deactivatePet({_p}, {_pet_id_to_despawn}, true) # Silent deactivation
    clear {player::%{_uuid}%::pets::active::*}
    if {rc.debug_mode} is true:
        send "&7[Debug] Despawned all active pets for %{_p}%." to console

function openPetInventory(p: player):
    set {_uuid} to {_p}'s uuid
    create a gui with virtual chest inventory with 6 rows named "&8&nPets":
        set {_slot} to 0
        # Owned Pets Section (first 4 rows for example)
        loop {player::%{_uuid}%::pets::owned::*}:
            set {_pet_id} to loop-value
            set {_pet_name} to {pet::%{_pet_id}%::name} ? "&cUnknown Pet"
            set {_pet_rarity} to {pet::%{_pet_id}%::rarity} ? "&7N/A"
            set {_pet_bonus_type} to {pet::%{_pet_id}%::bonus::type}
            set {_pet_bonus_value} to {pet::%{_pet_id}%::bonus::value}
            set {_pet_icon_str} to {pet::%{_pet_id}%::entity_type}
            set {_pet_icon} to paper # Default icon
            if {_pet_icon_str} is "WOLF": set {_pet_icon} to bone
            else if {_pet_icon_str} is "CAT": set {_pet_icon} to cod
            else if {_pet_icon_str} is "FOX": set {_pet_icon} to sweet_berries
            else if {_pet_icon_str} is "CHICKEN": set {_pet_icon} to feather
            else if {_pet_icon_str} is "PIG": set {_pet_icon} to carrot
            else if {_pet_icon_str} is "PLAYER_HEAD":
                if {pet::%{_pet_id}%::skin_data} is set:
                    set {_pet_icon} to player head with nbt "{SkullOwner:{Textures:[{Value:"%{pet::%{_pet_id}%::skin_data}%"}]}}"
                else:
                    set {_pet_icon} to player head
            
            set {_lore::*} to ("&7Rarity: %formatRarity({_pet_rarity})%", "")
            add "&6Bonus:&f %formatPetBonus({_pet_bonus_type}, {_pet_bonus_value})%" to {_lore::*}
            add "" to {_lore::*}

            if {_pet_id} is in {player::%{_uuid}%::pets::active::*}:
                add "&cClick to Deactivate" to {_lore::*}
                make gui slot {_slot} with {_pet_icon} named "&a%{_pet_name}% &7(Active)" with lore {_lore::*} to run function runPetInventoryAction({_p}, "deactivate", {_pet_id})
            else:
                add "&aClick to Activate" to {_lore::*}
                make gui slot {_slot} with {_pet_icon} named "&e%{_pet_name}% &7(Inactive)" with lore {_lore::*} to run function runPetInventoryAction({_p}, "activate", {_pet_id})
            
            add 1 to {_slot}
            if {_slot} >= 36: # Max items in first 4 rows
                stop loop

        # Fill remaining pet slots with glass panes
        loop integers from {_slot} to 35:
            make gui slot loop-value with light_gray_stained_glass_pane named " "

        # Info / Controls section (bottom 2 rows)
        make gui slot 49 with book named "&ePet Info" with lore "&7Manage your active pets." and "&7Max Active Pets: &6%{player::%{_uuid}%::pets::max_active} ? {@max_active_pets}%"
        
        # Fill border of bottom rows
        loop integers from 36 to 53:
            if gui slot loop-value is not set:
                if loop-value < 45 or loop-value > 53 or loop-value mod 9 = 0 or loop-value mod 9 = 8:
                    make gui slot loop-value with gray_stained_glass_pane named " "

    open last gui to {_p}

function runPetInventoryAction(p: player, action: text, pet_id: text):
    close inventory of {_p}
    if {_action} is "activate":
        activatePet({_p}, {_pet_id})
    else if {_action} is "deactivate":
        deactivatePet({_p}, {_pet_id})
    wait 1 tick # Give time for commands to process before reopening
    openPetInventory({_p}) # Refresh GUI

function formatRarity(rarity_text: text) -> text:
    if {_rarity_text} is "common": return "&fCommon"
    if {_rarity_text} is "rare": return "&9Rare"
    if {_rarity_text} is "epic": return "&5Epic"
    if {_rarity_text} is "legendary": return "&6Legendary"
    return "&7%{_rarity_text}%"

function formatPetBonus(type: text, value: number) -> text:
    if {_type} is "click_multiplier_percent": return "&e+% {_value}%%% Click Power"
    if {_type} is "autoclick_add": return "&e+% {_value}% Auto-Clicks/sec"
    if {_type} is "race_speed_boost_percent": return "&e+% {_value}%%% Race Speed"
    if {_type} is "prestige_points_multiplier_percent": return "&e+% {_value}%%% Prestige Points"
    return "&7Unknown Bonus"

function listOwnedPets(p: player):
    set {_uuid} to {_p}'s uuid
    if size of {player::%{_uuid}%::pets::owned::*} is 0:
        send "{@prefix} &7You do not own any pets yet." to {_p}
        return

    send "{@prefix} &6Your Pets:&r" to {_p}
    loop {player::%{_uuid}%::pets::owned::*}:
        set {_pet_id} to loop-value
        set {_pet_name} to {pet::%{_pet_id}%::name} ? "&cUnknown Pet"
        set {_status} to "&7(Inactive)"
        if {_pet_id} is in {player::%{_uuid}%::pets::active::*}:
            set {_status} to "&a(Active)"
        send " &7- %{_pet_name}% %{_status}%" to {_p}
    send "{@prefix} &7Use &e/pet&7 to manage them." to {_p}

# --- Pet Following Logic ---
every 1 second:
    loop all players:
        if loop-player is online:
            set {_player_uuid} to loop-player's uuid
            if {player::%{_player_uuid}%::pets::active::*} is set:
                loop {player::%{_player_uuid}%::pets::active::*}:
                    set {_active_pet_id} to loop-value
                    # Find the actual entity for this pet
                    loop all entities:
                        if {pet_entities::%loop-entity-2's uuid%} is "% {_player_uuid}%:%{_active_pet_id}%":
                            set {_pet_entity} to loop-entity-2
                            if {_pet_entity} is set:
                                if world of {_pet_entity} is world of loop-player: # Ensure same world
                                    set {_distance} to distance between loop-player and {_pet_entity}
                                    if {_distance} > {@pet_follow_distance_teleport}:
                                        teleport {_pet_entity} to location of loop-player
                                    else if {_distance} > {@pet_follow_distance}:
                                        # Simple teleport if pathfinding is not reliable or too complex for Skript
                                        # This ensures pets keep up without complex pathfinding logic
                                        teleport {_pet_entity} to behind loop-player at distance (random number between 1.5 and 2.5)
                                        # For a more advanced server, you'd use a proper pathfinding AI from a plugin.
                                        # Example of what you might try with Skript's limited pathfinding:
                                        # if {_pet_entity} is not an armor stand: # Pathfinding usually for mobs
                                        #    make {_pet_entity} pathfind to loop-player with speed 1.2
                                        # else:
                                        #    # Armor stands don't pathfind, so teleport is the only option
                                        #    teleport {_pet_entity} to behind loop-player at distance (random number between 1.5 and 2.5)
                            exit loop # Found the pet entity

# --- Applying Pet Bonuses ---

# --- Applying Pet Bonuses ---
# This function should be called whenever active pets change or relevant stats are calculated.
function getPetBonus(p: player, bonus_type_filter: text) -> number:
    set {_uuid} to {_p}'s uuid
    set {_total_bonus} to 0
    if {_bonus_type_filter} ends with "_percent": # For percentage bonuses, sum them up
        loop {player::%{_uuid}%::pets::active::*}:
            set {_pet_id} to loop-value
            if {pet::%{_pet_id}%::bonus::type} is {_bonus_type_filter}:
                add {pet::%{_pet_id}%::bonus::value} to {_total_bonus}
        return {_total_bonus} # Returns total percentage, e.g., 15 for 15%
    else if {_bonus_type_filter} ends with "_add": # For additive bonuses, sum them up
        loop {player::%{_uuid}%::pets::active::*}:
            set {_pet_id} to loop-value
            if {pet::%{_pet_id}%::bonus::type} is {_bonus_type_filter}:
                add {pet::%{_pet_id}%::bonus::value} to {_total_bonus}
        return {_total_bonus} # Returns total additive value, e.g., 5 for +5
    # Add other bonus calculation types if needed (e.g., multiplicative stacking)
    return 0

# Example of how to use getPetBonus in clicking.sk (conceptual)
# function calculateClickPower(p: player) -> number:
#     set {_power} to {player::%{_p}'s uuid%::base_click_power} ? 1
#     set {_click_multiplier_percent} to getPetBonus({_p}, "click_multiplier_percent")
#     set {_power} to {_power} * (1 + ({_click_multiplier_percent} / 100))
#     return {_power}

# This function should be called after activating/deactivating pets
function refreshPlayerPetBonuses(p: player):
    # This is a placeholder. In a real scenario, you might trigger updates
    # in other scripts that use these bonuses, or re-calculate cached stats.
    if {rc.debug_mode} is true:
        send "&7[Debug] Pet bonuses refreshed for %{_p}% (conceptual)." to console
        send "&7  Click Multiplier Bonus: %getPetBonus({_p}, "click_multiplier_percent")%%%" to console
        send "&7  Autoclick Add Bonus: +%getPetBonus({_p}, "autoclick_add")%" to console

# Admin commands for pets
command /rcpetadmin <player> <text> [<text>] [<text>]:
    permission: raceclicker.admin
    trigger:
        if arg-2 is "give":
            if arg-3 is set:
                if {pet::%arg-3%::name} is not set:
                    send "{@prefix} &cPet ID '%arg-3%' does not exist." to sender
                    return
                add arg-3 to {player::%arg-1's uuid%::pets::owned::*}
                send "{@prefix} &aGave pet %{pet::%arg-3%::name}%&r&a to %arg-1%." to sender
            else:
                send "{@prefix} &cUsage: /rcpetadmin <player> give <pet_id>" to sender
        else if arg-2 is "remove":
            if arg-3 is set:
                if arg-3 is in {player::%arg-1's uuid%::pets::active::*}:
                    deactivatePet(arg-1, arg-3, true) # Silent deactivate
                remove arg-3 from {player::%arg-1's uuid%::pets::owned::*}
                send "{@prefix} &aRemoved pet %arg-3% from %arg-1%." to sender
            else:
                send "{@prefix} &cUsage: /rcpetadmin <player> remove <pet_id>" to sender
        else if arg-2 is "clearowned":
            despawnActivePets(arg-1) # Despawns and clears active list
            delete {player::%arg-1's uuid%::pets::owned::*}
            send "{@prefix} &aCleared all owned pets for %arg-1%." to sender
        else if arg-2 is "setmaxactive":
            if arg-3 is set and arg-3 is a number:
                set {player::%arg-1's uuid%::pets::max_active} to arg-3 parsed as number
                send "{@prefix} &aSet max active pets for %arg-1% to %arg-3%." to sender
            else:
                send "{@prefix} &cUsage: /rcpetadmin <player> setmaxactive <number>" to sender
        else:
            send "{@prefix} &cUnknown pet admin command." to sender

# TODO: Add pet skin/appearance customization (e.g. for player head pets)
# TODO: Add pet leveling system (pets gain XP and level up for better bonuses)
# TODO: Add pet trading system between players