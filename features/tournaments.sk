# File: tournaments.sk
# Path: race-clicker/features/tournaments.sk
# Description: Competition systems

options:
    prefix: &6&lRaceClicker &8Â» # Example prefix

# --- Phase 6: Complete Multiplayer Features ---
# Enhanced Competition Features
# - TODO: Tournament bracket system
#   - Generate elimination brackets
#   - Manage multiple simultaneous races
#   - Track tournament progression
# - TODO: Seasonal competitions
#   - Monthly championship events
#   - Special reward tracks
#   - Limited-time upgrade opportunities

# --- Variables for Tournaments ---
# {tournament::current::id} = "unique_tournament_id"
# {tournament::%{_id}%::status} = "signups" / "running" / "finished"
# {tournament::%{_id}%::players::*} = list of participating player UUIDs
# {tournament::%{_id}%::bracket::round_1::match_1::player1} = player_uuid
# {tournament::%{_id}%::bracket::round_1::match_1::player2} = player_uuid
# {tournament::%{_id}%::bracket::round_1::match_1::winner} = player_uuid
# {tournament::%{_id}%::settings::track_id} = "track_for_tournament"
# {tournament::%{_id}%::settings::max_players} = 16
# {tournament::%{_id}%::settings::rewards::winner} = "command to give prize"

# --- Tournament Management Commands (Admin) ---
command /rctournamentadmin <text> [<text>]:
    permission: raceclicker.admin
    trigger:
        if arg-1 is "create":
            # Create a new tournament ID
            set {_new_id} to "tourney_" + random integer between 1000 and 9999
            set {tournament::current::id} to {_new_id}
            set {tournament::%{_new_id}%::status} to "signups"
            set {tournament::%{_new_id}%::settings::max_players} to 16 # Default
            set {tournament::%{_new_id}%::settings::min_players} to 4 # Minimum players to start
            set {tournament::%{_new_id}%::settings::track_id} to arg-2 ? "default_track"
            set {tournament::%{_new_id}%::current_round} to 0
            clear {tournament::%{_new_id}%::players::*}
            clear {tournament::%{_new_id}%::bracket::*}
            broadcast "{@prefix} &aA new tournament '%{_new_id}%' (Track: %{arg-2}% ? %{arg-2}% : "default_track") has been created! Type &e/tournament join&a to enter!" 
            send "{@prefix} &7Tournament '%{_new_id}%' created. Status: Signups. Track: %{tournament::%{_new_id}%::settings::track_id}%. Max Players: 16, Min Players: 4." to sender

        else if arg-1 is "start":
            set {_id} to {tournament::current::id}
            if not {_id} is set or {tournament::%{_id}%::status} is not "signups":
                send "{@prefix} &cNo tournament in signup phase to start." to sender
                stop
            if size of {tournament::%{_id}%::players::*} < {tournament::%{_id}%::settings::min_players}:
                send "{@prefix} &cNot enough players to start the tournament. (Need %{tournament::%{_id}%::settings::min_players}%, have %size of {tournament::%{_id}%::players::*}%)%" to sender
                stop
            
            generateTournamentBrackets({_id})
            if {tournament::%{_id}%::status} is "error_generating_brackets": # Check if bracket generation failed
                send "{@prefix} &cError generating brackets. Tournament not started." to sender
                delete {tournament::%{_id}%::status} # Reset status to allow re-attempt or cancellation
                stop

            set {tournament::%{_id}%::status} to "running"
            set {tournament::%{_id}%::current_round} to 1
            broadcast "{@prefix} &6Tournament '%{_id}%' has started! Check brackets with &e/tournament bracket&6."
            startNextTournamentRound({_id})

        else if arg-1 is "nextround": # Manually advance round if needed
            set {_id} to {tournament::current::id}
            if {_id} is not set or {tournament::%{_id}%::status} is not "running":
                send "{@prefix} &cNo tournament running or not ready for next round." to sender
                stop
            startNextTournamentRound({_id})

        else if arg-1 is "end":
            set {_id} to {tournament::current::id}
            if not {_id} is set:
                send "{@prefix} &cNo tournament to end." to sender
                stop
            
            # Announce winner and distribute prizes
            if {tournament::%{_id}%::status} is "running":
                set {_winner} to {tournament::%{_id}%::bracket::round_%{tournament::%{_id}%::current_round}%::match_1::winner}
                if {_winner} is set:
                    set {_winner_name} to name of {_winner} parsed as offline player
                    broadcast "{@prefix} &6Tournament '%{_id}%' has ended! Winner: %{_winner_name}%!"
                    # Give rewards
                    giveTournamentRewards({_id}, {_winner})
            
            # Clean up tournament data
            delete {tournament::current::id}
            delete {tournament::%{_id}%::*}
            broadcast "{@prefix} &cTournament '%{_id}%' has ended."

        else:
            send "{@prefix} &cUsage: /rctadmin [create <track_id>|start|nextround|end]" to sender

# --- Player Tournament Commands ---
command /tournament [<text>] [<text>]:
    trigger:
        if arg-1 is not set or arg-1 is "help":
            send "&6--- Tournament Commands ---"
            send "&e/tournament join &7- Join the current tournament during signups."
            send "&e/tournament leave &7- Leave the current tournament during signups."
            send "&e/tournament info &7- View info about the current tournament."
            send "&e/tournament bracket &7- View the current tournament bracket."
            send "&e/tournament spectate <match_id> &7- Spectate an ongoing match (conceptual)."
            # Potentially add /tournament list for past/upcoming tournaments
            stop

        set {_id} to {tournament::current::id}
        if {_id} is not set:
            send "{@prefix} &cThere is no active tournament currently." to player
            stop

        if arg-1 is "join":
            if {tournament::%{_id}%::status} is not "signups":
                send "{@prefix} &cTournament signups are closed." to player
                stop
            if player's uuid is in {tournament::%{_id}%::players::*}:
                send "{@prefix} &eYou are already in the tournament." to player
                stop
            if size of {tournament::%{_id}%::players::*} >= {tournament::%{_id}%::settings::max_players}:
                send "{@prefix} &cThe tournament is full." to player
                stop
            add player's uuid to {tournament::%{_id}%::players::*}
            send "{@prefix} &aYou have joined the tournament '%{_id}%'!" to player
            broadcast "{@prefix} &e%player% &7has joined the tournament! (%size of {tournament::%{_id}%::players::*}%/%{tournament::%{_id}%::settings::max_players}%)%"

        else if arg-1 is "leave":
            if {tournament::%{_id}%::status} is not "signups":
                send "{@prefix} &cYou can only leave a tournament during the signup phase." to player
                stop
            if player's uuid is not in {tournament::%{_id}%::players::*}:
                send "{@prefix} &eYou are not in this tournament." to player
                stop
            remove player's uuid from {tournament::%{_id}%::players::*}
            send "{@prefix} &aYou have left the tournament '%{_id}%'." to player
            broadcast "{@prefix} &e%player% &7has left the tournament. (%size of {tournament::%{_id}%::players::*}%/%{tournament::%{_id}%::settings::max_players}%)%"

        else if arg-1 is "info":
            send "{@prefix} &6--- Tournament Info: %{_id}% ---"
            send "&eStatus: &f%{tournament::%{_id}%::status}%"
            send "&eTrack: &f%{tournament::%{_id}%::settings::track_id}%"
            send "&ePlayers: &f%size of {tournament::%{_id}%::players::*}%/%{tournament::%{_id}%::settings::max_players}% (Min: %{tournament::%{_id}%::settings::min_players}%)%"
            if {tournament::%{_id}%::status} is "running":
                send "&eCurrent Round: &f%{tournament::%{_id}%::current_round}%"
            if {tournament::%{_id}%::status} is "finished":
                send "&eWinner: &f%name of {tournament::%{_id}%::winner} parsed as offline player%"
            send "&eTo view matches, use &6/tournament bracket&e."

        else if arg-1 is "bracket":
            send "{@prefix} &7Tournament bracket for '%{_id}%':"
            if {tournament::%{_id}%::status} is "signups":
                send "{@prefix} &7Signups are still open. Bracket will be generated when tournament starts."
                stop
            if {tournament::%{_id}%::status} is "error_generating_brackets" or {tournament::%{_id}%::status} is "error_no_matches":
                send "{@prefix} &cTournament bracket could not be generated or no matches formed."
                stop

            set {_max_rounds} to 0
            loop 10 times: # Assume max 10 rounds for now
                if {tournament::%{_id}%::bracket::round_%loop-number%::match_1::player1} is set or {tournament::%{_id}%::bracket::round_%loop-number%::match_1::winner} is set:
                    set {_max_rounds} to loop-number
                else:
                    stop loop
            
            if {_max_rounds} is 0 and {tournament::%{_id}%::status} is not "finished":
                send "&7No rounds or matches found. Tournament might be initializing or encountered an issue."
                stop

            send "&6--- Tournament: %{_id}% --- Track: %{tournament::%{_id}%::settings::track_id}% ---"
            loop integers from 1 to {_max_rounds}:
                set {_round_num} to loop-value
                if {tournament::%{_id}%::bracket::round_%{_round_num}%::match_1::player1} is not set and {tournament::%{_id}%::bracket::round_%{_round_num}%::match_1::winner} is not set:
                    if {_round_num} > {tournament::%{_id}%::current_round} and {tournament::%{_id}%::status} is not "finished": # Don't show empty future rounds
                        continue
                send "&b  --- Round %{_round_num}% ---"
                set {_any_match_in_round} to false
                loop {tournament::%{_id}%::bracket::round_%{_round_num}%::match_::*}:
                    set {_any_match_in_round} to true
                    set {_match_idx} to loop-index
                    set {_p1_uuid} to {tournament::%{_id}%::bracket::round_%{_round_num}%::match_%{_match_idx}%::player1}
                    set {_p2_uuid} to {tournament::%{_id}%::bracket::round_%{_round_num}%::match_%{_match_idx}%::player2}
                    set {_status} to {tournament::%{_id}%::bracket::round_%{_round_num}%::match_%{_match_idx}%::status}
                    set {_winner_uuid} to {tournament::%{_id}%::bracket::round_%{_round_num}%::match_%{_match_idx}%::winner}

                    set {_p1_name} to "(BYE)"
                    if {_p1_uuid} is set:
                        set {_p1_name} to name of {_p1_uuid} parsed as offline player
                    set {_p2_name} to "(BYE)"
                    if {_p2_uuid} is set:
                        set {_p2_name} to name of {_p2_uuid} parsed as offline player
                    
                    set {_match_display} to "&e    Match %{_match_idx}%: &f%{_p1_name}% &evs &f%{_p2_name}%"
                    if {_status} is "running":
                        set {_match_display} to "%{_match_display}% &7(&cRunning&7)"
                    else if {_status} is "finished" or {_status} is "finished_bye":
                        set {_winner_name} to name of {_winner_uuid} parsed as offline player if {_winner_uuid} is set else "N/A"
                        set {_match_display} to "&e    Match %{_match_idx}%: &f%{_p1_name}% &evs &f%{_p2_name}% &7(&aWinner: %{_winner_name}%&7)"
                        if {_p2_uuid} is not set and {_status} is "finished_bye": # Explicit bye display
                             set {_match_display} to "&e    Match %{_match_idx}%: &f%{_p1_name}% &7(BYE - Auto-advances)"
                    else if {_status} is "pending":
                        set {_match_display} to "%{_match_display}% &7(&6Pending&7)"
                    send "  %{_match_display}%"
                if {_any_match_in_round} is false and {_round_num} <= ({tournament::%{_id}%::current_round} ? 0) and {tournament::%{_id}%::status} is not "finished":
                    send "&7    (Waiting for matches to be generated or round to start)"
            
            if {tournament::%{_id}%::status} is "finished":
                set {_winner_name} to name of {tournament::%{_id}%::winner} parsed as offline player if {tournament::%{_id}%::winner} is set else "N/A"
                send "&6&lTournament Winner: &e&l%{_winner_name}%"
        
        else if arg-1 is "spectate":
            # Conceptual: /tournament spectate <match_id_from_bracket_display>
            # This would require integration with racing.sk to allow spectating ongoing races.
            send "{@prefix} &cSpectating tournament matches is not yet implemented." to player

        else:
            send "{@prefix} &cUsage: /tournament [help|join|leave|info|bracket|spectate <match_id>]" to player

# --- Tournament Logic Functions ---

# Function to give tournament rewards
function giveTournamentRewards(id: text, winner: text):
    set {_uuid} to {_winner}
    
    # Give ClickCoins
    add 100000 to {player::%{_uuid}%::clickcoins}
    
    # Give prestige points
    add 1000 to {player::%{_uuid}%::prestige_points}
    
    # Give special tournament title
    set {player::%{_uuid}%::tournament_titles::*} to {player::%{_uuid}%::tournament_titles::*} + ["Tournament Champion"]
    
    # Give tournament medal
    give tournament_medal to {_winner}

# Function to generate tournament brackets
function generateTournamentBrackets(id: text):
    set {_id} to {_id}
    set {_players} to {tournament::%{_id}%::players::*}
    set {_size} to size of {_players}
    
    # Check if we have a valid number of players
    if {_size} is not power of 2:
        set {tournament::%{_id}%::status} to "error_generating_brackets"
        return
    
    # Initialize bracket structure
    set {_rounds} to log({_size}) / log(2)
    set {_current_round} to 1
    
    # Create first round matches
    set {_index} to 1
    loop {_players}:
        set {_player1} to loop-value
        if {_index} % 2 = 0:
            set {_player2} to loop-value
            set {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%{(_index / 2)}%::player1} to {_player1}
            set {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%{(_index / 2)}%::player2} to {_player2}
            set {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%{(_index / 2)}%::winner} to null
        
        add 1 to {_index}
    
    # Set tournament status to ready for matches
    set {tournament::%{_id}%::status} to "ready_for_matches"

function generateTournamentBrackets(id: text):
    clear {tournament::%{_id}%::bracket::*}
    set {_player_uuids::*} to {tournament::%{_id}%::players::*}
    
    # Ensure player count is a power of 2 for a simple elimination bracket, or handle byes
    # For simplicity, we'll proceed if we have at least min_players. More complex logic needed for byes.
    if size of {_player_uuids::*} < {tournament::%{_id}%::settings::min_players}:
        send debug "[Tournament] Error: Not enough players for bracket generation in %{_id}%."
        set {tournament::%{_id}%::status} to "error_generating_brackets"
        return

    # Shuffle players
    set {_shuffled_players::*} to {_player_uuids::*}
    # Basic Fisher-Yates shuffle (Skript version)
    loop (size of {_shuffled_players::*}) times:
        set {_i} to (size of {_shuffled_players::*}) - loop-number + 1
        set {_j} to random integer between 1 and {_i}
        set {_temp} to {_shuffled_players::%{_i}%}
        set {_shuffled_players::%{_i}%} to {_shuffled_players::%{_j}%}
        set {_shuffled_players::%{_j}%} to {_temp}

    # Create round 1 matches
    set {_match_num} to 1
    set {_round} to 1
    loop {_shuffled_players::*}:
        if loop-index is odd:
            set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::player1} to loop-value
            set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::status} to "pending"
        else:
            set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::player2} to loop-value
            # If odd number of players, last player gets a bye (auto-win for this match)
            # This simple implementation doesn't handle byes gracefully across rounds yet.
            # For now, if player2 is not set, player1 advances.
            if {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::player2} is not set:
                set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::winner} to {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::player1}
                set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::status} to "finished_bye"
                send debug "[Tournament] %{_id}%: %{tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::player1}% gets a bye in round 1."
            add 1 to {_match_num}
    
    set {tournament::%{_id}%::total_initial_matches} to {_match_num} - 1
    send debug "[Tournament] Generated %{_match_num}-1% matches for round 1 of %{_id}%."

function startNextTournamentRound(id: text):
    # Determine current round and find matches to start.
    # This would involve:
    # 1. Checking which round is active or which was last completed.
    # 2. Finding all matches for the current round that haven't been played.
    # 3. For each match, start a race between the two players (using racing.sk functions).
    #    - This means multiple races might run simultaneously if the server can handle it.
    #    - Need a way to track when a tournament race finishes and who won.
    #    - The winner progresses in the {tournament::%{_id}%::bracket::...} variables.
    send debug "[Tournament] Attempting to start/progress round for %{_id}%."
    set {_current_round} to {tournament::%{_id}%::current_round} ? 1

    # Check if all matches in the current round are finished
    set {_all_matches_finished_this_round} to true
    set {_matches_in_current_round} to 0
    loop {tournament::%{_id}%::bracket::round_%{_current_round}%::match_::*}:
        add 1 to {_matches_in_current_round}
        if {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::status} is "pending" or {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::status} is "running":
            set {_all_matches_finished_this_round} to false
            # Start pending matches
            if {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::status} is "pending":
                set {_p1_uuid} to {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::player1}
                set {_p2_uuid} to {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::player2}
                if {_p1_uuid} is set and {_p2_uuid} is set:
                    send debug "[Tournament] Starting match %loop-index% of round %{_current_round}%: %name of {_p1_uuid} parsed as offline player% vs %name of {_p2_uuid} parsed as offline player%"
                    # TODO: Integrate with racing.sk to start the actual race
                    # This would involve calling a function in racing.sk, e.g.:
                    # callFunction "startRace" with arguments {_p1_uuid}, {_p2_uuid}, {tournament::%{_id}%::settings::track_id}, "tournament", {_id}, {_current_round}, loop-index
                    # For now, we simulate a race start and will need a way to report back results.
                    set {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::status} to "running"
                    broadcast "{@prefix} &eTournament Match Starting on track '%{tournament::%{_id}%::settings::track_id}%': %name of {_p1_uuid} parsed as offline player% vs %name of {_p2_uuid} parsed as offline player%!"
                else if {_p1_uuid} is set and {_p2_uuid} is not set: # Bye already handled
                    pass 
                else:
                    send debug "[Tournament] Error: Players not set for match %loop-index% round %{_current_round}%."
    
    if {_matches_in_current_round} is 0 and {_current_round} is 1: # No matches generated for round 1 (e.g. only 1 player)
        send debug "[Tournament] Not enough matches to start round 1 for %{_id}%."
        # TODO: Handle this scenario, maybe declare winner if only one player signed up and met min requirements
        if size of {tournament::%{_id}%::players::*} is 1:
            set {_winner_uuid} to {tournament::%{_id}%::players::1}
            declareTournamentWinner({_id}, {_winner_uuid})
        else:
            set {tournament::%{_id}%::status} to "error_no_matches"
        return

    if {_all_matches_finished_this_round} is true:
        send debug "[Tournament] All matches in round %{_current_round}% finished for %{_id}%."
        # Check if this was the final round (only one match)
        if {_matches_in_current_round} is 1:
            set {_final_winner_uuid} to {tournament::%{_id}%::bracket::round_%{_current_round}%::match_1::winner}
            if {_final_winner_uuid} is set:
                declareTournamentWinner({_id}, {_final_winner_uuid})
                return
            else:
                send debug "[Tournament] Error: Final match winner not recorded for %{_id}%."
                # Potentially try to find winner if only one player left in bracket logic
                return

        # Proceed to next round
        set {_next_round} to {_current_round} + 1
        generateNextRoundMatches({_id}, {_current_round}, {_next_round})
        set {tournament::%{_id}%::current_round} to {_next_round}
        send debug "[Tournament] Advanced to round %{_next_round}% for %{_id}%."
        # Recursively call to start matches of the new round
        startNextTournamentRound({_id})
    else:
        send debug "[Tournament] Round %{_current_round}% for %{_id}% is still in progress or starting matches."

# When a tournament race (part of a match) finishes, racing.sk should call a function here:
function recordTournamentMatchResult(id: text, round: number, match_num: number, winner_uuid: text):
    set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::winner} to {_winner_uuid}
    send debug "[Tournament] Match %{_match_num}% of round %{_round}% in %{_id}% won by %name of {_winner_uuid} parsed as offline player%"
        # Check if all matches in this round are complete.
    send debug "[Tournament] Match result recorded. Checking round status for %{_id}%."
    startNextTournamentRound({_id}) # This will check and advance if ready

function generateNextRoundMatches(id: text, completed_round: number, next_round: number):
    send debug "[Tournament] Generating matches for round %{_next_round}% of %{_id}% from winners of round %{_completed_round}%."
    clear {tournament::%{_id}%::bracket::round_%{_next_round}%::*}
    set {_winners_this_round::*} to all indices of {tournament::%{_id}%::bracket::round_%{_completed_round}%::match_::*}
    set {_advancing_players::*}
    loop {_winners_this_round::*}:
        set {_match_idx} to loop-value
        set {_winner_uuid} to {tournament::%{_id}%::bracket::round_%{_completed_round}%::match_%{_match_idx}%::winner}
        if {_winner_uuid} is set:
            add {_winner_uuid} to {_advancing_players::*}
        else:
            send debug "[Tournament] Warning: Winner not found for round %{_completed_round}% match %{_match_idx}% in %{_id}%."

    if size of {_advancing_players::*} is 0:
        send debug "[Tournament] Error: No players advanced to round %{_next_round}% for %{_id}%."
        # This could mean an issue or the tournament ended prematurely.
        # Consider if there's a single overall winner if only one player was left from previous logic.
        return
    if size of {_advancing_players::*} is 1:
        send debug "[Tournament] Only one player advanced. %{_advancing_players::1}% is the winner of %{_id}% by default."
        declareTournamentWinner({_id}, {_advancing_players::1})
        return

    # Shuffle advancing players (optional, but good for fairness if pairings are static)
    # For simplicity, we'll pair them in order of their previous match indices for now.
    set {_match_num_next_round} to 1
    loop {_advancing_players::*}:
        if loop-index is odd:
            set {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::player1} to loop-value
            set {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::status} to "pending"
        else:
            set {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::player2} to loop-value
            if {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::player2} is not set: # Should not happen if even number of winners
                set {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::winner} to {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::player1}
                set {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::status} to "finished_bye"
            add 1 to {_match_num_next_round}
    send debug "[Tournament] Generated %{_match_num_next_round}-1% matches for round %{_next_round}% of %{_id}%."

function declareTournamentWinner(id: text, winner_uuid: text):
    set {tournament::%{_id}%::status} to "finished"
    set {tournament::%{_id}%::winner} to {_winner_uuid}
    set {_winner_name} to name of {_winner_uuid} parsed as offline player
    broadcast "{@prefix} &6&lTournament '%{_id}%' Concluded! Winner: &e&l%{_winner_name}%&6&l!"
    send debug "[Tournament] %{_winner_name}% declared winner of %{_id}%."
    # TODO: Distribute prizes based on {tournament::%{_id}%::settings::rewards::winner}
    # Example: 
    # if {tournament::%{_id}%::settings::rewards::winner} is set:
    #     execute console command replace "<player>" with "%{_winner_name}%" in {tournament::%{_id}%::settings::rewards::winner}
    #     send "{@prefix} &aYou have received rewards for winning the tournament!" to {_winner_uuid} parsed as player
    
    # TODO: Clean up tournament data (or mark for cleanup)
    # For now, we'll clear the current tournament ID to allow a new one to be made.
    delete {tournament::current::id}
    send debug "[Tournament] Tournament %{_id}% finished. {tournament::current::id} cleared."

# --- Seasonal Competitions (Conceptual) ---
# This would be a layer on top of the tournament system, or a separate event system.
# - Monthly championship events: Could use the tournament system with special announcements/rewards.
# - Special reward tracks: Tracks could be flagged as "seasonal" or part of an event.
# - Limited-time upgrade opportunities: Could be temporary items in shop.sk or special event vendors.

# Example: Announce a seasonal event
# on load:
#    if today is between "01/12" and "31/12": # Crude date check for December
#        set {event::christmas::active} to true
#        broadcast "{@prefix} &c&lIt's Christmas time! Special events and rewards are active!"

# This is a very high-level overview. Tournament systems are one of the most complex features
# to implement in Skript due to data management, state tracking, and race coordination.
# Addons or a more robust database backend would be highly beneficial for this.