# File: clicking.sk
# Path: race-clicker/core/clicking.sk
# Description: Click detection and power calculation

options:
    prefix: "&6&lRaceClicker &8Â»"
    click_item: stick # Item used for special combo clicks, can be any item type
    combo_max_time: 2 seconds # Max time between clicks to maintain a combo
    combo_max_multiplier: 3 # Maximum multiplier from combos (e.g., 3x power)
    base_click_power: 1 # Base power per click before any upgrades
    combo_counter_duration: 5 seconds # How long to show combo counter
    combo_counter_height: 2.5 # Height above player for counter
    combo_counter_particle_count: 10 # Number of particles for counter
    # Particle for manual click
    click_particle: crit
    click_particle_count: 5
    click_particle_offset: 0.2
    # Particle for auto-clicker
    autoclick_particle: flame
    autoclick_particle_count: 1
    autoclick_particle_offset: 0.1

# Variables (ensure these are initialized in data.sk or on first join):
# {player::%player's uuid%::clicks} - Total clicks by the player
# {player::%player's uuid%::speed_level} - Player's speed upgrade level (affects click power)
# {player::%player's uuid%::autoclicker_level} - Player's auto-clicker upgrade level
# {player::%player's uuid%::prestige_bonus_click_power} - Multiplier from prestige
# {player::%player's uuid%::last_click_time} - Timestamp of the last click for combo
# {player::%player's uuid%::click_combo} - Current click combo count
# {player::%player's uuid%::in_race} - Boolean, true if player is currently in a race
# {player::%player's uuid%::race_progress_current_race} - Current progress in an active race

# --- Phase 1 & 5: Click Detection, Power Calculation, Combos ---

# Function to calculate click power
function calculateClickPower(p: player) :: number:
    set {_power} to {@base_click_power}
    # Add power from speed level (example: each level adds 0.5 power)
    set {_speed_level_bonus} to ({player::%{_p}'s uuid%::speed_level} ? 0) * 0.5
    add {_speed_level_bonus} to {_power}
    
    # Add pattern multiplier
    set {_pattern_multiplier} to getCurrentPatternMultiplier({_p})
    set {_power} to {_power} * {
    # Add accuracy multiplier
    set {_accuracy_multiplier} to getCurrentAccuracyMultiplier({_p})
    set {_power} to {_power} * {_accuracy_multiplier}
    
    # Add upgrade bonuses
    set {_uuid} to {_p}'s uuid
    
    # Add speed bonus from upgrade
    set {_speed_bonus} to getUpgradeBonus({_p}, "speed")
    add {_speed_bonus} to {_power}
    
    # Apply combo bonus from upgrade
    set {_combo_bonus} to getUpgradeBonus({_p}, "combo")
    set {_power} to {_power} * {_combo_bonus}
    
    # Apply accuracy bonus from upgrade
    set {_accuracy_bonus} to getUpgradeBonus({_p}, "accuracy")
    set {_power} to {_power} * {_accuracy_bonus}
    
    # Apply power bonus from upgrade
    set {_power_bonus} to getUpgradeBonus({_p}, "power")
    set {_power} to {_power} * {_power_bonus}

    # Apply prestige bonus (example: direct multiplier)
    set {_prestige_multiplier} to ({player::%{_p}'s uuid%::prestige_bonus_click_power} ? 1)
    set {_power} to {_power} * {_prestige_multiplier}

    # Apply combo bonus
    set {_combo_count} to {player::%{_p}'s uuid%::click_combo} ? 0
    if {_combo_count} > 1:
        set {_combo_bonus_multiplier} to 1 + (({_combo_count} - 1) * 0.1) # Each combo hit adds 0.1x, caps later
        if {_combo_bonus_multiplier} > {@combo_max_multiplier}:
            set {_combo_bonus_multiplier} to {@combo_max_multiplier}
        set {_power} to {_power} * {_combo_bonus_multiplier}
        send action bar "&b&lCOMBO x%player combo count% &7(&a+%.1f%% Power&7)" to {_p} with arguments ((_combo_bonus_multiplier - 1) * 100)
    
    # Apply active obstacle effect (from racing.sk)
    if {player::%{_p}\'s uuid%::active_obstacle_effect::type} is set and {player::%{_p}\'s uuid%::active_obstacle_effect::end_time} is set and {player::%{_p}\'s uuid%::active_obstacle_effect::end_time} > now:
        set {_obstacle_magnitude} to {player::%{_p}\'s uuid%::active_obstacle_effect::magnitude} ? 1 # Default to no effect if magnitude not set
        if {_obstacle_magnitude} < 0: # Ensure magnitude is not negative, treat as 0 if so (full stop)
            set {_obstacle_magnitude} to 0
        if {_obstacle_magnitude} > 1: # Cap reduction at 100% (no negative power)
            set {_obstacle_magnitude} to 1 # This means 100% reduction, effectively 0 power if type is slow_down
    
        if {player::%{_p}\'s uuid%::active_obstacle_effect::type} is "slow_down":
            set {_power} to {_power} * (1 - {_obstacle_magnitude}) # e.g. magnitude 0.5 means 50% power
            if {_power} < 0: # Ensure power doesn't go negative
                set {_power} to 0
    
    # Apply active boost effect (from racing.sk)
    if {player::%{_p}'s uuid%::active_boost_effect::end_time} is set and {player::%{_p}'s uuid%::active_boost_effect::end_time} > now:
        set {_boost_magnitude} to {player::%{_p}'s uuid%::active_boost_effect::magnitude} ? 1 # Default to no boost if not set
        if {_boost_magnitude} < 1: # Ensure boost is at least 1x (no negative boost)
            set {_boost_magnitude} to 1
        set {_power} to {_power} * {_boost_magnitude} # e.g. magnitude 1.5 means 1.5x power

    # TODO: Apply other temporary boosts or debuffs from mini-games or effects
    return {_power}

# Main click event (any click)
on click:
    if player has permission "raceclicker.play":
        # Increment total clicks (persists across races)
        add 1 to {player::%player's uuid%::clicks}

        # Calculate click power
        set {_click_power} to calculateClickPower(player)

        # If in a race, add to race progress
        if {player::%player's uuid%::in_race} is true:
            add {_click_power} to {player::%player's uuid%::race_progress_current_race}
            # Send title showing progress gained in race
            send title "&a+%.2f Race Progress" to player for 10 ticks with arguments {_click_power}
        else:
            # If not in a race, maybe just show general click power or a different feedback
            send title "&b+%.2f Click Power" to player for 10 ticks with arguments {_click_power}

        # Particle effect for click
        spawn {@click_particle_count} of {@click_particle} at location of player offset by vector({@click_particle_offset}, {@click_particle_offset}, {@click_particle_offset})
        
        # Combo System Logic
        set {_uuid} to player's uuid
        set {_now} to now
        
        # Check combo time
        if {_now} - ({player::%{_uuid}%::last_click_time} ? (now - 10 seconds)) <= {@combo_max_time}:
            add 1 to {player::%{_uuid}%::click_combo}
            
            # Show combo counter above player
            set {_loc} to location of player add vector(0, {@combo_counter_height}, 0)
            set {_combo_text} to "&eCOMBO &6x%{player::%{_uuid}%::click_combo}%"
            
            # Create floating text
            spawn 10 of particle "text" with text {_combo_text} at {_loc}
            
            # Add particles around the text
            loop {@combo_counter_particle_count} times:
                set {_angle} to loop-number * (360 / {@combo_counter_particle_count})
                set {_offset} to vector(sin({_angle}), 0, cos({_angle})) multiply 0.5
                spawn particle "crit" at {_loc} add {_offset}
        else:
            # Reset combo if too much time passed
            if ({player::%player\'s uuid%::click_combo} ? 0) > 1:
                send "{@prefix} &cCombo Lost!" to player
            set {player::%{_uuid}%::click_combo} to 1 # Start new combo at 1
    
        # Update last click time
        set {player::%{_uuid}%::last_click_time} to {_now}

    else:
        send "{@prefix} &cYou do not have permission to play."
        cancel event

# --- Click Patterns (Conceptual Placeholders) ---
# TODO: Perfect timing bonuses - Complex: would require tracking click intervals precisely.
# TODO: Rhythm-based clicking - Very Complex: sequences like L-R-L clicks.
# TODO: Anti-spam with skill requirements - Could involve reducing power if click rate is too high without meeting certain conditions (e.g., target hits in a mini-game).
# For now, a simple diminishing return on extremely rapid, non-combo clicks could be considered if spam becomes an issue.

# --- Clicking Mini-games (Conceptual Placeholders) ---
# These would be separate systems, potentially triggered by commands or events.
# command /rcminigame [<text>]:
#    trigger:
#        if arg-1 is "targetpractice":
#            # TODO: Logic for target practice mini-game (e.g., spawning temporary targets)
#            send "{@prefix} &7Target Practice mini-game (Not Implemented)" to player
#        else if arg-1 is "clickaccuracy":
#            # TODO: Logic for click accuracy challenge
#            send "{@prefix} &7Click Accuracy mini-game (Not Implemented)" to player
#        else:
#            send "{@prefix} &cUnknown mini-game."

# --- Advanced Auto-Clicker System ---
every 1 second: # Auto-clicker runs every second
    loop all online players:
        if {player::%loop-player's uuid%::autoclicker_level} is set and {player::%loop-player's uuid%::autoclicker_level} > 0:
            set {_ac_level} to {player::%loop-player's uuid%::autoclicker_level}
            
            # Calculate auto-clicks per second (base on level)
            set {_autoclicks_per_second} to {_ac_level} * 0.5 # Example: 0.5 clicks per level per second

            # Auto-clicker efficiency / Diminishing returns (example)
            if {_ac_level} > 10:
                set {_efficiency_factor} to 1 - (({_ac_level} - 10) * 0.02) # 2% less efficient per level above 10
                if {_efficiency_factor} < 0.5: # Cap efficiency loss at 50%
                    set {_efficiency_factor} to 0.5
                set {_autoclicks_per_second} to {_autoclicks_per_second} * {_efficiency_factor}

            add {_autoclicks_per_second} to {player::%loop-player's uuid%::clicks}

            # Visual auto-clicker representation
            if {_ac_level} > 0 and chance of (20 + {_ac_level} * 2)%: # More frequent particles for higher levels
                spawn {@autoclick_particle_count} of {@autoclick_particle} at entity loop-player offset by vector(random number between -0.5 and 0.5, random number between 0.5 and 1.5, random number between -0.5 and 0.5)
                # TODO: Show floating items around citizens (more complex, involves entity manipulation near player or their citizen)
                # TODO: Upgrade level visual indicators (e.g., different particle color/type based on tiers of auto-clicker level)

            # Auto-clicker contributing to race progress
            if {player::%loop-player's uuid%::in_race} is true:
                set {_autoclick_race_power_base} to {_autoclicks_per_second} * 0.25 # Auto-clicks are less powerful for races than manual clicks
                set {_autoclick_race_power} to {_autoclick_race_power_base} * ({player::%loop-player's uuid%::speed_level} ? 1) # Scale with speed level
                set {_prestige_multiplier_ac} to ({player::%loop-player's uuid%::prestige_bonus_click_power} ? 1)
                set {_autoclick_race_power} to {_autoclick_race_power} * {_prestige_multiplier_ac}

                # Apply active obstacle effect to auto-clicker race power
                if {player::%loop-player's uuid%::active_obstacle_effect::type} is set and {player::%loop-player's uuid%::active_obstacle_effect::end_time} is set and {player::%loop-player's uuid%::active_obstacle_effect::end_time} > now:
                    set {_obstacle_magnitude_ac} to {player::%loop-player's uuid%::active_obstacle_effect::magnitude} ? 1
                    if {_obstacle_magnitude_ac} < 0: set {_obstacle_magnitude_ac} to 0
                    if {_obstacle_magnitude_ac} > 1: set {_obstacle_magnitude_ac} to 1
                    if {player::%loop-player's uuid%::active_obstacle_effect::type} is "slow_down":
                        set {_autoclick_race_power} to {_autoclick_race_power} * (1 - {_obstacle_magnitude_ac})
                        if {_autoclick_race_power} < 0: set {_autoclick_race_power} to 0
                
                # Apply active boost effect to auto-clicker race power
                if {player::%loop-player's uuid%::active_boost_effect::end_time} is set and {player::%loop-player's uuid%::active_boost_effect::end_time} > now:
                    set {_boost_magnitude_ac} to {player::%loop-player's uuid%::active_boost_effect::magnitude} ? 1
                    if {_boost_magnitude_ac} < 1: set {_boost_magnitude_ac} to 1
                    set {_autoclick_race_power} to {_autoclick_race_power} * {_boost_magnitude_ac}

                add {_autoclick_race_power} to {player::%loop-player's uuid%::race_progress_current_race}
                if {_autoclick_race_power} > 0.01: # Only show if significant
                    send action bar "&6Auto-Clicker: +%.2f Race Progress" to loop-player for 2 seconds with arguments {_autoclick_race_power}

            # Synergy with manual clicking (Conceptual)
            # TODO: If player manually clicked recently, slightly boost auto-clicker effectiveness for a short duration.
            # Example: if (now - ({player::%loop-player's uuid%::last_click_time} ? (now - 10 seconds))) < 5 seconds:
            #    multiply {_autoclicks_per_second} by 1.1 # 10% boost

            # Temporary boost mechanics (Conceptual)
            # TODO: Check for active global or player-specific auto-clicker boosts.
            # if {global_autoclick_boost_active} is true:
            #    multiply {_autoclicks_per_second} by {global_autoclick_boost_multiplier}

# --- Debug Commands (Optional) ---
command /rcdebugclick [<text>] [<offline player>] [<number>]:
    permission: "raceclicker.admin"
    trigger:
        if arg-1 is "setcombo":
            if arg-2 is set and arg-3 is set:
                set {player::%arg-2's uuid%::click_combo} to arg-3
                send "{@prefix} Set %arg-2%'s combo to %arg-3%" to sender
            else:
                send "{@prefix} Usage: /rcdebugclick setcombo <player> <amount>"
        else if arg-1 is "testpower":
            set {_power} to calculateClickPower(player)
            send "{@prefix} Your current calculated click power: %.2f" to player with arguments {_power}
        else:
            send "{@prefix} &7Debug: /rcdebugclick <setcombo|testpower> ..."