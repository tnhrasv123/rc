# File: racing.sk
# Path: race-clicker/core/racing.sk
# Description: Race mechanics, track management, and player race state.

# --- Required Scripts --- #
# Ensure all listed scripts exist in the specified paths or relative to the script's location.
# Skript will automatically look for .sk files.
options:
    required_scripts: core/utils, core/config, integration/citizens, integration/camera, dynamic_camera_effects, features/leaderboards

# Options specific to racing.sk, distinct from the global required_scripts
options:
    prefix: "&6&lRaceClicker &8Â»"
    admin_permission: "raceclicker.admin"
    default_race_length: 1000 # Arbitrary length for a race if not defined by track
    countdown_seconds: 5
    max_players_per_race: 10
    min_players_to_start: 1 # For testing, usually 2+

# Variables:
# {race::active} - boolean, true if a race is currently in countdown or progress
# {race::track_id} - string, ID of the current/upcoming track
# {race::status} - string, e.g., "lobby", "countdown", "inprogress", "finished"
# {race::players::*} - list of players participating in the current race
# {race::finished_players::*} - list of players who have finished, with their times/ranks
# {race::start_time} - timestamp when the race actually began (after countdown)

# Player-specific race variables (managed in data.sk, accessed here):
# {player::%uuid%::in_race} - boolean
# {player::%uuid%::current_track_id} - string
# {player::%uuid%::race_progress_current_race} - number (0 to track_length)
# {player::%uuid%::race_start_time_personal} - timestamp for personal race duration
# {player::%uuid%::race_citizen_entity_id} - from citizens.sk

# Track Data (Ideally loaded from YAML, for now, in-script definitions for simplicity)
# {tracks::%track_id%::name} - Display name
# {tracks::%track_id%::length} - Total progress units needed to finish
# {tracks::%track_id%::start_location} - Location for spawning citizens
# {tracks::%track_id%::waypoints::*} - List of locations defining the path
# {tracks::%track_id%::finish_region} - A region defining the finish line (requires a region addon or manual checks)
# {tracks::%track_id%::difficulty} - e.g., "Easy", "Medium", "Hard"
# {tracks::%track_id%::obstacles::*} - List of locations (as strings) for obstacles
# {tracks::%track_id%::obstacles::%location_as_string%::type} - e.g., \"slow_down\", \"temporary_blindness\" (string)
# {tracks::%track_id%::obstacles::%location_as_string%::duration} - duration of effect in ticks (number)
# {tracks::%track_id%::obstacles::%location_as_string%::magnitude} - magnitude of effect (e.g., speed reduction factor) (number)
# {tracks::%track_id%::boost_pads::*} - List of locations (as strings) for boost pads
# {tracks::%track_id%::boost_pads::%location_as_string%::duration} - duration of boost in ticks (number)
# {tracks::%track_id%::boost_pads::%location_as_string%::magnitude} - progress boost amount or speed multiplier (number)

# Player-specific effect variables (temporary, applied during race loop)
# {player::%uuid%::active_obstacle_effect::type} - string, type of current effect
# {player::%uuid%::active_obstacle_effect::end_time} - timestamp, when the effect wears off
# {player::%uuid%::active_obstacle_effect::magnitude} - number, current obstacle effect magnitude
# {player::%uuid%::active_boost_effect::end_time} - timestamp, when the boost wears off
# {player::%uuid%::active_boost_effect::magnitude} - number, current boost magnitude

on load:
    # Initialize some default tracks if none exist (for testing)
    if not {tracks::testtrack1::name} is set:
        set {tracks::testtrack1::name} to "Test Track Alpha"
        set {tracks::testtrack1::length} to 500
        set {tracks::testtrack1::start_location} to location(0, 64, 0, "world")
        add location(10, 64, 0, "world") to {tracks::testtrack1::waypoints::*}
        add location(20, 64, 10, "world") to {tracks::testtrack1::waypoints::*}
        add location(20, 64, 20, "world") to {tracks::testtrack1::waypoints::*}
        set {tracks::testtrack1::finish_region_loc1} to location(18, 63, 28, "world")
        set {tracks::testtrack1::finish_region_loc2} to location(22, 68, 32, "world")
        send console "[RaceClicker] Initialized default track 'testtrack1'. Use /rcadmin track setpoint for locations."
    set {race::status} to "lobby"

# --- Core Race Logic --- #
# Race Movement Mechanics
# - Smooth citizen movement along track waypoints
# - Proper track following with interpolation
# - Collision detection and boundaries

function startRaceCountdown(track_id: text):
    if not {race::status} is "lobby":
        broadcast "{@prefix} &cCannot start race: A race is already in progress or countdown (%{race::status}%)."
        return
    if not {_track_id} is set or not {tracks::%{_track_id}%::name} is set:
        broadcast "{@prefix} &cCannot start race: Track ID '%{_track_id}%' is invalid or not found."
        return
:start_line:84
-------
    if size of {race::players::*} < {@min_players_to_start}:
        broadcast "{@prefix} &cCannot start race: Not enough players. Need %{@min_players_to_start}%, have %{size of {race::players::*}}%"
        return

    set {race::track_id} to {_track_id}
    set {race::status} to "countdown"
    broadcast "{@prefix} &eRace on track &6%{tracks::%{_track_id}%::name}% &estarting in %{@countdown_seconds}% seconds!"

    loop {@countdown_seconds} times:
        set {_remaining_time} to {@countdown_seconds} - (loop-number - 1)
        broadcast "{@prefix} &eRace starting in &c%{_remaining_time}%..."
        loop {race::players::*}:
            set {_p_in_loop} to loop-value-1 # Corrected loop-value to loop-value-1
            send title "&c%{_remaining_time}%" to {_p_in_loop} for 20 ticks
            play sound "block.note_block.pling" to {_p_in_loop} with pitch ((loop-number / {@countdown_seconds}) * 0.5) + 0.5 # Pitch increases
        wait 1 second
    
    triggerRaceStart({_track_id})

function triggerRaceStart(track_id: text):
    if not {race::status} is "countdown" or not {race::track_id} is {_track_id}:
        broadcast "{@prefix} &cRace start failed: Race status mismatch or track ID mismatch."
        return
    
    # Initialize race state
    set {race::status} to "inprogress"
    set {race::start_time} to now
    clear {race::finished_players::*}
    
    # Removed main race loop from here, it's a separate timed event

    # Position citizens at start line
    loop {race::players::*}:
        set {_p} to loop-value-1
        set {_uuid} to {_p}'s uuid
        
        # Create or get citizen
        if {player::%{_uuid}%::race_citizen_entity_id} is not set:
            create new citizen named "RaceCitizen_%{_uuid}%" at {tracks::%{_track_id}%::start_location}
            set {player::%{_uuid}%::race_citizen_entity_id} to last created citizen's uuid
        
        # Position citizen at start
        set {_citizen} to entity from uuid {player::%{_uuid}%::race_citizen_entity_id}
        set location of {_citizen} to {tracks::%{_track_id}%::start_location}
        
        # Reset race progress
        set {player::%{_uuid}%::race_progress_current_race} to 0
        set {player::%{_uuid}%::race_start_time_personal} to now
        
        # Enable race camera
        enableRaceCamera({_p}, {_citizen})
        send "{@prefix} &a3rd person race camera enabled!" to {_p}
        
        # Initialize position tracking
        set {player::%{_uuid}%::last_position_update} to now
        set {player::%{_uuid}%::current_waypoint} to 0
        set {player::%{_uuid}%::target_waypoint} to 1
    broadcast "{@prefix} &a&lGO! &eRace on &6%{tracks::%{_track_id}%::name}% &ehas started!"
    loop {race::players::*}:
        set {_p_in_loop} to loop-value-1 # Corrected loop-value to loop-value-1
        send title "&a&lGO!" to {_p_in_loop} with subtitle "&eRace has started!" for 40 ticks
        playSound("entity.ender_dragon.growl", 1, 1.2, {_p_in_loop})
        if {tracks::%{_track_id}%::start_location} is set:
            spawn 10 of particle "cloud" at {tracks::%{_track_id}%::start_location} offset by vector(2, 1, 2) with speed 0.1 for {_p_in_loop}

    loop {race::players::*}:
        set {_player} to loop-value
        set {player::%{_player}'s uuid%::in_race} to true
        set {player::%{_player}'s uuid%::current_track_id} to {_track_id}
        set {player::%{_player}'s uuid%::race_progress_current_race} to 0
        set {player::%{_player}'s uuid%::race_start_time_personal} to now

        # Spawn citizen for the player
        # TODO: Ensure citizens.sk's spawnRaceCitizen is robust and handles potential errors.
        # This requires {tracks::%{_track_id}%::start_location} to be set.
        if {tracks::%{_track_id}%::start_location} is set:
            set {_citizen} to spawnRaceCitizen({_player}, {tracks::%{_track_id}%::start_location}) # From citizens.sk
            if {_citizen} is set:
                # {player::%{_player}'s uuid%::race_citizen_entity_id} is set by spawnRaceCitizen
                send "{@prefix} &7Your racer has been spawned!" to {_player}
                # Call camera.sk to enable 3rd person race camera for {_player}, targeting {_citizen}
                execute function "enableRaceCamera" with arguments {_player}, {_citizen} # from camera.sk
                execute function "onRaceStartForPlayer" with arguments {_player}, {_citizen} # from camera.sk, for start-specific camera adjustments
            else:
                send "{@prefix} &cFailed to spawn your racer! You will race without one." to {_player}
        else:
            send "{@prefix} &cTrack start location not set! Racers cannot be spawned." to {_player}

function playerFinishRace(p: player):
    if not {player::%{_p}'s uuid%::in_race} is true or not {race::status} is "inprogress":
        return

    set {_time_taken} to now - {player::%{_p}'s uuid%::race_start_time_personal}
    add {_p} to {race::finished_players::*}
    set {_rank} to size of {race::finished_players::*}
    set {race::finished_players::%{_p}%::time} to {_time_taken}
    set {race::finished_players::%{_p}%::rank} to {_rank}

    set {player::%{_p}'s uuid%::in_race} to false
    # add 1 to {player::%{_p}'s uuid%::races_won} # Moved to reward section for actual 1st
    add 1 to {player::%{_p}'s uuid%::total_races_participated}

    broadcast "{@prefix} &6%{_p}% &ehas finished the race in position &a#%size of {race::finished_players::*}% &ewith a time of &b%formatTimespan({_time_taken})%&e!"
    send "{@prefix} &aYou finished! Rank: #%size of {race::finished_players::*}%. Time: %formatTimespan({_time_taken})%" to {_p}
    send title "&6&lFINISHED!" to {_p} with subtitle "&eRank #%size of {race::finished_players::*}% | Time: %formatTimespan({_time_taken})%" for 80 ticks
    playSound("entity.player.levelup", 1, 1, {_p})
    execute function "onRaceFinish" with arguments {_p}, {race::finished_players::%{_p}%::rank} # from dynamic_camera_effects.sk
    # Particle effect at finish line
    if {tracks::%{race::track_id}%::finish_line_center} is set:
        spawn 20 of particle firework at {tracks::%{race::track_id}%::finish_line_center} offset by vector(3, 2, 3) for {_p}
    else if {tracks::%{race::track_id}%::finish_region_loc1} is set and {tracks::%{race::track_id}%::finish_region_loc2} is set: # Fallback to midpoint of finish region corners
        set {_finish_mid_x} to (x-coordinate of {tracks::%{race::track_id}%::finish_region_loc1} + x-coordinate of {tracks::%{race::track_id}%::finish_region_loc2}) / 2
        set {_finish_mid_y} to (y-coordinate of {tracks::%{race::track_id}%::finish_region_loc1} + y-coordinate of {tracks::%{race::track_id}%::finish_region_loc2}) / 2
        set {_finish_mid_z} to (z-coordinate of {tracks::%{race::track_id}%::finish_region_loc1} + z-coordinate of {tracks::%{race::track_id}%::finish_region_loc2}) / 2
        set {_world_name} to world of {tracks::%{race::track_id}%::finish_region_loc1}
        set {_finish_center_loc} to location({_finish_mid_x}, {_finish_mid_y}, {_finish_mid_z}, world {_world_name})
        spawn 20 of particle firework at {_finish_center_loc} offset by vector(3, 2, 3) for {_p}

    # Distribute rewards based on rank
    set {_rank} to {race::finished_players::%{_p}%::rank}
    set {_reward_clicks} to 0
    if {_rank} is 1:
        set {_reward_clicks} to 100
        # Update races_won for global leaderboard, only if truly 1st
        add 1 to {player::%{_p}'s uuid%::races_won_global}
        execute function "updateGlobalLeaderboard" with arguments {_p}, "races_won", 1 # from features/leaderboards.sk
    else if {_rank} is 2:
        set {_reward_clicks} to 50
    else if {_rank} is 3:
        set {_reward_clicks} to 25
    else:
        set {_reward_clicks} to 10 # Participation reward for finishing
    
    if {_reward_clicks} > 0:
        add {_reward_clicks} to {player::%{_p}'s uuid%::clicks} # Assuming {player::%uuid%::clicks} is the variable for player's currency
        send "{@prefix} &eYou earned &6%{_reward_clicks}% clicks &efor finishing rank &a#%{_rank}%!" to {_p}
        execute function "updateGlobalLeaderboard" with arguments {_p}, "clicks_earned", {_reward_clicks} # from features/leaderboards.sk

    # Call camera.sk to disable 3rd person race camera for {_p}
    execute function "disableRaceCamera" with argument {_p} # from camera.sk
    execute function "onRaceEndForPlayer" with argument {_p} # from camera.sk, for finish-specific camera transitions
    # Update track leaderboard
    execute function "updateTrackLeaderboard" with arguments {_p}, {race::track_id}, {_time_taken} # from features/leaderboards.sk

    # Play victory pose if player is 1st
    if {race::finished_players::%{_p}%::rank} is 1:
        set {_citizen_uuid_victory} to {player::%{_p}'s uuid%::race_citizen_entity_id}
        if {_citizen_uuid_victory} is set:
            set {_citizen_entity_victory} to entity from uuid {_citizen_uuid_victory}
            if {_citizen_entity_victory} is set:
                execute function "playCitizenVictoryPose" with argument {_citizen_entity_victory} # from citizens.sk
    else: # Play idle for others who finished but didn't win (or before removal)
        set {_citizen_uuid_idle} to {player::%{_p}'s uuid%::race_citizen_entity_id}
        if {_citizen_uuid_idle} is set:
            set {_citizen_entity_idle} to entity from uuid {_citizen_uuid_idle}
            if {_citizen_entity_idle} is set:
                execute function "playCitizenIdleAnimation" with argument {_citizen_entity_idle} # from citizens.sk
                wait 10 ticks # Brief pause to see idle before removal, adjust as needed

    # Call citizens.sk to remove player's race citizen
    execute function "removeRaceCitizen" with argument {_p} # from citizens.sk

    # Check if all players finished
    if size of {race::finished_players::*} is equal to size of {race::players::*}:
        triggerRaceEnd()

function triggerRaceEnd():
    if not {race::status} is "inprogress" and not {race::status} is "finished": # Can be called if race times out too
        return
    broadcast "{@prefix} &eThe race on &6%{tracks::%{race::track_id}%::name}% &ehas concluded!"
    set {race::status} to "finished"

    # Display leaderboard for the race
    broadcast "{@prefix} &lRace Results:"
    sort {race::finished_players::*} by {race::finished_players::%loop-value%::time} numerically
    loop {race::finished_players::*}:
        set {_p_in_loop} to loop-value
        set {_rank_in_loop} to loop-index
        execute function "updateCitizenRaceIndicator" with arguments {_p_in_loop}, {_rank_in_loop}, size of {race::players::*} # Update final rank display
        # Ensure this doesn't conflict if removeCitizenRaceIndicator is called immediately after in playerFinishRace for this player.
        set {_player} to loop-value
        broadcast "&7- &e#%loop-index%: &b%{_player}% &7(&a%formatTimespan({race::finished_players::%{_player}%::time})%&7)"

    # Cleanup remaining players who might not have finished (e.g., if race ended by admin or timeout)
    loop {race::players::*}:
        if {player::%loop-value's uuid%::in_race} is true:
            # Play idle animation for players who DNF'd and are about to be cleaned up
            set {_citizen_uuid_dnf} to {player::%loop-value's uuid%::race_citizen_entity_id}
            if {_citizen_uuid_dnf} is set:
                set {_citizen_entity_dnf} to entity from uuid {_citizen_uuid_dnf}
                if {_citizen_entity_dnf} is set:
                    execute function "playCitizenIdleAnimation" with argument {_citizen_entity_dnf} # from citizens.sk
                    wait 10 ticks # Brief pause
            # End of DNF idle animation call

            set {player::%loop-value's uuid%::in_race} to false
            execute function "disableRaceCamera" with argument loop-value # from camera.sk
            execute function "removeRaceCitizen" with argument loop-value # from citizens.sk (this will also call removeCitizenRaceIndicator)
            send "{@prefix} &cThe race has ended." to loop-value

    clear {race::players::*}
    # {race::track_id} can remain for viewing last race info
    set {race::status} to "lobby" # Ready for a new race
    send "{@prefix} &aReturning to lobby state." to console

    # Potentially trigger idle animations for all remaining citizens if any are kept in lobby
    # For now, citizens are removed. If a lobby system with visible citizens is added,
    # this would be the place to loop through them and call playCitizenIdleAnimation.


# --- Player Progress and Movement Update Loop --- #
every 10 ticks: # Update rate for citizen movement and finish line checks (0.5 seconds)
    if {race::status} is not "inprogress":
        stop

    # Real-time Ranking Logic
    clear {_ranked_racers::*}
    loop {race::players::*}:
        if {player::%loop-value's uuid%::in_race} is true:
            # Play idle animation for players who DNF'd and are about to be cleaned up
            set {_citizen_uuid_dnf} to {player::%loop-value's uuid%::race_citizen_entity_id}
            if {_citizen_uuid_dnf} is set:
                set {_citizen_entity_dnf} to entity from uuid {_citizen_uuid_dnf}
                if {_citizen_entity_dnf} is set:
                    execute function "playCitizenIdleAnimation" with argument {_citizen_entity_dnf} # from citizens.sk
                    wait 10 ticks # Brief pause
            # End of DNF idle animation call

            add loop-value to {_ranked_racers::*}
    
    # Sort players by progress (descending). If progress is equal, maintain original order or use join time (not implemented here for simplicity)
    sort {_ranked_racers::*} by {player::%loop-value's uuid%::race_progress_current_race} numerically descending

    # Assign ranks and update indicators
    set {_total_racers_in_loop} to size of {_ranked_racers::*}
    loop {_ranked_racers::*}:
        set {_player_for_rank_update} to loop-value
        set {_current_rank_for_player} to loop-index
        # Call updateCitizenRaceIndicator for each player with their calculated rank
        execute function "updateCitizenRaceIndicator" with arguments {_player_for_rank_update}, {_current_rank_for_player}, {_total_racers_in_loop} # from citizens.sk

    # Main player loop for movement, effects, etc.
    loop {race::players::*}: # This loop is now primarily for game logic other than rank display which is handled above.
        set {_player} to loop-value-1 # Corrected loop-value to loop-value-1
        if {player::%{_player}'s uuid%::in_race} is true:
            set {_progress} to {player::%{_player}'s uuid%::race_progress_current_race} ? 0
            set {_track_id} to {player::%{_player}'s uuid%::current_track_id}
            set {_track_length} to {tracks::%{_track_id}%::length} ? {@default_race_length}

            # Rank display is now handled in the ranking logic at the start of the 'every 10 ticks' loop.
            # The call to updateCitizenRaceIndicator has been moved there.

            # Move citizen
            set {_citizen_uuid} to {player::%{_player}'s uuid%::race_citizen_entity_id}
            if {_citizen_uuid} is set:
                set {_citizen_entity} to entity from uuid {_citizen_uuid}
                if {_citizen_entity} is set:
                    set {_track_start_loc} to {tracks::%{_track_id}%::start_location}
                    set {_track_waypoints::*} to {tracks::%{_track_id}%::waypoints::*}
                    if {_track_start_loc} is set and {tracks::%{_track_id}%::waypoints::*} is set and size of {_track_waypoints::*} > 0:
                        execute function "moveCitizenOnTrack" with arguments {_citizen_entity}, {_track_start_loc}, {_track_waypoints::*}, {_progress}, {_track_length} # from citizens.sk
                        send action bar "&7Progress: %.1f / %.1f" to {_player} with arguments {_progress}, {_track_length}
                    else if {_track_start_loc} is set: # Fallback for tracks with no waypoints or empty waypoints list
                        if {tracks::%{_track_id}%::finish_line_center} is set:
                            set {_target_loc} to location between {_track_start_loc} and {tracks::%{_track_id}%::finish_line_center} at ratio ({_progress} / {_track_length})
                            teleport {_citizen_entity} to {_target_loc}
                            make {_citizen_entity} look at {tracks::%{_track_id}%::finish_line_center}
                            send action bar "&7Progress (approx): %.1f / %.1f" to {_player} with arguments {_progress}, {_track_length}
                        else if {tracks::%{_track_id}%::finish_region_loc1} is set: # Fallback to first corner of finish region
                            set {_target_loc} to location between {_track_start_loc} and {tracks::%{_track_id}%::finish_region_loc1} at ratio ({_progress} / {_track_length})
                            teleport {_citizen_entity} to {_target_loc}
                            make {_citizen_entity} look at {tracks::%{_track_id}%::finish_region_loc1}
                            send action bar "&7Progress (approx): %.1f / %.1f" to {_player} with arguments {_progress}, {_track_length}
                        else:
                            send action bar "&cTrack data incomplete for precise movement..." to {_player}
                    else:
                        send action bar "&cTrack start location missing for movement..." to {_player}

            # Check for finish line AFTER movement
            if {_progress} >= {_track_length}:
                if {player::%{_player}'s uuid%::in_race} is true: # Ensure they haven't already finished this tick
                    playerFinishRace({_player})
                    continue loop # Skip obstacle/boost checks for finished player

            # Obstacle and Boost Pad Logic (based on citizen's NEW location after movement)
            if {_citizen_uuid} is set and {_citizen_entity} is set: # Ensure citizen exists before checking its location
                # Round citizen's location to match how locations are stored for obstacles/boosts (integer coords)
                set {_cx} to round(x-coordinate of location of {_citizen_entity})
                set {_cy} to round(y-coordinate of location of {_citizen_entity})
                set {_cz} to round(z-coordinate of location of {_citizen_entity})
                set {_cw} to world of location of {_citizen_entity}
                set {_citizen_rounded_loc_string} to "%world of location of {_citizen_entity}%,%round(x-coordinate of location of {_citizen_entity})%,%round(y-coordinate of location of {_citizen_entity})%,%round(z-coordinate of location of {_citizen_entity})%"

                # Check for obstacles
                if {tracks::%{_track_id}%::obstacles::%{_citizen_rounded_loc_string}%::type} is set:
                    if {player::%{_player}'s uuid%::active_obstacle_effect::end_time} is not set or {player::%{_player}'s uuid%::active_obstacle_effect::end_time} < now:
                        set {_obstacle_type} to {tracks::%{_track_id}%::obstacles::%{_citizen_rounded_loc_string}%::type} ? "slow_down"
                        set {_obstacle_duration_ticks} to {tracks::%{_track_id}%::obstacles::%{_citizen_rounded_loc_string}%::duration} ? 60 # 3 seconds default
                        set {_obstacle_magnitude} to {tracks::%{_track_id}%::obstacles::%{_citizen_rounded_loc_string}%::magnitude} ? 0.5 # 50% speed reduction default
                        set {player::%{_player}'s uuid%::active_obstacle_effect::type} to {_obstacle_type}
                        set {player::%{_player}'s uuid%::active_obstacle_effect::end_time} to (now + {_obstacle_duration_ticks} ticks)
                        set {player::%{_player}'s uuid%::active_obstacle_effect::magnitude} to {_obstacle_magnitude}
                        send "{@prefix} &cYou hit an obstacle! (%{_obstacle_type}%) Effect active for %{_obstacle_duration_ticks} / 20% seconds." to {_player}
                        playSound("entity.zombie.hurt", 1, 0.8, {_player})
                        spawn 10 of particle crit at location of {_citizen_entity} offset by vector(0.5, 0.5, 0.5) with speed 0.1 for {_player}
                        execute function "onObstacleHit" with argument {_player} # from dynamic_camera_effects.sk
                # Check for boost pads
                else if {tracks::%{_track_id}%::boost_pads::%{_citizen_rounded_loc_string}%::magnitude} is set: # Use 'else if' to prevent applying boost and obstacle simultaneously from same block
                    if {player::%{_player}'s uuid%::active_boost_effect::end_time} is not set or {player::%{_player}'s uuid%::active_boost_effect::end_time} < now:
                        set {_boost_duration_ticks} to {tracks::%{_track_id}%::boost_pads::%{_citizen_rounded_loc_string}%::duration} ? 40 # 2 seconds default
                        set {_boost_magnitude} to {tracks::%{_track_id}%::boost_pads::%{_citizen_rounded_loc_string}%::magnitude} ? 1.5 # 1.5x progress gain default
                        set {player::%{_player}'s uuid%::active_boost_effect::end_time} to (now + {_boost_duration_ticks} ticks)
                        set {player::%{_player}'s uuid%::active_boost_effect::magnitude} to {_boost_magnitude}
                        send "{@prefix} &aBoost Pad! Effect active for %{_boost_duration_ticks} / 20% seconds." to {_player}
                        playSound("entity.generic.explode", 0.5, 1.5, {_player})
                        spawn 15 of particle flame at location of {_citizen_entity} offset by vector(0.5, 0.5, 0.5) with speed 0.05 for {_player}
                        execute function "onBoostPadHit" with argument {_player} # from dynamic_camera_effects.sk

            # Clear expired effects
            if {player::%{_player}'s uuid%::active_obstacle_effect::end_time} is set and {player::%{_player}'s uuid%::active_obstacle_effect::end_time} < now:
                delete {player::%{_player}'s uuid%::active_obstacle_effect::type}
                delete {player::%{_player}'s uuid%::active_obstacle_effect::end_time}
                delete {player::%{_player}'s uuid%::active_obstacle_effect::magnitude}
                send "{@prefix} &aObstacle effect wore off." to {_player}

            if {player::%{_player}'s uuid%::active_boost_effect::end_time} is set and {player::%{_player}'s uuid%::active_boost_effect::end_time} < now:
                delete {player::%{_player}'s uuid%::active_boost_effect::end_time}
                delete {player::%{_player}'s uuid%::active_boost_effect::magnitude}
                send "{@prefix} &eBoost wore off." to {_player}

# --- Player Commands --- #
command /race [<join|leave|info|list>] [<text>]:
    trigger:
        if arg-1 is not set or arg-1 is "info":
            send "{@prefix} &7Current race status: &e%{race::status}%"
            if {race::status} is not "lobby":
                send "{@prefix} &7Track: &6%{tracks::%{race::track_id}%::name}%"
                send "{@prefix} &7Players: &b%size of {race::players::*}% / %{@max_players_per_race}%"
            send "{@prefix} &7Available tracks: (use /race list)"
            send "{@prefix} &7Commands: /race join <track_id>, /race leave"
            stop

        if arg-1 is "list":
            send "{@prefix} &eAvailable Race Tracks:"
            if size of {tracks::*} is 0:
                send "&c - No tracks defined yet. An admin needs to create them."
                stop
            loop {tracks::*}:
                send "&7 - &b%loop-index%&7: &a%loop-value::name% &7(Length: %loop-value::length ? {@default_race_length}%, Difficulty: %loop-value::difficulty ? "N/A"%)"
            stop

        if arg-1 is "join":
            if {race::status} is not "lobby":
                send "{@prefix} &cCannot join: A race is already in %{race::status}% state."
                stop
            if size of {race::players::*} >= {@max_players_per_race}:
                send "{@prefix} &cCannot join: The race lobby is full (%{@max_players_per_race}% players)."
                stop
            if player is in {race::players::*}:
                send "{@prefix} &cYou are already in the race lobby."
                stop
            # For now, any race started by admin uses the admin-specified track.
            # If players could choose or vote, arg-2 would be track_id.
            add player to {race::players::*}
            broadcast "{@prefix} &b%player% &ehas joined the race lobby! (&a%size of {race::players::*}%/%{@max_players_per_race}%&e)"
            stop

        if arg-1 is "leave":
            if player is not in {race::players::*}:
                send "{@prefix} &cYou are not in the race lobby or current race."
                stop
            if {race::status} is "inprogress" and {player::%player's uuid%::in_race} is true:
                # Handle leaving mid-race (DNF - Did Not Finish)
                set {player::%player's uuid%::in_race} to false
                # removeRaceCitizen(player)
                # disableRaceCamera(player)
                send "{@prefix} &cYou have left the race."
                broadcast "{@prefix} &b%player% &chas left the ongoing race."
                remove player from {race::players::*} # Also remove from active list
                # Check if this ends the race (e.g., if last player leaves)
                if {race::status} is "inprogress" and size of {race::players::*} < {@min_players_to_start} and size of {race::players::*} < 1: # If all active players left
                    broadcast "{@prefix} &cAll players have left the race. Ending race."
                    triggerRaceEnd()
                stop

            remove player from {race::players::*}
            broadcast "{@prefix} &b%player% &ehas left the race lobby. (&a%size of {race::players::*}%/%{@max_players_per_race}%&e)"
            stop

# --- Admin Commands for Racing --- #
command /rcadmin race [<text>] [<text>] [<text>] [<text>] [<text>] [<text>]: # Increased args for obstacle/boost params
    permission: {@admin_permission}
    trigger:
        if arg-1 is "start":
            if arg-2 is not set:
                send "{@prefix} &cUsage: /rcadmin race start <track_id>"
                stop
            startRaceCountdown(arg-2)
            stop

        if arg-1 is "stop":
            if {race::status} is "lobby" or {race::status} is "finished":
                send "{@prefix} &cNo race is currently active to stop."
                stop
            broadcast "{@prefix} &cThe current race has been stopped by an administrator!"
            triggerRaceEnd() # This will handle cleanup
            stop
        
        if arg-1 is "createtrack":
            if arg-2 is not set:
                send "{@prefix} &cUsage: /rcadmin race createtrack <track_id> <Track Name>"
                stop
            if {tracks::%arg-2%::name} is set:
                send "{@prefix} &cTrack ID '%arg-2%' already exists."
                stop
            set {tracks::%arg-2%::name} to arg-3 ? arg-2 # Default name to ID if not provided
            set {tracks::%arg-2%::length} to {@default_race_length}
            send "{@prefix} &aTrack '%arg-3%' (ID: %arg-2%) created with default length. Use /rcadmin race setpoint to define its path."
            stop

        if arg-1 is "deletetrack":
            if arg-2 is not set or {tracks::%arg-2%::name} is not set:
                send "{@prefix} &cUsage: /rcadmin race deletetrack <track_id>. Track not found."
                stop
            clear {tracks::%arg-2%::*}
            send "{@prefix} &aTrack '%arg-2%' deleted."
            stop

        if arg-1 is "setpoint": 
            if arg-2 is not set or arg-3 is not set:
                send \"{@prefix} &cUsage: /rcadmin race setpoint <track_id> <type> [value/here] [param1] [param2] [param3]\"
                send \"{@prefix} &cTypes: start, waypoint, clearwaypoints, finish1, finish2, length, name, difficulty, obstacle, boostpad, removelastobstacle, removelastboostpad, removelastwaypoint\"
                stop
            set {_track_id} to arg-2
            if {tracks::%{_track_id}%::name} is not set and arg-3 is not "createtrack": # Allow createtrack without existing track
                send \"{@prefix} &cTrack ID '%{_track_id}%' not found. Create it first.\"
                stop
            set {_point_type} to lowercased arg-3
            set {_value} to arg-4 # This can be 'here' or a specific value depending on _point_type

            if {_point_type} is "start":
                set {tracks::%{_track_id}%::start_location} to player's location
                send "{@prefix} &aStart point for track '%{_track_id}%' set to your location."
            else if {_point_type} is "waypoint":
                add player's location to {tracks::%{_track_id}%::waypoints::*}
                send "{@prefix} &aWaypoint #%size of {tracks::%{_track_id}%::waypoints::*}% for track '%{_track_id}%' added at your location."
            else if {_point_type} is "removelastwaypoint":
                if size of {tracks::%{_track_id}%::waypoints::*} > 0:
                    remove last element from {tracks::%{_track_id}%::waypoints::*}
                    send "{@prefix} &aLast waypoint removed from track '%{_track_id%}%'."
                else:
                    send "{@prefix} &cNo waypoints to remove from track '%{_track_id%}%'."
            else if {_point_type} is "clearwaypoints":
                clear {tracks::%{_track_id}%::waypoints::*}
                send "{@prefix} &aAll waypoints for track '%{_track_id}%' cleared."
            else if {_point_type} is "finish1": # Define one corner of finish region
                set {tracks::%{_track_id}%::finish_region_loc1} to player's location
                send "{@prefix} &aFinish region corner 1 for track '%{_track_id}%' set."
            else if {_point_type} is "finish2": # Define other corner of finish region
                set {tracks::%{_track_id}%::finish_region_loc2} to player's location
                send "{@prefix} &aFinish region corner 2 for track '%{_track_id}%' set."
            else if {_point_type} is "length":
                set {_len} to {_value} parsed as number
                if {_len} is not set or {_len} <= 0:
                    send "{@prefix} &cInvalid length: %{_value}%"
                    stop
                set {tracks::%{_track_id}%::length} to {_len}
                send "{@prefix} &aTrack '%{_track_id}%' length set to %{_len}% units."
            else if {_point_type} is "name":
                set {tracks::%{_track_id}%::name} to {_value}
                send "{@prefix} &aTrack '%{_track_id}%' name set to '%{_value}%'."
            else if {_point_type} is \"difficulty\":
                set {tracks::%{_track_id}%::difficulty} to {_value}
                send \"{@prefix} &aTrack '%{_track_id}%' difficulty set to '%{_value}%'.\"
            else if {_point_type} is \"obstacle\":
                set {_loc_string} to \"%player's location%\"
                set {_obstacle_type} to arg-5 ? \"slow_down\"
                set {_obstacle_duration} to arg-6 parsed as number ? 60
                set {_obstacle_magnitude} to arg-7 parsed as number ? 0.5
                add {_loc_string} to {tracks::%{_track_id}%::obstacles::*}
                set {tracks::%{_track_id}%::obstacles::%{_loc_string}%::type} to {_obstacle_type}
                set {tracks::%{_track_id}%::obstacles::%{_loc_string}%::duration} to {_obstacle_duration}
                set {tracks::%{_track_id}%::obstacles::%{_loc_string}%::magnitude} to {_obstacle_magnitude}
                send \"{@prefix} &aObstacle ('%{_obstacle_type}%', %{_obstacle_duration}%t, mag %{_obstacle_magnitude}%) added to '%{_track_id}%' at your location (%{_loc_string}%).\"
            else if {_point_type} is \"boostpad\":
                set {_loc_string} to \"%player's location%\"
                set {_boost_duration} to arg-5 parsed as number ? 40
                set {_boost_magnitude} to arg-6 parsed as number ? 1.5
                add {_loc_string} to {tracks::%{_track_id}%::boost_pads::*}
                set {tracks::%{_track_id}%::boost_pads::%{_loc_string}%::duration} to {_boost_duration}
                set {tracks::%{_track_id}%::boost_pads::%{_loc_string}%::magnitude} to {_boost_magnitude}
                send \"{@prefix} &aBoost pad (%{_boost_duration}%t, mag %{_boost_magnitude}%) added to '%{_track_id}%' at your location (%{_loc_string}%).\"
            else if {_point_type} is \"removelastobstacle\":
                if size of {tracks::%{_track_id}%::obstacles::*} > 0:
                    set {_last_obstacle_loc_string} to last element of {tracks::%{_track_id}%::obstacles::*}
                    remove last element from {tracks::%{_track_id}%::obstacles::*}
                    delete {tracks::%{_track_id}%::obstacles::%{_last_obstacle_loc_string}%::type}
                    delete {tracks::%{_track_id}%::obstacles::%{_last_obstacle_loc_string}%::duration}
                    delete {tracks::%{_track_id}%::obstacles::%{_last_obstacle_loc_string}%::magnitude}
                    send \"{@prefix} &aLast obstacle removed from track '%{_track_id}%'.\"
                else:
                    send \"{@prefix} &cNo obstacles to remove from track '%{_track_id%}%'.\"
            else if {_point_type} is \"removelastboostpad\":
                if size of {tracks::%{_track_id}%::boost_pads::*} > 0:
                    set {_last_boost_loc_string} to last element of {tracks::%{_track_id}%::boost_pads::*}
                    remove last element from {tracks::%{_track_id}%::boost_pads::*}
                    delete {tracks::%{_track_id}%::boost_pads::%{_last_boost_loc_string}%::duration}
                    delete {tracks::%{_track_id}%::boost_pads::%{_last_boost_loc_string}%::magnitude}
                    send \"{@prefix} &aLast boost pad removed from track '%{_track_id%}%'.\"
                else:
                    send \"{@prefix} &cNo boost pads to remove from track '%{_track_id%}%'.\"
            else:
                send \"{@prefix} &cInvalid setpoint type. Use: start, waypoint, clearwaypoints, finish1, finish2, length, name, difficulty, obstacle, boostpad, removelastobstacle, removelastboostpad, removelastwaypoint.\"
            stop

        if arg-1 is "trackinfo":
            if arg-2 is not set or {tracks::%arg-2%::name} is not set:
                send "{@prefix} &cUsage: /rcadmin race trackinfo <track_id>. Track not found."
                stop
            set {_track_id} to arg-2
            send "{@prefix} &6Track Info for: %{_track_id}% (%{tracks::%{_track_id}%::name}%)"
            send "&e - Length: &b%{tracks::%{_track_id}%::length}% units"
            send "&e - Difficulty: &b%{tracks::%{_track_id}%::difficulty ? "N/A"}%"
            send "&e - Start Location: &b%{tracks::%{_track_id}%::start_location}%"
            send "&e - Waypoints (%size of {tracks::%{_track_id}%::waypoints::*}%):"
            loop {tracks::%{_track_id}%::waypoints::*}:
                send "&7  - %loop-value%"
            send \"&e - Finish Region Corner 1: &b%{tracks::%{_track_id}%::finish_region_loc1}%\"
            send \"&e - Finish Region Corner 2: &b%{tracks::%{_track_id}%::finish_region_loc2}%\"
            send \"&e - Obstacles (%size of {tracks::%{_track_id}%::obstacles::*}%):\"
            loop {tracks::%{_track_id}%::obstacles::*}:
                set {_obs_loc_str} to loop-value
                send \"&7  - Loc: %{_obs_loc_str}%, Type: %{tracks::%{_track_id}%::obstacles::%{_obs_loc_str}%::type}%, Dur: %{tracks::%{_track_id}%::obstacles::%{_obs_loc_str}%::duration}%, Mag: %{tracks::%{_track_id}%::obstacles::%{_obs_loc_str}%::magnitude}%\"
            send \"&e - Boost Pads (%size of {tracks::%{_track_id}%::boost_pads::*}%):\"
            loop {tracks::%{_track_id}%::boost_pads::*}:
                set {_bst_loc_str} to loop-value
                send \"&7  - Loc: %{_bst_loc_str}%, Dur: %{tracks::%{_track_id}%::boost_pads::%{_bst_loc_str}%::duration}%, Mag: %{tracks::%{_track_id}%::boost_pads::%{_bst_loc_str}%::magnitude}%\"
            stop

        send "{@prefix} &cUnknown race admin command. See /rcadmin help (TODO)"

# --- Utility Functions --- #
function formatTimespan(t: timespan) :: text:
    set {_seconds} to total seconds of {_t}
    set {_minutes} to floor({_seconds} / 60)
    set {_remaining_seconds} to {_seconds} mod 60
    return "%%02d:%%.2f" formatted with {_minutes}, {_remaining_seconds} # Corrected formatting string

# TODO: Implement spectator mode
# TODO: Add team racing modes
# TODO: Dynamic track loading from YAML (Phase 4)
# TODO: Track-specific features like obstacles and boosts (Phase 4)
# TODO: More robust finish line detection (e.g., using Skript-Regions or similar addon if available, or more complex location math)
# TODO: Integrate calls to camera.sk for 3rd person camera management
# TODO: Integrate calls to citizens.sk for spawning, moving, and removing race citizens