# File: achievement_system.sk
# Description: Achievement system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Achievement categories
    achievement_categories:
        - "Racing"
        - "Clicking"
        - "Social"
        - "Guild"
        - "Economy"
        - "Collection"
        - "Special"
    
    # Achievement reward types
    achievement_rewards:
        - "ClickCoins"
        - "Speed Boost"
        - "Power Boost"
        - "Prestige Points"
        - "Title"
        - "Custom Item"
    
    # Achievement levels
    achievement_levels:
        - "Bronze"
        - "Silver"
        - "Gold"
        - "Platinum"
        - "Diamond"

# Variables:
# {player::%uuid%::achievements::*} = text (unlocked achievements)
# {player::%uuid%::achievement_progress::*} = number (achievement progress)
# {player::%uuid%::achievement_points} = number (total achievement points)
# {achievement::%id%::name} = text (achievement name)
# {achievement::%id%::description} = text (achievement description)
# {achievement::%id%::category} = text (achievement category)
# {achievement::%id%::reward} = text (achievement reward)
# {achievement::%id%::points} = number (achievement points)
# {achievement::%id%::level} = text (achievement level)
# {achievement::%id%::progress_required} = number (required progress)

# Function to initialize achievements
on join:
    set {_p} to player
    set {_uuid} to {_p}'s uuid
    
    # Initialize achievement variables
    if not {player::%{_uuid}%::achievements::*} is set:
        set {player::%{_uuid}%::achievements::*} to []
    if not {player::%{_uuid}%::achievement_progress::*} is set:
        set {player::%{_uuid}%::achievement_progress::*} to []
    if not {player::%{_uuid}%::achievement_points} is set:
        set {player::%{_uuid}%::achievement_points} to 0

# Function to initialize achievements
function initializeAchievements():
    # Clear existing achievements
    clear {achievement::*}
    
    # Racing Achievements
    registerAchievement("first_race", "First Race", "Complete your first race", "Racing", "Bronze", 10, "ClickCoins", 1)
    registerAchievement("race_winner", "Race Winner", "Win your first race", "Racing", "Silver", 25, "ClickCoins", 1)
    registerAchievement("track_master", "Track Master", "Complete all tracks", "Racing", "Gold", 50, "ClickCoins", 10)
    registerAchievement("speed_demon", "Speed Demon", "Reach 1000 speed multiplier", "Racing", "Platinum", 100, "Speed Boost", 1000)
    
    # Clicking Achievements
    registerAchievement("click_master", "Click Master", "Reach 1,000,000 clicks", "Clicking", "Silver", 50, "ClickCoins", 1000)
    registerAchievement("combo_king", "Combo King", "Achieve 1000x combo multiplier", "Clicking", "Gold", 75, "ClickCoins", 2500)
    registerAchievement("accuracy_perfect", "Perfect Accuracy", "Achieve 100% accuracy", "Clicking", "Diamond", 150, "Power Boost", 1500)
    
    # Social Achievements
    registerAchievement("friendship", "Friendship", "Add 10 friends", "Social", "Bronze", 20, "ClickCoins", 500)
    registerAchievement("guild_master", "Guild Master", "Create a guild", "Social", "Silver", 30, "ClickCoins", 1000)
    registerAchievement("guild_hero", "Guild Hero", "Reach guild rank 10", "Social", "Gold", 100, "Prestige Points", 50)
    
    # Economy Achievements
    registerAchievement("rich_man", "Rich Man", "Reach 1,000,000 ClickCoins", "Economy", "Gold", 100, "ClickCoins", 5000)
    registerAchievement("market_master", "Market Master", "Complete 100 market transactions", "Economy", "Platinum", 150, "ClickCoins", 10000)
    registerAchievement("investor", "Investor", "Reach 1000% market profit", "Economy", "Diamond", 200, "Prestige Points", 100)

# Function to register achievement
function registerAchievement(id: text, name: text, description: text, category: text, level: text, points: number, reward: text, reward_amount: number):
    set {achievement::%{_id}%::name} to {_name}
    set {achievement::%{_id}%::description} to {_description}
    set {achievement::%{_id}%::category} to {_category}
    set {achievement::%{_id}%::level} to {_level}
    set {achievement::%{_id}%::points} to {_points}
    set {achievement::%{_id}%::reward} to {_reward}
    set {achievement::%{_id}%::reward_amount} to {_reward_amount}
    set {achievement::%{_id}%::progress_required} to 1

# Function to check achievement progress
function checkAchievement(p: player, achievement_id: text):
    set {_uuid} to {_p}'s uuid
    
    # Check if achievement is already unlocked
    if not {_achievement_id} is in {player::%{_uuid}%::achievements::*}:
        return
        
    # Check progress
    if {player::%{_uuid}%::achievement_progress::%{_achievement_id}%} >= {achievement::%{_achievement_id}%::progress_required}:
        # Unlock achievement
        add {_achievement_id} to {player::%{_uuid}%::achievements::*}
        add {achievement::%{_achievement_id}%::points} to {player::%{_uuid}%::achievement_points}
        
        # Give reward
        switch {achievement::%{_achievement_id}%::reward}:
            case "ClickCoins":
                add {achievement::%{_achievement_id}%::reward_amount} to {player::%{_uuid}%::clickcoins}
                break
            case "Speed Boost":
                set {player::%{_uuid}%::speed_boost} to true
                break
            case "Power Boost":
                set {player::%{_uuid}%::power_boost} to true
                break
            case "Prestige Points":
                add {achievement::%{_achievement_id}%::reward_amount} to {player::%{_uuid}%::prestige_points}
                break
            case "Title":
                set {player::%{_uuid}%::title} to {achievement::%{_achievement_id}%::reward_amount}
                break
        
        # Notify player
        send "{@prefix} &6Achievement Unlocked: %{achievement::%{_achievement_id}%::name}%" to {_p}
        send "{@prefix} &eDescription: %{achievement::%{_achievement_id}%::description}%" to {_p}
        send "{@prefix} &aReward: %{achievement::%{_achievement_id}%::reward_amount}% %{achievement::%{_achievement_id}%::reward}%" to {_p}
        
        # Broadcast achievement
        broadcast "{@prefix} &6%{_p}% unlocked achievement: %{achievement::%{_achievement_id}%::name}%" to players with permission "raceclicker.achievements.view"

# Function to update achievement progress
function updateAchievementProgress(p: player, achievement_id: text, amount: number):
    set {_uuid} to {_p}'s uuid
    
    # Check if achievement exists
    if {achievement::%{_achievement_id}%::name} is not set:
        return
        
    # Update progress
    if {player::%{_uuid}%::achievement_progress::%{_achievement_id}%} is not set:
        set {player::%{_uuid}%::achievement_progress::%{_achievement_id}%} to {_amount}
    else:
        add {_amount} to {player::%{_uuid}%::achievement_progress::%{_achievement_id}%}
        
    # Check if achievement is unlocked
    checkAchievement({_p}, {_achievement_id})

# Achievement triggers
# TODO: These are custom events that need to be called from other scripts
# on race completion:
#     set {_p} to player
#     set {_uuid} to {_p}'s uuid
#     
#     # Update racing achievements
#     updateAchievementProgress({_p}, "first_race", 1)
#     updateAchievementProgress({_p}, "race_winner", 1)
#     updateAchievementProgress({_p}, "track_master", 1)
#     updateAchievementProgress({_p}, "speed_demon", {player::%{_uuid}%::speed_multiplier})

on click:
    set {_p} to player
    set {_uuid} to {_p}'s uuid
    
    # Update clicking achievements
    updateAchievementProgress({_p}, "click_master", 1)
    updateAchievementProgress({_p}, "combo_king", {player::%{_uuid}%::combo_multiplier})
    updateAchievementProgress({_p}, "accuracy_perfect", {player::%{_uuid}%::accuracy})

# TODO: These are custom events that need to be called from other scripts
# on market transaction:
#     set {_p} to player
#     set {_uuid} to {_p}'s uuid
#     
#     # Update economy achievements
#     updateAchievementProgress({_p}, "rich_man", 1)
#     updateAchievementProgress({_p}, "market_master", 1)
#     updateAchievementProgress({_p}, "investor", 1)

# Achievement commands
command /achievements:
    permission: raceclicker.achievements.view
    trigger:
        set {_p} to player
        set {_uuid} to {_p}'s uuid
        
        # Get unlocked achievements
        set {_unlocked} to "&6Achievements Unlocked:\n"
        loop {player::%{_uuid}%::achievements::*}:
            set {_achievement_id} to loop-value
            append "&7- %{achievement::%{_achievement_id}%::name}% &8(&6%{achievement::%{_achievement_id}%::level}%&8)\n" to {_unlocked}
            
        # Get progress
        set {_progress} to "&6Achievement Progress:\n"
        loop all achievements:
            set {_achievement_id} to loop-key
            if {_achievement_id} is not in {player::%{_uuid}%::achievements::*}:
                set {_current} to {player::%{_uuid}%::achievement_progress::%{_achievement_id}%} ? 0
                set {_required} to {achievement::%{_achievement_id}%::progress_required}
                append "&7- %{achievement::%{_achievement_id}%::name}%: %{_current}%/%{_required}%\n" to {_progress}
                
        # Send info
        send "{@prefix} %{_unlocked}%" to {_p}
        send "{@prefix} %{_progress}%" to {_p}

command /achievementinfo <text>:
    permission: raceclicker.achievements.view
    trigger:
        set {_p} to player
        set {_uuid} to {_p}'s uuid
        
        # Get achievement info
        set {_achievement_id} to arg-1
        if not {achievement::%{_achievement_id}%::name} is set:
            send "{@prefix} &cAchievement not found!" to {_p}
            return
            
        # Get achievement details
        set {_name} to {achievement::%{_achievement_id}%::name}
        set {_description} to {achievement::%{_achievement_id}%::description}
        set {_category} to {achievement::%{_achievement_id}%::category}
        set {_level} to {achievement::%{_achievement_id}%::level}
        set {_points} to {achievement::%{_achievement_id}%::points}
        set {_reward} to {achievement::%{_achievement_id}%::reward}
        set {_reward_amount} to {achievement::%{_achievement_id}%::reward_amount}
        
        # Get player progress
        if not {player::%{_uuid}%::achievement_progress::%{_achievement_id}%} is set:
            set {player::%{_uuid}%::achievement_progress::%{_achievement_id}%} to 0
        set {_progress} to {player::%{_uuid}%::achievement_progress::%{_achievement_id}%}
        
        # Send achievement info
        send "{@prefix} &6Achievement Info:" to {_p}
        send "{@prefix} &eName: &a%{_name}%" to {_p}
        send "{@prefix} &eCategory: &a%{_category}%" to {_p}
        send "{@prefix} &eLevel: &a%{_level}%" to {_p}
        send "{@prefix} &eDescription: &a%{_description}%" to {_p}
        send "{@prefix} &ePoints: &a%{_points}%" to {_p}
        send "{@prefix} &eReward: &a%{_reward}%: %{_reward_amount}%" to {_p}
        send "{@prefix} &eProgress: &a%{_progress}%" to {_p}
# File: admin.sk
# Path: race-clicker/admin/admin.sk
# Description: Admin tools for Race Clicker Skript

options:
    prefix: &6&lRaceClicker &c&lAdmin &8» # Admin-specific prefix
    admin_permission: "raceclicker.admin" # Permission node for admin commands

# --- Phase 1: Fix and Complete Core Systems ---
# - TODO: Add commands to reset player data (specific variables or all)
# - TODO: Add commands to modify player variables (clicks, speed, etc.)

# --- Phase 7: Performance and Anti-Cheat ---
# Implement Anti-Cheat Measures
# - TODO: Command to view player's click rate or other suspicious metrics
# - TODO: Command to temporarily ban or kick players based on cheat detection (manual override)
# Optimize Performance
# - TODO: Command to view server performance metrics related to the Skript (TPS, variable counts - if possible)
# - TODO: Command to clear specific caches if implemented (e.g., leaderboard cache)

# --- Phase 8: Content and Progression Systems ---
# Prestige System
# - TODO: Integrate with prestige.sk admin commands (already has /rcprestigeadmin)
# Achievement System
# - TODO: Command to grant/revoke specific achievements for a player
# - TODO: Command to reset all achievements for a player

# --- Phase 6: Multiplayer Features (Tournaments) ---
# - TODO: Integrate with tournaments.sk admin commands (already has /rctournamentadmin)

# --- General Admin Commands ---

command /rcadmin [<text>] [<text>] [<player>] [<text>]:
    permission: {@admin_permission}
    permission message: &cYou do not have permission to use RaceClicker admin commands.
    trigger:
        if arg-1 is not set:
            send "{@prefix} &7Available commands:"
            send "&e/rcadmin reload &7- Reloads RaceClicker Skripts (requires Skript's reload functionality)."
            send "&e/rcadmin set <variable> <player> <value> &7- Sets a player's variable (e.g., clicks, speedlevel)."
            send "&e/rcadmin get <variable> <player> &7- Gets a player's variable value."
            send "&e/rcadmin resetdata <player> [confirm] &7- Resets all RaceClicker data for a player."
            send "&e/rcadmin giveclicks <player> <amount> &7- Gives a player a specified amount of clicks."
            # Add more help lines as commands are implemented
            stop

        # Reload command (conceptual - Skript handles its own reloads)
        if arg-1 is "reload":
            send "{@prefix} &7Attempting to reload RaceClicker Skripts..."
            # This typically requires a full Skript reload, e.g., /sk reload all or /sk reload race-clicker
            # Direct Skript reloading from within another Skript is not standard.
            # Advise admin to use Skript's own reload commands.
            send "{@prefix} &ePlease use &b/sk reload all &eor &b/sk reload <script_name>&e for full effect."
            stop

        # Set player variable
        if arg-1 is "set":
            if arg-2 is not set or arg-3 is not set or arg-4 is not set:
                send "{@prefix} &cUsage: /rcadmin set <variable_name> <player> <value>"
                send "{@prefix} &7Example: /rcadmin set clicks Notch 1000"
                send "{@prefix} &7Valid variables: clicks, speedlevel, autoclicklevel, prestigelevel, raceswon, etc."
                stop
            set {_variable_name} to lowercased arg-2
            set {_target_player} to arg-3
            # Attempt to parse value as number, but some might be text
            set {_value_text} to arg-4
            set {_value_num} to {_value_text} parsed as number

            send "{@prefix} &7Attempting to set &e%{_variable_name}%&7 for player &b%{_target_player}%&7 to &a%{_value_text}%&7..."
            # This requires knowing the exact variable names used in data.sk
            # Example for 'clicks':
            if {_variable_name} is "clicks":
                if {_value_num} is not set:
                    send "{@prefix} &cInvalid number for clicks: %{_value_text}%"
                    stop
                set {player::%{_target_player}'s uuid%::clicks} to {_value_num}
                send "{@prefix} &aSuccessfully set clicks for %{_target_player}% to %{_value_num}%."
            else if {_variable_name} is "speedlevel":
                if {_value_num} is not set:
                    send "{@prefix} &cInvalid number for speedlevel: %{_value_text}%"
                    stop
                set {player::%{_target_player}'s uuid%::speed_level} to {_value_num}
                send "{@prefix} &aSuccessfully set speed level for %{_target_player}% to %{_value_num}%."
            # Add more 'else if' for other variables like autoclicklevel, prestigelevel, raceswon
            # else if {_variable_name} is "autoclicklevel": ...
            # else if {_variable_name} is "prestigelevel": ...
            # else if {_variable_name} is "raceswon": ...
            else:
                send "{@prefix} &cUnknown or unhandled variable: &e%{_variable_name}%&c. Check variable name."
            stop

        # Get player variable
        if arg-1 is "get":
            if arg-2 is not set or arg-3 is not set:
                send "{@prefix} &cUsage: /rcadmin get <variable_name> <player>"
                stop
            set {_variable_name} to lowercased arg-2
            set {_target_player} to arg-3
            set {_player_uuid} to uuid of {_target_player}

            if {_player_uuid} is not set:
                send "{@prefix} &cPlayer %{_target_player}% not found or never joined."
                stop

            send "{@prefix} &7Fetching &e%{_variable_name}%&7 for player &b%{_target_player}%&7..."
            if {_variable_name} is "clicks":
                send "{@prefix} &b%{_target_player}%&7's clicks: &a%{player::%{_player_uuid}%::clicks ? 0}%"
            else if {_variable_name} is "speedlevel":
                send "{@prefix} &b%{_target_player}%&7's speed level: &a%{player::%{_player_uuid}%::speed_level ? 0}%"
            # Add more 'else if' for other variables
            else:
                send "{@prefix} &cUnknown or unhandled variable: &e%{_variable_name}%&c. Check variable name."
            stop

        # Reset player data
        if arg-1 is "resetdata":
            if arg-2 is not set:
                send "{@prefix} &cUsage: /rcadmin resetdata <player> [confirm]"
                stop
            set {_target_player} to arg-2
            set {_player_uuid} to uuid of {_target_player}

            if {_player_uuid} is not set:
                send "{@prefix} &cPlayer %{_target_player}% not found or never joined."
                stop

            if arg-3 is not "confirm":
                send "{@prefix} &cWARNING: This will delete ALL RaceClicker data for %{_target_player}%."
                send "{@prefix} &cTo confirm, type: &e/rcadmin resetdata %{_target_player}% confirm"
                stop

            send "{@prefix} &7Resetting all data for player &b%{_target_player}%&7..."
            # Delete all known player variables. This needs to be comprehensive.
            delete {player::%{_player_uuid}%::clicks}
            delete {player::%{_player_uuid}%::speed_level}
            delete {player::%{_player_uuid}%::autoclicker_level}
            delete {player::%{_player_uuid}%::prestige_level}
            delete {player::%{_player_uuid}%::prestige_points}
            delete {player::%{_player_uuid}%::races_won}
            delete {player::%{_player_uuid}%::total_races_participated}
            # Delete achievement-related variables if any are player-specific and stored directly
            # loop all achievements:
            #    delete {player_achievements::%{_player_uuid}%::%loop-value%}
            # Delete any other custom variables
            # ... (add more as needed)

            # Re-initialize with default values (similar to on join in data.sk)
            # This part is crucial to ensure the player can continue playing without errors.
            # It's better to call a function from data.sk if one exists for initializing new player data.
            # For now, manually set defaults:
            set {player::%{_player_uuid}%::clicks} to 0
            set {player::%{_player_uuid}%::speed_level} to 1
            set {player::%{_player_uuid}%::autoclicker_level} to 0
            set {player::%{_player_uuid}%::prestige_level} to 0
            set {player::%{_player_uuid}%::prestige_points} to 0
            set {player::%{_player_uuid}%::races_won} to 0
            set {player::%{_player_uuid}%::total_races_participated} to 0

            send "{@prefix} &aSuccessfully reset all RaceClicker data for &b%{_target_player}%&a and initialized defaults."
            if {_target_player} is online:
                send "{@prefix} &eYour RaceClicker data has been reset by an administrator." to {_target_player}
            stop

        # Give clicks
        if arg-1 is "giveclicks":
            if arg-2 is not set or arg-3 is not set:
                send "{@prefix} &cUsage: /rcadmin giveclicks <player> <amount>"
                stop
            set {_target_player} to arg-2
            set {_amount} to arg-3 parsed as number
            set {_player_uuid} to uuid of {_target_player}

            if {_player_uuid} is not set:
                send "{@prefix} &cPlayer %{_target_player}% not found or never joined."
                stop
            if {_amount} is not set or {_amount} <= 0:
                send "{@prefix} &cInvalid amount: %arg-3%"
                stop

            add {_amount} to {player::%{_player_uuid}%::clicks}
            send "{@prefix} &aGave &e%{_amount}% clicks &ato &b%{_target_player}%&a. New total: &e%{player::%{_player_uuid}%::clicks}%".
            if {_target_player} is online:
                send "{@prefix} &aYou have received &e%{_amount}% clicks &afrom an administrator." to {_target_player}
            stop

        send "{@prefix} &cUnknown command. Type &e/rcadmin &cfor help."

# TODO: Add more specific admin commands as per the plan
# - Achievement management: /rcadmin achievement <grant|revoke|reset> <player> [achievement_id]
# - Anti-cheat related: /rcadmin checkclicks <player>, /rcadmin rckick <player> [reason]
# - Performance: /rcadmin perfstats, /rcadmin clearcache <cache_name>

# Placeholder for a function to be called from data.sk to initialize a player
# This avoids duplicating the default value logic.
# function initializePlayerDataAdmin(p: player):
#    # Call the function from data.sk, e.g.:
#    # initializeNewPlayerData({_p}) # Assuming such a function exists in data.sk
#    send debug "[Admin] initializePlayerDataAdmin called for %{_p}% (should call data.sk function)"
# File: player_data_reset_command.sk
# Path: race-clicker/admin/player_data_reset_command.sk
# Description: Admin command to reset player data for Race Clicker.

options:
    prefix: "&6&lRaceClicker &8»"
    admin_permission: "raceclicker.admin.resetdata"

# Command to reset player data
# /rcreset <player> <data_type> [confirm]
# data_type can be: clicks, speed_level, autoclicker_level, prestige_level, prestige_points, achievements, race_stats, all
command /rcreset [<offlineplayer>] [<text>] [<text>]:
    permission: {@admin_permission}
    trigger:
        if arg-1 is not set or arg-2 is not set:
            send "{@prefix} &cUsage: /rcreset <player> <data_type> [confirm]"
            send "{@prefix} &7Data types: clicks, speed, autoclicker, prestigelevel, prestigepoints, achievements, racestats, all"
            stop

        set {_target_player} to arg-1
        set {_data_type} to lowercased arg-2
        set {_uuid} to uuid of {_target_player}

        if {_uuid} is not set:
            send "{@prefix} &cPlayer '%arg-1%' not found or has never played."
            stop

        if arg-3 is not "confirm":
            send "{@prefix} &eWARNING: You are about to reset %{_data_type}% data for player %name of {_target_player}%."
            send "{@prefix} &eThis action is IRREVERSIBLE."
            send "{@prefix} &eTo confirm, run the command again with 'confirm' at the end:"
            send "{@prefix} &f/rcreset %name of {_target_player}% %{_data_type}% confirm"
            stop

        send "{@prefix} &7Attempting to reset %{_data_type}% data for %name of {_target_player}% (UUID: %{_uuid}%)..."

        if {_data_type} is "clicks" or {_data_type} is "all":
            delete {player::%{_uuid}%::clicks}
            send "{@prefix} &aClicks data reset for %name of {_target_player}%."
            if {_data_type} is not "all":
                stop

        if {_data_type} is "speed" or {_data_type} is "speed_level" or {_data_type} is "all":
            delete {player::%{_uuid}%::speed-level} # Assuming variable name from shop.sk
            send "{@prefix} &aSpeed level data reset for %name of {_target_player}%."
            if {_data_type} is not "all":
                stop

        if {_data_type} is "autoclicker" or {_data_type} is "autoclicker_level" or {_data_type} is "all":
            delete {player::%{_uuid}%::autoclicker-level} # Assuming variable name from shop.sk
            send "{@prefix} &aAuto-clicker level data reset for %name of {_target_player}%."
            if {_data_type} is not "all":
                stop

        if {_data_type} is "prestigelevel" or {_data_type} is "prestige_level" or {_data_type} is "all":
            delete {player::%{_uuid}%::prestige-level} # Assuming variable name from prestige.sk
            send "{@prefix} &aPrestige level data reset for %name of {_target_player}%."
            if {_data_type} is not "all":
                stop

        if {_data_type} is "prestigepoints" or {_data_type} is "prestige_points" or {_data_type} is "all":
            delete {player::%{_uuid}%::prestige-points} # Assuming variable name from prestige.sk
            send "{@prefix} &aPrestige points data reset for %name of {_target_player}%."
            if {_data_type} is not "all":
                stop

        if {_data_type} is "achievements" or {_data_type} is "all":
            delete {player::%{_uuid}%::achievements::*} # Resets all unlocked achievements
            send "{@prefix} &aAchievements data reset for %name of {_target_player}%."
            if {_data_type} is not "all":
                stop

        if {_data_type} is "racestats" or {_data_type} is "race_stats" or {_data_type} is "all":
            delete {player::%{_uuid}%::races_won}
            delete {player::%{_uuid}%::total_races_participated}
            # Add any other race-specific stats here, e.g., best times per track if stored under player UUID
            send "{@prefix} &aRace stats (wins, participated) reset for %name of {_target_player}%."
            if {_data_type} is not "all":
                stop
        
        if {_data_type} is "all":
            send "{@prefix} &aAll specified data categories have been reset for %name of {_target_player}%."
        else:
            send "{@prefix} &cUnknown data type '%{_data_type}%'. No data was reset."
            send "{@prefix} &7Valid types: clicks, speed, autoclicker, prestigelevel, prestigepoints, achievements, racestats, all"
# File: track_builder.sk
# Description: Track building and management system for Race Clicker

options:
    prefix: &6&lRaceClicker &8» &aTrackBuilder &8»
    track_builder_permission: "raceclicker.admin.trackbuilder"
    
# Variables:
# {admin::%player's uuid%::building_track_id} - ID of track being built
# {admin::%player's uuid%::last_waypoint} - Last waypoint location
# {admin::%player's uuid%::building_mode} - Current building mode (waypoint, start, finish)

# Command to start building a track
command /buildtrack [<text>]:
    permission: {%track_builder_permission%}
    trigger:
        if arg-1 is not set:
            send "{@prefix} &cUsage: /buildtrack <track_id>"
            stop
        
        set {_uuid} to player's uuid
        set {_track_id} to arg-1
        
        # Check if track already exists
        if {tracks::%{_track_id}%::name} is set:
            send "{@prefix} &cTrack %{_track_id}% already exists!"
            stop
        
        # Initialize track variables
        set {admin::%{_uuid}%::building_track_id} to {_track_id}
        set {admin::%{_uuid}%::building_mode} to "start"
        set {admin::%{_uuid}%::last_waypoint} to player's location
        
        send "{@prefix} &aStarting track build for %{_track_id}%"
        send "{@prefix} &eLeft-click to set start location"
        send "{@prefix} &eRight-click to set waypoints"
        send "{@prefix} &eShift+Right-click to set finish region"
        send "{@prefix} &eUse /savepoints to save current track"

# Command to save track points
command /savepoints:
    permission: {%track_builder_permission%}
    trigger:
        set {_uuid} to player's uuid
        set {_track_id} to {admin::%{_uuid}%::building_track_id}
        
        if {_track_id} is not set:
            send "{@prefix} &cNo track is being built! Use /buildtrack first."
            stop
        
        # Validate track data
        if not {admin::%{_uuid}%::last_waypoint} is set:
            send "{@prefix} &cNo start location set!"
            stop
        if size of {admin::%{_uuid}%::waypoints::*} < 2:
            send "{@prefix} &cNot enough waypoints! (Need at least 2)"
            stop
        if not {admin::%{_uuid}%::finish_region} is set:
            send "{@prefix} &cNo finish region set!"
            stop

        # Save track data
        set {tracks::%{_track_id}%::name} to "Track %{_track_id}%"
        set {tracks::%{_track_id}%::start_location} to {admin::%{_uuid}%::last_waypoint}
        set {tracks::%{_track_id}%::waypoints::*} to {admin::%{_uuid}%::waypoints::*}
        set {tracks::%{_track_id}%::finish_region} to {admin::%{_uuid}%::finish_region}

        # Calculate track length from waypoints
        set {_length} to 0
        loop {tracks::%{_track_id}%::waypoints::*}:
            if loop-index > 1:
                set {_prev_loc} to element at loop-index - 1 of {tracks::%{_track_id}%::waypoints::*}
                set {_current_loc} to loop-value
                add magnitude of ({_current_loc} subtract {_prev_loc}) to {_length}
        set {tracks::%{_track_id}%::length} to {_length}
        
        # Calculate track length from waypoints
        set {_length} to 0
        loop {tracks::%{_track_id}%::waypoints::*}:
            if loop-index > 1:
                set {_prev_loc} to loop-value-1
                set {_current_loc} to loop-value
                add magnitude of ({_current_loc} subtract {_prev_loc}) to {_length}
        
        set {tracks::%{_track_id}%::length} to {_length}
        
        send "{@prefix} &aTrack %{_track_id}% saved successfully!"
        send "{@prefix} &eTrack length: %{_length}% blocks"
        send "{@prefix} &eWaypoints: %size of {tracks::%{_track_id}%::waypoints::*}%"
        
        # Clean up
        delete {admin::%{_uuid}%::building_track_id}
        delete {admin::%{_uuid}%::building_mode}
        delete {admin::%{_uuid}%::last_waypoint}
        delete {admin::%{_uuid}%::waypoints::*}
        delete {admin::%{_uuid}%::finish_region}

# Command to list all tracks
command /listtracks:
    permission: {%track_builder_permission%}
    trigger:
        send "{@prefix} &aAvailable Tracks:" to player
        loop all keys of {tracks::*}:
            if loop-value starts with "::":
                continue
            send "&7- %{loop-value}% &8(&6%{tracks::%{loop-value}%::length}% blocks&8)" to player

# Command to test a track
command /testtrack [<text>]:
    permission: {%track_builder_permission%}
    trigger:
        if arg-1 is not set:
            send "{@prefix} &cUsage: /testtrack <track_id>"
            stop
        
        set {_track_id} to arg-1
        if {tracks::%{_track_id}%::name} is not set:
            send "{@prefix} &cTrack %{_track_id}% not found!"
            stop
        
        # Create test citizen
        create new citizen named "TestCitizen_%{_track_id}%" at {tracks::%{_track_id}%::start_location}
        set {_citizen} to last created citizen
        
        # Set waypoints
        set {_waypoints} to {tracks::%{_track_id}%::waypoints::*}
        loop {_waypoints}:
            set {_loc} to loop-value
            set {_citizen}'s location to {_loc}
            wait 1 second
        
        # Test finish region
        set {_citizen}'s location to {tracks::%{_track_id}%::finish_region}
        wait 1 second
        
        # Clean up
        remove {_citizen}
        
        send "{@prefix} &aTrack test completed!"

# Building mode changes
on left click:
    if player has permission {%track_builder_permission%}:
        set {_uuid} to player's uuid
        if {admin::%{_uuid}%::building_track_id} is set:
            set {admin::%{_uuid}%::building_mode} to "start"
            send "{@prefix} &aBuilding mode: &eStart Location"
            set {admin::%{_uuid}%::last_waypoint} to player's location

on right click:
    if player has permission {%track_builder_permission%}:
        set {_uuid} to player's uuid
        if {admin::%{_uuid}%::building_track_id} is set:
            if {admin::%{_uuid}%::building_mode} is "start":
                set {admin::%{_uuid}%::building_mode} to "waypoint"
                send "{@prefix} &aBuilding mode: &eWaypoints"
            else:
                set {_current_loc} to player's location
                if {admin::%{_uuid}%::last_waypoint} is set:
                    add {_current_loc} to {admin::%{_uuid}%::waypoints::*}
                    set {admin::%{_uuid}%::last_waypoint} to {_current_loc}
                    send "{@prefix} &aAdded waypoint %{size of {admin::%{_uuid}%::waypoints::*}}%"

on shift right click:
    if player has permission {%track_builder_permission%}:
        set {_uuid} to player's uuid
        if {admin::%{_uuid}%::building_track_id} is set:
            set {_current_loc} to player's location
            set {admin::%{_uuid}%::finish_region} to {_current_loc}
            send "{@prefix} &aSet finish region at %{_current_loc}%"
            set {admin::%{_uuid}%::building_mode} to "start"
            send "{@prefix} &aBuilding mode: &eStart Location"
            
            # Show finish region particles
            loop 20 times:
                set {_offset} to vector(random between -1 and 1, 0, random between -1 and 1)
                spawn particle "end_rod" at {_current_loc} add {_offset}
# File: finish_line_cameras.sk
# Description: Cinematic finish line camera effects and transitions

options:
    prefix: &6&lRaceClicker &8»
    # Camera settings
    finish_line_distance: 10 blocks # Distance before finish line to trigger cinematic
    finish_line_duration: 5 seconds # Duration of finish line camera
    finish_line_zoom: 0.5 # Camera zoom factor
    finish_line_effect_duration: 2 seconds # Duration of finish line effects
    
# Variables:
# {player::%uuid%::in_finish_camera} = boolean (in finish line camera)
# {player::%uuid%::finish_camera_start_time} = timestamp (when finish camera started)
# {player::%uuid%::finish_camera_target} = location (target location)

# Function to check if player is near finish line
function isNearFinishLine(p: player) -> boolean:
    set {_uuid} to {_p}'s uuid
    set {_citizen_loc} to location of entity from uuid {player::%{_uuid}%::race_citizen_entity_id}
    set {_finish_region} to cuboid region from {tracks::%{player::%{_uuid}%::current_track_id}%::finish_region_loc1} to {tracks::%{player::%{_uuid}%::current_track_id}%::finish_region_loc2}
    return {_citizen_loc} is in {_finish_region}

# Function to start finish line camera
every 1 tick:
    loop all players:
        if {player::%loop-player's uuid%::in_race} is true:
            set {_p} to loop-player
            set {_uuid} to {_p}'s uuid
            
            if isNearFinishLine({_p}) is true:
                if {player::%{_uuid}%::in_finish_camera} is not true:
                    startFinishLineCamera({_p})
            else if {player::%{_uuid}%::in_finish_camera} is true:
                endFinishLineCamera({_p})

# Function to start finish line camera
function startFinishLineCamera(p: player):
    set {_uuid} to {_p}'s uuid
    set {player::%{_uuid}%::in_finish_camera} to true
    set {player::%{_uuid}%::finish_camera_start_time} to now
    
    # Get citizen location
    set {_citizen} to entity from uuid {player::%{_uuid}%::race_citizen_entity_id}
    set {_citizen_loc} to location of {_citizen}
    set {player::%{_uuid}%::finish_camera_target} to {_citizen_loc}
    
    # Start camera transition
    set camera location of {_p} to {_citizen_loc} add vector(0, 2, -5)
    set camera rotation of {_p} to look at {_citizen_loc}
    
    # Start zoom effect
    set {_zoom} to 1.0
    loop 20 times:
        set {_zoom} to {_zoom} - 0.025
        set camera zoom of {_p} to {_zoom}
        wait 1 tick
    
    # Play finish line effects
    spawn 20 of particle "happy_villager" at {_citizen_loc}
    play sound "minecraft:entity.firework_rocket.launch" to {_p} with volume 1 pitch 1.5
    
    # Send message
    send "{@prefix} &aApproaching Finish Line!" to {_p}

# Function to end finish line camera
function endFinishLineCamera(p: player):
    set {_uuid} to {_p}'s uuid
    
    # Reset camera
    set camera zoom of {_p} to 1.0
    set camera location of {_p} to location of {_p}
    set camera rotation of {_p} to look at location of {_p} add vector(0, 1, 0)
    
    # Reset variables
    set {player::%{_uuid}%::in_finish_camera} to false
    set {player::%{_uuid}%::finish_camera_start_time} to null
    set {player::%{_uuid}%::finish_camera_target} to null
    
    # Play finish sound
    play sound "minecraft:entity.player.levelup" to {_p} with volume 1 pitch 1.2

# Function to update finish line camera position
every 1 tick:
    loop all players:
        if {player::%loop-player's uuid%::in_finish_camera} is true:
            set {_p} to loop-player
            set {_uuid} to {_p}'s uuid
            
            # Get citizen location
            set {_citizen} to entity from uuid {player::%{_uuid}%::race_citizen_entity_id}
            set {_citizen_loc} to location of {_citizen}
            
            # Update camera position
            set camera location of {_p} to {_citizen_loc} add vector(0, 2, -5)
            set camera rotation of {_p} to look at {_citizen_loc}
            
            # Check if finish line duration has passed
            if {player::%{_uuid}%::finish_camera_start_time} is set:
                set {_duration} to now - {player::%{_uuid}%::finish_camera_start_time}
                if {_duration} >= {@finish_line_duration}:
                    endFinishLineCamera({_p})

# Function to add finish line effects
function addFinishLineEffects(p: player):
    set {_uuid} to {_p}'s uuid
    
    # Get citizen location
    set {_citizen} to entity from uuid {player::%{_uuid}%::race_citizen_entity_id}
    set {_citizen_loc} to location of {_citizen}
    
    # Spawn particle effects
    loop 50 times:
        set {_angle} to loop-number * (360 / 50)
        set {_offset} to vector(sin({_angle}), 0, cos({_angle})) multiply 2
        spawn particle "happy_villager" at {_citizen_loc} add {_offset}
    
    # Play celebration sounds
    play sound "minecraft:entity.player.levelup" to {_p} with volume 1 pitch 1.2
    play sound "minecraft:entity.experience_orb.pickup" to {_p} with volume 1 pitch 1.5
    
    # Show title
    send title "&6Race Complete!" to {_p} with subtitle "&eGreat Job!" for 3 seconds

# Function to check if finish line camera is active
function isFinishLineCameraActive(p: player) -> boolean:
    set {_uuid} to {_p}'s uuid
    return {player::%{_uuid}%::in_finish_camera} is true
# File: race_cameras.sk
# Description: Race-specific camera angles and views

options:
    prefix: &6&lRaceClicker &8»
    # Camera modes
    camera_modes: "follow,behind,side,above,free" # Available camera modes
    # Camera settings
    follow_distance: 3 blocks # Distance behind for follow camera
    follow_height: 1.5 blocks # Height above ground for follow camera
    side_offset: 4 blocks # Horizontal offset for side camera
    side_height: 2 blocks # Height above ground for side camera
    above_height: 5 blocks # Height above for above camera
    free_camera_speed: 0.5 # Speed multiplier for free camera movement
    
# Variables:
# {player::%uuid%::camera_mode} = text (current camera mode)
# {player::%uuid%::free_camera_location} = location (for free camera mode)
# {player::%uuid%::free_camera_target} = location (target location in free camera mode)

# Function to set camera mode
function setCameraMode(p: player, mode: text):
    set {_uuid} to {_p}'s uuid
    set {player::%{_uuid}%::camera_mode} to {_mode}
    
    # Send message
    send "{@prefix} &aCamera Mode: &e%{_mode}%" to {_p}
    
    # Update camera position
    updateCameraPosition({_p})

# Function to update camera position
function updateCameraPosition(p: player):
    set {_uuid} to {_p}'s uuid
    set {_mode} to {player::%{_uuid}%::camera_mode} ? "follow"
    
    if {player::%{_uuid}%::race_citizen_entity_id} is not set:
        return
    
    set {_citizen} to entity from uuid {player::%{_uuid}%::race_citizen_entity_id}
    set {_citizen_loc} to location of {_citizen}
    
    if {_mode} is "follow":
        # Follow camera behind citizen
        set {_camera_loc} to {_citizen_loc} add vector(0, {@follow_height}, -{@follow_distance})
    else if {_mode} is "behind":
        # Fixed behind view
        set {_camera_loc} to {_citizen_loc} add vector(0, {@follow_height}, -{@follow_distance})
    else if {_mode} is "side":
        # Side view
        set {_camera_loc} to {_citizen_loc} add vector({@side_offset}, {@side_height}, 0)
    else if {_mode} is "above":
        # Top-down view
        set {_camera_loc} to {_citizen_loc} add vector(0, {@above_height}, 0)
    else if {_mode} is "free":
        # Free camera mode
        if {player::%{_uuid}%::free_camera_location} is not set:
            set {player::%{_uuid}%::free_camera_location} to {_citizen_loc}
        set {_camera_loc} to {player::%{_uuid}%::free_camera_location}
    
    # Update camera position
    set camera location of {_p} to {_camera_loc}
    
    # Update camera rotation
    if {_mode} is not "free":
        set {_look_at} to {_citizen_loc}
        set camera rotation of {_p} to look at {_look_at}

# Function to handle free camera movement
every 1 tick:
    loop all players:
        if {player::%loop-player's uuid%::camera_mode} is "free":
            set {_p} to loop-player
            set {_uuid} to {_p}'s uuid
            
            # Get movement input
            set {_forward} to 0
            set {_right} to 0
            
            if {_p} is holding "forward":
                add 1 to {_forward}
            if {_p} is holding "back":
                subtract 1 from {_forward}
            if {_p} is holding "left":
                subtract 1 from {_right}
            if {_p} is holding "right":
                add 1 to {_right}
            
            # Calculate movement vector
            set {_move_vec} to vector({_right}, 0, {_forward})
            
            # Get current location
            set {_loc} to {player::%{_uuid}%::free_camera_location}
            
            # Move camera
            set {_new_loc} to {_loc} add {_move_vec} multiply {@free_camera_speed}
            set {player::%{_uuid}%::free_camera_location} to {_new_loc}
            
            # Update camera position
            set camera location of {_p} to {_new_loc}

# Command to change camera mode
command /camera <text>:
    trigger:
        if arg-1 is in {@camera_modes}:
            setCameraMode(player, arg-1)
        else:
            send "{@prefix} &cInvalid camera mode! Available modes: %{@camera_modes}%" to player

# Command to list available camera modes
command /cameras:
    trigger:
        send "{@prefix} &aAvailable Camera Modes:" to player
        loop {@camera_modes} split by ",":
            send "&e- %loop-value%" to player

# Function to get current camera mode
function getCurrentCameraMode(p: player) :: text:
    set {_uuid} to {_p}'s uuid
    return {player::%{_uuid}%::camera_mode} ? "follow"

# Function to reset camera to default
function resetCamera(p: player):
    set {_uuid} to {_p}'s uuid
    set {player::%{_uuid}%::camera_mode} to "follow"
    updateCameraPosition({_p})
# File: spectator_mode.sk
# Description: Spectator mode camera system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    spectator_modes: "follow,free,track" # Available spectator modes
    spectator_follow_distance: 4 blocks # Distance to follow players
    spectator_follow_height: 2 blocks # Height above ground
    spectator_free_speed: 0.8 # Speed multiplier for free movement
    spectator_track_smoothness: 0.5 # Smoothing factor for track camera
    
# Variables:
# {spectator::%uuid%::mode} = text (current spectator mode)
# {spectator::%uuid%::target_player} = text (target player UUID)
# {spectator::%uuid%::free_location} = location (for free mode)
# {spectator::%uuid%::track_position} = number (current track position)

# Function to enable spectator mode
function enableSpectatorMode(p: player):
    set {_uuid} to {_p}'s uuid
    set {spectator::%{_uuid}%::mode} to "follow"
    set {spectator::%{_uuid}%::target_player} to null
    set {spectator::%{_uuid}%::free_location} to location of {_p}
    set {spectator::%{_uuid}%::track_position} to 0
    
    # Send message
    send "{@prefix} &aSpectator Mode Enabled!" to {_p}
    
    # Hide player's body
    hide {_p} from {_p}
    
    # Set initial camera position
    updateSpectatorCamera({_p})

# Function to disable spectator mode
function disableSpectatorMode(p: player):
    set {_uuid} to {_p}'s uuid
    delete {spectator::%{_uuid}%::*}
    
    # Show player's body
    show {_p} to {_p}
    
    # Reset camera
    set camera location of {_p} to location of {_p}
    set camera rotation of {_p} to look at location of {_p} add vector(0, 1, 0)
    
    # Send message
    send "{@prefix} &cSpectator Mode Disabled!" to {_p}

# Function to update spectator camera position
every 1 tick:
    loop all players:
        if {spectator::%loop-player's uuid%::mode} is set:
            set {_p} to loop-player
            set {_uuid} to {_p}'s uuid
            set {_mode} to {spectator::%{_uuid}%::mode}
            
            if {_mode} is "follow":
                # Follow mode
                if {spectator::%{_uuid}%::target_player} is set:
                    set {_target} to player from uuid {spectator::%{_uuid}%::target_player}
                    if {_target} is not null:
                        set {_target_loc} to location of {_target}
                        set {_camera_loc} to {_target_loc} add vector(0, {@spectator_follow_height}, -{@spectator_follow_distance})
                        set camera location of {_p} to {_camera_loc}
                        set camera rotation of {_p} to look at {_target_loc}
            else if {_mode} is "free":
                # Free movement mode
                set {_loc} to {spectator::%{_uuid}%::free_location} ? location of {_p}
                
                # Get movement input
                set {_forward} to 0
                set {_right} to 0
                
                if {_p} is holding "forward":
                    add 1 to {_forward}
                if {_p} is holding "back":
                    subtract 1 from {_forward}
                if {_p} is holding "left":
                    subtract 1 from {_right}
                if {_p} is holding "right":
                    add 1 to {_right}
                
                # Calculate movement vector
                set {_move_vec} to vector({_right}, 0, {_forward})
                
                # Move camera
                set {_new_loc} to {_loc} add {_move_vec} multiply {@spectator_free_speed}
                set {spectator::%{_uuid}%::free_location} to {_new_loc}
                set camera location of {_p} to {_new_loc}
            else if {_mode} is "track":
                # Track camera mode
                if {spectator::%{_uuid}%::target_player} is set:
                    set {_target} to player from uuid {spectator::%{_uuid}%::target_player}
                    if {_target} is not null:
                        # Get target's race citizen
                        set {_citizen_id} to {player::%{_target}'s uuid%::race_citizen_entity_id}
                        if {_citizen_id} is set:
                            set {_citizen} to entity from uuid {_citizen_id}
                            set {_citizen_loc} to location of {_citizen}
                            
                            # Calculate smooth track position
                            set {_current_pos} to {spectator::%{_uuid}%::track_position}
                            set {_target_pos} to getTrackPosition({_citizen_loc})
                            set {_smooth_pos} to {_current_pos} + ({_target_pos} - {_current_pos}) * {@spectator_track_smoothness}
                            set {spectator::%{_uuid}%::track_position} to {_smooth_pos}
                            
                            # Calculate camera position based on track position
                            set {_camera_loc} to calculateTrackCameraPosition({_smooth_pos})
                            set camera location of {_p} to {_camera_loc}
                            set camera rotation of {_p} to look at {_citizen_loc}

# Function to get track position from location
function getTrackPosition(loc: location) :: number:
    # TODO: Implement track position calculation based on track waypoints
    return 0

# Function to calculate camera position based on track position
function calculateTrackCameraPosition(track_position: number) :: location:
    # TODO: Implement camera position calculation based on track waypoints
    return location of player

# Command to toggle spectator mode
command /spectator:
    trigger:
        if {spectator::%player's uuid%::mode} is set:
            disableSpectatorMode(player)
        else:
            enableSpectatorMode(player)

# Command to change spectator mode
command /spectatormode <text>:
    trigger:
        if {spectator::%player's uuid%::mode} is not set:
            send "{@prefix} &cYou're not in spectator mode!" to player
            return
        
        if arg-1 is in {@spectator_modes}:
            set {spectator::%player's uuid%::mode} to arg-1
            send "{@prefix} &aSpectator Mode: &e%arg-1%" to player
        else:
            send "{@prefix} &cInvalid spectator mode! Available modes: %{@spectator_modes}%" to player

# Command to target a player
command /spectatortarget <player>:
    trigger:
        if {spectator::%player's uuid%::mode} is not set:
            send "{@prefix} &cYou're not in spectator mode!" to player
            return
        
        set {spectator::%player's uuid%::target_player} to arg-1's uuid
        send "{@prefix} &aTargeting player: &e%arg-1%" to player

# Function to get current spectator mode
function getCurrentSpectatorMode(p: player) :: text:
    set {_uuid} to {_p}'s uuid
    return {spectator::%{_uuid}%::mode} ? "follow"
# File: click_accuracy.sk
# Description: Click accuracy challenges and mini-games

options:
    prefix: &6&lRaceClicker &8»
    accuracy_challenge_interval: 30 seconds # How often to spawn accuracy challenges
    accuracy_target_radius: 0.5 # Radius of the target area
    accuracy_target_duration: 5 seconds # How long the target is visible
    accuracy_reward_multiplier: 2.0 # Multiplier for successful hits
    accuracy_penalty_multiplier: 0.5 # Multiplier for misses
    
# Variables:
# {player::%uuid%::accuracy_target_location} = location (current target location)
# {player::%uuid%::accuracy_target_end_time} = timestamp (when target disappears)
# {player::%uuid%::accuracy_hits} = number (successful hits)
# {player::%uuid%::accuracy_misses} = number (misses)
# {player::%uuid%::accuracy_streak} = number (current hit streak)

# Function to spawn a new accuracy target
function spawnAccuracyTarget(p: player):
    set {_uuid} to {_p}'s uuid
    
    # Find a suitable location
    set {_loc} to location of {_p} add vector(0, 1, 0)
    
    # Create target particle effect
    loop 10 times:
        set {_angle} to loop-number * (360 / 10)
        set {_offset} to vector(sin({_angle}), 0, cos({_angle})) multiply {@accuracy_target_radius}
        spawn particle "redstone" at {_loc} add {_offset}
    
    # Set target variables
    set {player::%{_uuid}%::accuracy_target_location} to {_loc}
    set {player::%{_uuid}%::accuracy_target_end_time} to now + {@accuracy_target_duration}
    
    # Send message
    send "{@prefix} &aAccuracy Challenge! &eHit the target within %{@accuracy_target_duration}% seconds!" to {_p}

# Function to check if click hit the target
function checkTargetHit(p: player, click_location: location) :: boolean:
    set {_uuid} to {_p}'s uuid
    
    # Check if target exists and is still active
    if {player::%{_uuid}%::accuracy_target_location} is not set:
        return false
    
    if {player::%{_uuid}%::accuracy_target_end_time} is set and {player::%{_uuid}%::accuracy_target_end_time} < now:
        # Target expired
        remove target particles
        set {player::%{_uuid}%::accuracy_target_location} to null
        set {player::%{_uuid}%::accuracy_target_end_time} to null
        return false
    
    # Calculate distance to target
    set {_target_loc} to {player::%{_uuid}%::accuracy_target_location}
    set {_distance} to distance between {_click_location} and {_target_loc}
    
    if {_distance} <= {@accuracy_target_radius}:
        # Hit the target
        add 1 to {player::%{_uuid}%::accuracy_hits}
        add 1 to {player::%{_uuid}%::accuracy_streak}
        
        # Show hit particles
        loop 5 times:
            set {_angle} to loop-number * (360 / 5)
            set {_offset} to vector(sin({_angle}), 0, cos({_angle})) multiply 0.2
            spawn particle "happy_villager" at {_click_location} add {_offset}
            
        return true
    else:
        # Missed the target
        add 1 to {player::%{_uuid}%::accuracy_misses}
        set {player::%{_uuid}%::accuracy_streak} to 0
        
        # Show miss particles
        spawn 5 of particle "large_smoke" at {_click_location}
        
        return false

# Function to remove target particles
function removeTargetParticles(p: player):
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::accuracy_target_location} is set:
        set {_loc} to {player::%{_uuid}%::accuracy_target_location}
        loop 10 times:
            set {_angle} to loop-number * (360 / 10)
            set {_offset} to vector(sin({_angle}), 0, cos({_angle})) multiply {@accuracy_target_radius}
            spawn particle "white_smoke" at {_loc} add {_offset}

# Event handler for clicks
every click:
    if player has permission "raceclicker.play":
        if {player::%player's uuid%::in_race} is true:
            set {_hit} to checkTargetHit(player, location of player)
            if {_hit} is true:
                # Apply accuracy bonus
                set {_multiplier} to {@accuracy_reward_multiplier}
                set {player::%player's uuid%::accuracy_multiplier} to {_multiplier}
                send "{@prefix} &aAccuracy Bonus! &e+%{_multiplier}x Power!" to player
            else:
                # Apply penalty
                set {_multiplier} to {@accuracy_penalty_multiplier}
                set {player::%player's uuid%::accuracy_multiplier} to {_multiplier}
                send "{@prefix} &cAccuracy Miss! &e-%{_multiplier}x Power!" to player

# Periodically spawn new targets
every {@accuracy_challenge_interval}:
    loop all players:
        if {player::%loop-player's uuid%::in_race} is true:
            spawnAccuracyTarget(loop-player)

# Function to get current accuracy multiplier
function getCurrentAccuracyMultiplier(p: player) :: number:
    set {_uuid} to {_p}'s uuid
    return {player::%{_uuid}%::accuracy_multiplier} ? 1
# File: clan_system.sk
# Description: Clan system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Clan settings
    clan_creation_cost: 10000 # Cost to create a clan
    clan_name_length: [3, 20] # Minimum and maximum clan name length
    clan_tag_length: [2, 5] # Minimum and maximum clan tag length
    clan_max_members: 50 # Maximum clan members
    clan_invite_cooldown: 5 minutes # Cooldown between clan invites
    
    # Clan ranks
    clan_ranks:
        - "Leader"
        - "Officer"
        - "Member"
        - "Recruit"
    
    # Clan permissions
    clan_permissions:
        leader:
            - "clan.kick"
            - "clan.promote"
            - "clan.demote"
            - "clan.sethome"
            - "clan.setrank"
        officer:
            - "clan.kick"
            - "clan.promote"
            - "clan.demote"
            - "clan.setrank"
        member:
            - "clan.chat"
            - "clan.leave"
        recruit:
            - "clan.chat"

# Variables:
# {clan::%clan_name%::tag} = text (clan tag)
# {clan::%clan_name%::leader} = text (clan leader)
# {clan::%clan_name%::members::*} = text (clan members)
# {clan::%clan_name%::rank::*} = text (clan member ranks)
# {clan::%clan_name%::bank} = number (clan bank)
# {clan::%clan_name%::home} = location (clan home)
# {clan::%clan_name%::xp} = number (clan xp)
# {clan::%clan_name%::level} = number (clan level)
# {player::%uuid%::clan} = text (player's clan)
# {player::%uuid%::clan_rank} = text (player's clan rank)

# Function to create clan
command /createclan <text>:
    permission: raceclicker.clan.create
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has clan
        if not {player::%{_uuid}%::clan} is set:
            send "{@prefix} &cYou are already in a clan!" to player
            return
            
        # Check clan name
        if length of arg-1 is not between {@clan_name_length::0} and {@clan_name_length::1}:
            send "{@prefix} &cClan name must be between %{clan_name_length::0}% and %{clan_name_length::1}% characters!" to player
            return
            
        # Check if clan exists
        if not {clan::%arg-1%::leader} is set:
            send "{@prefix} &cClan %{arg-1}% already exists!" to player
            return
            
        # Check cost
        if {player::%{_uuid}%::clickcoins} < {@clan_creation_cost}:
            send "{@prefix} &cYou need %{@clan_creation_cost}% ClickCoins to create a clan!" to player
            return
            
        # Create clan
        set {clan::%arg-1%::leader} to player
        set {clan::%arg-1%::members::*} to [player]
        set {clan::%arg-1%::rank::*} to ["Leader"]
        set {clan::%arg-1%::bank} to 0
        set {clan::%arg-1%::xp} to 0
        set {clan::%arg-1%::level} to 1
        set {player::%{_uuid}%::clan} to arg-1
        set {player::%{_uuid}%::clan_rank} to "Leader"
        subtract {@clan_creation_cost} from {player::%{_uuid}%::clickcoins}
        
        # Announce clan creation
        broadcast "{@prefix} &6Clan created: %{arg-1}%" to all players
        send "{@prefix} &aCreated clan %{arg-1}%!" to player

# Function to join clan
command /joinclan <text>:
    permission: raceclicker.clan.join
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has clan
        if not {player::%{_uuid}%::clan} is set:
            send "{@prefix} &cYou are already in a clan!" to player
            return
            
        # Check if clan exists
        if not {clan::%arg-1%::leader} is set:
            send "{@prefix} &cClan %{arg-1}% does not exist!" to player
            return
            
        # Check if clan is full
        if size of {clan::%arg-1%::members::*} >= {@clan_max_members}:
            send "{@prefix} &cClan %{arg-1}% is full!" to player
            return
            
        # Check if player has invite
        if not {player::%{_uuid}%::clan_invite} is set:
            send "{@prefix} &cYou don't have an invite to clan %{arg-1}%!" to player
            return
            
        # Join clan
        add player to {clan::%arg-1%::members::*}
        add "Member" to {clan::%arg-1%::rank::*}
        set {player::%{_uuid}%::clan} to arg-1
        set {player::%{_uuid}%::clan_rank} to "Member"
        remove {_uuid} from {player::%{_uuid}%::clan_invite}
        
        # Notify clan
        broadcast "{@prefix} &6%{player}% joined clan %{arg-1}%!" to players with permission "raceclicker.clan.view"
        send "{@prefix} &aSuccessfully joined clan %{arg-1}%!" to player

# Function to leave clan
command /leaveclan:
    permission: raceclicker.clan.leave
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has clan
        if not {player::%{_uuid}%::clan} is set:
            send "{@prefix} &cYou are not in a clan!" to player
            return
            
        # Get clan info
        set {_clan} to {player::%{_uuid}%::clan}
        
        # Remove from clan
        remove player from {clan::%{_clan}%::members::*}
        remove {player::%{_uuid}%::clan_rank} from {clan::%{_clan}%::rank::*}
        set {player::%{_uuid}%::clan} to null
        
        # Notify clan
        loop {clan::%{_clan}%::members::*}:
            send "{@prefix} &6%{player}% left clan %{_clan}%" to loop-value
        
        send "{@prefix} &aLeft clan %{_clan}%!" to player

# Function to kick member
command /clankick <player>:
    permission: raceclicker.clan.kick
    trigger:
        set {_uuid} to player's uuid
        set {_target} to arg-1
        set {_target_uuid} to {_target}'s uuid
        
        # Check permissions
        if {player::%{_uuid}%::clan_rank} is not "Leader" and {player::%{_uuid}%::clan_rank} is not "Officer":
            send "{@prefix} &cYou don't have permission to kick!" to player
            return
            
        # Check if target is in same clan
        if {player::%{_target_uuid}%::clan} is not {player::%{_uuid}%::clan}:
            send "{@prefix} &c%{_target}% is not in your clan!" to player
            return
            
        # Kick member
        set {_clan} to {player::%{_uuid}%::clan}
        remove {_target} from {clan::%{_clan}%::members::*}
        remove {player::%{_target_uuid}%::clan_rank} from {clan::%{_clan}%::rank::*}
        set {player::%{_target_uuid}%::clan} to null
        
        # Notify clan
        loop {clan::%{_clan}%::members::*}:
            send "{@prefix} &6%{player}% kicked %{_target}% from clan %{_clan}%" to loop-value
        
        send "{@prefix} &aKicked %{_target}% from clan %{_clan}%!" to player

# Function to promote member
command /clanpromote <player>:
    permission: raceclicker.clan.promote
    trigger:
        set {_uuid} to player's uuid
        set {_target} to arg-1
        set {_target_uuid} to {_target}'s uuid
        
        # Check permissions
        if {player::%{_uuid}%::clan_rank} is not "Leader":
            send "{@prefix} &cYou don't have permission to promote!" to player
            return
            
        # Check if target is in same clan
        if {player::%{_target_uuid}%::clan} is not {player::%{_uuid}%::clan}:
            send "{@prefix} &c%{_target}% is not in your clan!" to player
            return
            
        # Promote member
        set {_clan} to {player::%{_uuid}%::clan}
        set {_current_rank} to {player::%{_target_uuid}%::clan_rank}
        set {_new_rank} to next element of {@clan_ranks::*} after {_current_rank}
        
        if {_new_rank} is not set:
            send "{@prefix} &c%{_target}% is already at the highest rank!" to player
            return
            
        # Update rank
        remove {_current_rank} from {clan::%{_clan}%::rank::*}
        add {_new_rank} to {clan::%{_clan}%::rank::*}
        set {player::%{_target_uuid}%::clan_rank} to {_new_rank}
        
        # Notify clan
        loop {clan::%{_clan}%::members::*}:
            send "{@prefix} &6%{player}% promoted %{_target}% to %{_new_rank}%" to loop-value
        
        send "{@prefix} &aPromoted %{_target}% to %{_new_rank}%!" to player

# Function to demote member
command /clandemote <player>:
    permission: raceclicker.clan.demote
    trigger:
        set {_uuid} to player's uuid
        set {_target} to arg-1
        set {_target_uuid} to {_target}'s uuid
        
        # Check permissions
        if {player::%{_uuid}%::clan_rank} is not "Leader":
            send "{@prefix} &cYou don't have permission to demote!" to player
            return
            
        # Check if target is in same clan
        if {player::%{_target_uuid}%::clan} is not {player::%{_uuid}%::clan}:
            send "{@prefix} &c%{_target}% is not in your clan!" to player
            return
            
        # Demote member
        set {_clan} to {player::%{_uuid}%::clan}
        set {_current_rank} to {player::%{_target_uuid}%::clan_rank}
        set {_new_rank} to previous element of {@clan_ranks::*} before {_current_rank}
        
        if {_new_rank} is not set:
            send "{@prefix} &c%{_target}% is already at the lowest rank!" to player
            return
            
        # Update rank
        remove {_current_rank} from {clan::%{_clan}%::rank::*}
        add {_new_rank} to {clan::%{_clan}%::rank::*}
        set {player::%{_target_uuid}%::clan_rank} to {_new_rank}
        
        # Notify clan
        loop {clan::%{_clan}%::members::*}:
            send "{@prefix} &6%{player}% demoted %{_target}% to %{_new_rank}%" to loop-value
        
        send "{@prefix} &aDemoted %{_target}% to %{_new_rank}%!" to player

# Function to set clan home
command /clansethome:
    permission: raceclicker.clan.sethome
    trigger:
        set {_uuid} to player's uuid
        
        # Check permissions
        if {player::%{_uuid}%::clan_rank} is not "Leader" and {player::%{_uuid}%::clan_rank} is not "Officer":
            send "{@prefix} &cYou don't have permission to set clan home!" to player
            return
            
        # Set clan home
        set {_clan} to {player::%{_uuid}%::clan}
        set {clan::%{_clan}%::home} to player's location
        
        # Notify clan
        loop {clan::%{_clan}%::members::*}:
            send "{@prefix} &6%{player}% set clan home!" to loop-value
        
        send "{@prefix} &aSet clan home!" to player

# Function to teleport to clan home
command /clanthome:
    permission: raceclicker.clan.home
    trigger:
        set {_uuid} to player's uuid
        
        # Check if clan has home
        if {clan::%{player::%{_uuid}%::clan}%::home} is not set:
            send "{@prefix} &cClan home not set!" to player
            return
            
        # Teleport to clan home
        teleport player to {clan::%{player::%{_uuid}%::clan}%::home}
        send "{@prefix} &aTeleported to clan home!" to player

# Function to view clan info
command /claninfo:
    permission: raceclicker.clan.info
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has clan
        if {player::%{_uuid}%::clan} is not set:
            send "{@prefix} &cYou are not in a clan!" to player
            return
            
        # Get clan info
        set {_clan} to {player::%{_uuid}%::clan}
        set {_info} to "&6Clan Info: %{_clan}%\n"
        append "&eLeader: &a%{clan::%{_clan}%::leader}%\n" to {_info}
        append "&eMembers: &a%{size of {clan::%{_clan}%::members::*}}%/%{@clan_max_members}%\n" to {_info}
        append "&eLevel: &a%{clan::%{_clan}%::level}%\n" to {_info}
        append "&eXP: &a%{clan::%{_clan}%::xp}%\n" to {_info}
        append "&eBank: &a%{clan::%{_clan}%::bank}% ClickCoins\n" to {_info}
        append "&eMembers:\n" to {_info}
        
        # Add member list
        loop {clan::%{_clan}%::members::*}:
            set {_member} to loop-value
            set {_member_uuid} to {_member}'s uuid
            append "&7- %{_member}% &8(&a%{player::%{_member_uuid}%::clan_rank}%&8)\n" to {_info}
        
        send "{@prefix} %{_info}%" to player

# Function to deposit to clan bank
command /clandeposit <number>:
    permission: raceclicker.clan.bank
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has clan
        if {player::%{_uuid}%::clan} is not set:
            send "{@prefix} &cYou are not in a clan!" to player
            return
            
        # Check if player has enough coins
        if {player::%{_uuid}%::clickcoins} < arg-1:
            send "{@prefix} &cYou don't have enough ClickCoins!" to player
            return
            
        # Deposit coins
        set {_clan} to {player::%{_uuid}%::clan}
        add arg-1 to {clan::%{_clan}%::bank}
        subtract arg-1 from {player::%{_uuid}%::clickcoins}
        
        # Notify clan
        loop {clan::%{_clan}%::members::*}:
            send "{@prefix} &6%{player}% deposited %{arg-1}% ClickCoins to clan bank!" to loop-value
        
        send "{@prefix} &aDeposited %{arg-1}% ClickCoins to clan bank!" to player

# Function to withdraw from clan bank
command /clanwithdraw <number>:
    permission: raceclicker.clan.bank
    trigger:
        set {_uuid} to player's uuid
        
        # Check clan membership
        if not {player::%{_uuid}%::clan} is set:
            send "{@prefix} &cYou are not in a clan!" to player
            return
            
        # Get clan info
        set {_clan} to {player::%{_uuid}%::clan}
        set {_rank} to {player::%{_uuid}%::clan_rank}
        
        # Check permissions
        if not {_rank} is "Leader" and not {_rank} is "Officer":
            send "{@prefix} &cYou don't have permission to withdraw from clan bank!" to player
            return
            
        # Check amount
        if arg-1 <= 0:
            send "{@prefix} &cAmount must be greater than 0!" to player
            return
            
        # Check clan bank balance
        if {clan::%{_clan}%::bank} < arg-1:
            send "{@prefix} &cClan bank doesn't have enough funds!" to player
            return
            
        # Withdraw funds
        subtract arg-1 from {clan::%{_clan}%::bank}
        add arg-1 to {player::%{_uuid}%::clickcoins}
        
        # Notify clan
        broadcast "{@prefix} &6%{player}% withdrew %{arg-1}% ClickCoins from clan bank!" to players with permission "raceclicker.clan.view"
        send "{@prefix} &aSuccessfully withdrew %{arg-1}% ClickCoins from clan bank!" to player

# Function to invite player to clan
command /claninvite <player>:
    permission: raceclicker.clan.invite
    trigger:
        set {_uuid} to player's uuid
        set {_target} to arg-1
        set {_target_uuid} to {_target}'s uuid
        
        # Check if player has clan
        if {player::%{_uuid}%::clan} is not set:
            send "{@prefix} &cYou are not in a clan!" to player
            return
            
        # Check if target has clan
        if {player::%{_target_uuid}%::clan} is set:
            send "{@prefix} &c%{_target}% is already in a clan!" to player
            return
            
        # Check cooldown
        if {player::%{_uuid}%::last_invite} is set and now - {player::%{_uuid}%::last_invite} < {@clan_invite_cooldown}:
            send "{@prefix} &cYou must wait %{@clan_invite_cooldown}% between invites!" to player
            return
            
        # Send invite
        set {_clan} to {player::%{_uuid}%::clan}
        send "{@prefix} &6%{player}% invited you to clan %{_clan}%!" to {_target}
        send "{@prefix} &aSent invite to %{_target}%!" to player
        set {player::%{_uuid}%::last_invite} to now
        
        # Wait for response
        wait 30 seconds
        if {player::%{_target_uuid}%::clan} is not set:
            send "{@prefix} &cInvite to %{_target}% expired!" to player

# Function to accept clan invite
command /clanaccept <text>:
    permission: raceclicker.clan.accept
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has clan
        if {player::%{_uuid}%::clan} is set:
            send "{@prefix} &cYou are already in a clan!" to player
            return
            
        # Check if clan exists
        if {clan::%arg-1%::leader} is not set:
            send "{@prefix} &cClan %{arg-1}% does not exist!" to player
            return
            
        # Join clan
        set {_clan} to arg-1
        add player to {clan::%{_clan}%::members::*}
        add "Member" to {clan::%{_clan}%::rank::*}
        set {player::%{_uuid}%::clan} to {_clan}
        set {player::%{_uuid}%::clan_rank} to "Member"
        
        # Notify clan
        loop {clan::%{_clan}%::members::*}:
            send "{@prefix} &6%{player}% joined clan %{_clan}%" to loop-value
        
        send "{@prefix} &aJoined clan %{_clan}%!" to player

# Function to set clan tag
command /clansettag <text>:
    permission: raceclicker.clan.tag
    trigger:
        set {_uuid} to player's uuid
        
        # Check permissions
        if {player::%{_uuid}%::clan_rank} is not "Leader":
            send "{@prefix} &cYou don't have permission to set clan tag!" to player
            return
            
        # Check tag length
        if length of arg-1 is not between {@clan_tag_length::0} and {@clan_tag_length::1}:
            send "{@prefix} &cClan tag must be between %{clan_tag_length::0}% and %{clan_tag_length::1}% characters!" to player
            return
            
        # Set clan tag
        set {_clan} to {player::%{_uuid}%::clan}
        set {clan::%{_clan}%::tag} to arg-1
        
        # Update clan chat
        loop {clan::%{_clan}%::members::*}:
            set {_member} to loop-value
            set {_member_uuid} to {_member}'s uuid
            set {_member}'s display name to "&8[&6%{clan::%{_clan}%::tag}%&8] %{_member}%"
        
        # Notify clan
        loop {clan::%{_clan}%::members::*}:
            send "{@prefix} &6%{player}% set clan tag to %{arg-1}%" to loop-value
        
        send "{@prefix} &aSet clan tag to %{arg-1}%!" to player

# Function to handle clan chat
on chat:
    if player has clan:
        set {_clan} to {player::%player's uuid%::clan}
        set event-message to "&8[&6%{clan::%{_clan}%::tag}%&8] %{event-message}%"

# Function to calculate clan xp
on race completion:
    set {_uuid} to player's uuid
    if {player::%{_uuid}%::clan} is set:
        set {_clan} to {player::%{_uuid}%::clan}
        add 100 to {clan::%{_clan}%::xp}
        
        # Check level up
        if {clan::%{_clan}%::xp} >= {clan::%{_clan}%::level} * 1000:
            add 1 to {clan::%{_clan}%::level}
            set {clan::%{_clan}%::xp} to 0
            
            # Give level up rewards
            set {_reward} to {clan::%{_clan}%::level} * 1000
            add {_reward} to {clan::%{_clan}%::bank}
            
            # Notify clan
            loop {clan::%{_clan}%::members::*}:
                send "{@prefix} &6Clan level up! New level: %{clan::%{_clan}%::level}%" to loop-value
                send "{@prefix} &6Clan bank received %{_reward}% ClickCoins!" to loop-value
# File: anti_spam.sk
# Description: Anti-spam system to prevent click abuse and ensure fair gameplay

options:
    prefix: &6&lRaceClicker &8»
    max_clicks_per_second: 20 # Maximum allowed clicks per second
    spam_detection_window: 5 ticks # Window size for spam detection
    spam_penalty_duration: 10 seconds # Duration of penalty when spam is detected
    spam_penalty_effect: "slowness" # Effect to apply as penalty
    spam_penalty_level: 2 # Level of penalty effect
    spam_penalty_message: "&cClick spam detected! You've been slowed down for %duration% seconds."
    
# Variables:
# {player::%uuid%::clicks_in_window} = number (clicks in current window)
# {player::%uuid%::last_click_time} = timestamp (last click time)
# {player::%uuid%::spam_penalty_end_time} = timestamp (when penalty ends)

# Function to check if a click is spam
function isSpamClick(p: player) :: boolean:
    set {_uuid} to {_p}'s uuid
    
    # Check if player is under penalty
    if {player::%{_uuid}%::spam_penalty_end_time} is set and {player::%{_uuid}%::spam_penalty_end_time} > now:
        return true
    
    # Check click rate
    if {player::%{_uuid}%::last_click_time} is set:
        set {_time_diff} to now - {player::%{_uuid}%::last_click_time}
        if {_time_diff} < 1 second:
            add 1 to {player::%{_uuid}%::clicks_in_window}
            
            # Check if exceeded limit
            if {player::%{_uuid}%::clicks_in_window} >= {@max_clicks_per_second}:
                return true
        else:
            # Reset window if too much time passed
            set {player::%{_uuid}%::clicks_in_window} to 1
    else:
        set {player::%{_uuid}%::clicks_in_window} to 1
    
    set {player::%{_uuid}%::last_click_time} to now
    return false

# Function to apply spam penalty
function applySpamPenalty(p: player):
    set {_uuid} to {_p}'s uuid
    
    # Apply penalty effect
    apply {@spam_penalty_effect} of tier {@spam_penalty_level} to {_p} for {@spam_penalty_duration}
    
    # Set penalty end time
    set {player::%{_uuid}%::spam_penalty_end_time} to now + {@spam_penalty_duration}
    
    # Send message with duration in seconds
    set {_duration_seconds} to floor({@spam_penalty_duration} / 20)
    send "{@prefix} %{@spam_penalty_message}%" to {_p} with arguments {_duration_seconds}
    
    # Play warning sound
    play sound "minecraft:entity.villager.no" to {_p} with volume 1 pitch 1.5

# Event handler for all clicks
on click:
    if player has permission "raceclicker.play":
        if isSpamClick(player):
            applySpamPenalty(player)
            stop
        
        # If not spam, proceed with click
        trigger:
            # Continue with normal click handling
            pass

# Function to check if player is under penalty
function isUnderPenalty(p: player) :: boolean:
    set {_uuid} to {_p}'s uuid
    return {player::%{_uuid}%::spam_penalty_end_time} is set and {player::%{_uuid}%::spam_penalty_end_time} > now

# Function to get remaining penalty time
function getPenaltyTimeRemaining(p: player) :: timespan:
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::spam_penalty_end_time} is set:
        return {player::%{_uuid}%::spam_penalty_end_time} - now
    return 0 seconds
# File: click_pattern.sk
# Description: Click pattern system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    pattern_detection_interval: 5 ticks # How often to check for patterns
    pattern_reward_multiplier: 1.5 # Multiplier for matching patterns
    pattern_display_duration: 3 seconds # How long to show pattern hints
    pattern_types: "simple,advanced,expert" # Available pattern types
    
# Variables:
# {player::%uuid%::current_pattern} = text (current pattern being matched)
# {player::%uuid%::pattern_progress} = number (progress in current pattern)
# {player::%uuid%::last_pattern_click} = timestamp (last click time for pattern)
# {player::%uuid%::pattern_multiplier} = number (current pattern multiplier)

# Function to generate a random pattern
function generatePattern(type: text) :: text:
    if {_type} is "simple":
        return choose from "left,right", "left,right,right", "right,left,right"
    else if {_type} is "advanced":
        return choose from "left,right,left,right", "right,left,right,left", "left,right,right,left,right"
    else if {_type} is "expert":
        return choose from "left,right,left,right,left,right", "right,left,right,left,right,left", "left,right,right,left,right,right,left"
    return "left,right" # Default if type not recognized

# Function to check if click matches pattern
function checkPatternMatch(p: player, click_type: text):
    set {_uuid} to {_p}'s uuid
    set {_pattern} to {player::%{_uuid}%::current_pattern} ? generatePattern("simple")
    set {_progress} to {player::%{_uuid}%::pattern_progress} ? 0
    
    # Split pattern into array
    set {_pattern_array} to split {_pattern} by ","
    
    # Check if click matches current position
    if {_click_type} is {_pattern_array}[_progress]:
        add 1 to {_progress}
        set {player::%{_uuid}%::pattern_progress} to {_progress}
        
        # If pattern completed
        if {_progress} >= size of {_pattern_array}:
            # Give reward
            set {_multiplier} to {@pattern_reward_multiplier}
            set {player::%{_uuid}%::pattern_multiplier} to {_multiplier}
            send "{@prefix} &aPattern Completed! &e+%{_multiplier}x Power!" to {_p}
            
            # Start new pattern
            set {player::%{_uuid}%::pattern_progress} to 0
            set {player::%{_uuid}%::current_pattern} to generatePattern(choose from "simple", "advanced", "expert")
            
            # Show next pattern hint
            set {_next_pattern} to {player::%{_uuid}%::current_pattern}
            send title "&6Pattern: &e%{_next_pattern}%" to {_p} for {@pattern_display_duration}
    else:
        # Reset pattern on mismatch
        set {player::%{_uuid}%::pattern_progress} to 0
        set {player::%{_uuid}%::current_pattern} to generatePattern("simple")
        set {player::%{_uuid}%::pattern_multiplier} to 1
        send "{@prefix} &cPattern Reset!" to {_p}

# Main click pattern detection loop
every {@pattern_detection_interval}:
    loop all players:
        set {_p} to loop-player
        set {_uuid} to {_p}'s uuid
        
        # Check if player is in a race
        if {player::%{_uuid}%::in_race} is true:
            # Show pattern hint if not already shown
            if {player::%{_uuid}%::last_pattern_click} is not set or now - {player::%{_uuid}%::last_pattern_click} > 10 seconds:
                set {player::%{_uuid}%::last_pattern_click} to now
                set {_pattern} to {player::%{_uuid}%::current_pattern} ? generatePattern("simple")
                send title "&6Pattern: &e%{_pattern}%" to {_p} for 2 seconds

# Event handler for left click
on left click:
    if player has permission "raceclicker.play":
        checkPatternMatch(player, "left")

# Event handler for right click
on right click:
    if player has permission "raceclicker.play":
        checkPatternMatch(player, "right")

# Function to get current pattern multiplier
function getCurrentPatternMultiplier(p: player) :: number:
    set {_uuid} to {_p}'s uuid
    return {player::%{_uuid}%::pattern_multiplier} ? 1
# File: clicking.sk
# Path: race-clicker/core/clicking.sk
# Description: Click detection and power calculation

options:
    prefix: "&6&lRaceClicker &8»"
    click_item: stick # Item used for special combo clicks, can be any item type
    combo_max_time: 2 seconds # Max time between clicks to maintain a combo
    combo_max_multiplier: 3 # Maximum multiplier from combos (e.g., 3x power)
    base_click_power: 1 # Base power per click before any upgrades
    combo_counter_duration: 5 seconds # How long to show combo counter
    combo_counter_height: 2.5 # Height above player for counter
    combo_counter_particle_count: 10 # Number of particles for counter
    # Particle for manual click
    click_particle: crit
    click_particle_count: 5
    click_particle_offset: 0.2
    # Particle for auto-clicker
    autoclick_particle: flame
    autoclick_particle_count: 1
    autoclick_particle_offset: 0.1

# Variables (ensure these are initialized in data.sk or on first join):
# {player::%player's uuid%::clicks} - Total clicks by the player
# {player::%player's uuid%::speed_level} - Player's speed upgrade level (affects click power)
# {player::%player's uuid%::autoclicker_level} - Player's auto-clicker upgrade level
# {player::%player's uuid%::prestige_bonus_click_power} - Multiplier from prestige
# {player::%player's uuid%::last_click_time} - Timestamp of the last click for combo
# {player::%player's uuid%::click_combo} - Current click combo count
# {player::%player's uuid%::in_race} - Boolean, true if player is currently in a race
# {player::%player's uuid%::race_progress_current_race} - Current progress in an active race

# --- Phase 1 & 5: Click Detection, Power Calculation, Combos ---

# Function to calculate click power
function calculateClickPower(p: player) :: number:
    set {_power} to {@base_click_power}
    # Add power from speed level (example: each level adds 0.5 power)
    set {_speed_level_bonus} to ({player::%{_p}'s uuid%::speed_level} ? 0) * 0.5
    add {_speed_level_bonus} to {_power}
    
    # Add pattern multiplier
    set {_pattern_multiplier} to getCurrentPatternMultiplier({_p})
    set {_power} to {_power} * {
    # Add accuracy multiplier
    set {_accuracy_multiplier} to getCurrentAccuracyMultiplier({_p})
    set {_power} to {_power} * {_accuracy_multiplier}
    
    # Add upgrade bonuses
    set {_uuid} to {_p}'s uuid
    
    # Add speed bonus from upgrade
    set {_speed_bonus} to getUpgradeBonus({_p}, "speed")
    add {_speed_bonus} to {_power}
    
    # Apply combo bonus from upgrade
    set {_combo_bonus} to getUpgradeBonus({_p}, "combo")
    set {_power} to {_power} * {_combo_bonus}
    
    # Apply accuracy bonus from upgrade
    set {_accuracy_bonus} to getUpgradeBonus({_p}, "accuracy")
    set {_power} to {_power} * {_accuracy_bonus}
    
    # Apply power bonus from upgrade
    set {_power_bonus} to getUpgradeBonus({_p}, "power")
    set {_power} to {_power} * {_power_bonus}

    # Apply prestige bonus (example: direct multiplier)
    set {_prestige_multiplier} to ({player::%{_p}'s uuid%::prestige_bonus_click_power} ? 1)
    set {_power} to {_power} * {_prestige_multiplier}

    # Apply combo bonus
    set {_combo_count} to {player::%{_p}'s uuid%::click_combo} ? 0
    if {_combo_count} > 1:
        set {_combo_bonus_multiplier} to 1 + (({_combo_count} - 1) * 0.1) # Each combo hit adds 0.1x, caps later
        if {_combo_bonus_multiplier} > {@combo_max_multiplier}:
            set {_combo_bonus_multiplier} to {@combo_max_multiplier}
        set {_power} to {_power} * {_combo_bonus_multiplier}
        send action bar "&b&lCOMBO x%player combo count% &7(&a+%.1f%% Power&7)" to {_p} with arguments ((_combo_bonus_multiplier - 1) * 100)
    
    # Apply active obstacle effect (from racing.sk)
    if {player::%{_p}\'s uuid%::active_obstacle_effect::type} is set and {player::%{_p}\'s uuid%::active_obstacle_effect::end_time} is set and {player::%{_p}\'s uuid%::active_obstacle_effect::end_time} > now:
        set {_obstacle_magnitude} to {player::%{_p}\'s uuid%::active_obstacle_effect::magnitude} ? 1 # Default to no effect if magnitude not set
        if {_obstacle_magnitude} < 0: # Ensure magnitude is not negative, treat as 0 if so (full stop)
            set {_obstacle_magnitude} to 0
        if {_obstacle_magnitude} > 1: # Cap reduction at 100% (no negative power)
            set {_obstacle_magnitude} to 1 # This means 100% reduction, effectively 0 power if type is slow_down
    
        if {player::%{_p}\'s uuid%::active_obstacle_effect::type} is "slow_down":
            set {_power} to {_power} * (1 - {_obstacle_magnitude}) # e.g. magnitude 0.5 means 50% power
            if {_power} < 0: # Ensure power doesn't go negative
                set {_power} to 0
    
    # Apply active boost effect (from racing.sk)
    if {player::%{_p}'s uuid%::active_boost_effect::end_time} is set and {player::%{_p}'s uuid%::active_boost_effect::end_time} > now:
        set {_boost_magnitude} to {player::%{_p}'s uuid%::active_boost_effect::magnitude} ? 1 # Default to no boost if not set
        if {_boost_magnitude} < 1: # Ensure boost is at least 1x (no negative boost)
            set {_boost_magnitude} to 1
        set {_power} to {_power} * {_boost_magnitude} # e.g. magnitude 1.5 means 1.5x power

    # TODO: Apply other temporary boosts or debuffs from mini-games or effects
    return {_power}

# Main click event (any click)
on click:
    if player has permission "raceclicker.play":
        # Increment total clicks (persists across races)
        add 1 to {player::%player's uuid%::clicks}

        # Calculate click power
        set {_click_power} to calculateClickPower(player)

        # If in a race, add to race progress
        if {player::%player's uuid%::in_race} is true:
            add {_click_power} to {player::%player's uuid%::race_progress_current_race}
            # Send title showing progress gained in race
            send title "&a+%.2f Race Progress" to player for 10 ticks with arguments {_click_power}
        else:
            # If not in a race, maybe just show general click power or a different feedback
            send title "&b+%.2f Click Power" to player for 10 ticks with arguments {_click_power}

        # Particle effect for click
        spawn {@click_particle_count} of {@click_particle} at location of player offset by vector({@click_particle_offset}, {@click_particle_offset}, {@click_particle_offset})
        
        # Combo System Logic
        set {_uuid} to player's uuid
        set {_now} to now
        
        # Check combo time
        if {_now} - ({player::%{_uuid}%::last_click_time} ? (now - 10 seconds)) <= {@combo_max_time}:
            add 1 to {player::%{_uuid}%::click_combo}
            
            # Show combo counter above player
            set {_loc} to location of player add vector(0, {@combo_counter_height}, 0)
            set {_combo_text} to "&eCOMBO &6x%{player::%{_uuid}%::click_combo}%"
            
            # Create floating text
            spawn 10 of particle "text" with text {_combo_text} at {_loc}
            
            # Add particles around the text
            loop {@combo_counter_particle_count} times:
                set {_angle} to loop-number * (360 / {@combo_counter_particle_count})
                set {_offset} to vector(sin({_angle}), 0, cos({_angle})) multiply 0.5
                spawn particle "crit" at {_loc} add {_offset}
        else:
            # Reset combo if too much time passed
            if ({player::%player\'s uuid%::click_combo} ? 0) > 1:
                send "{@prefix} &cCombo Lost!" to player
            set {player::%{_uuid}%::click_combo} to 1 # Start new combo at 1
    
        # Update last click time
        set {player::%{_uuid}%::last_click_time} to {_now}

    else:
        send "{@prefix} &cYou do not have permission to play."
        cancel event

# --- Click Patterns (Conceptual Placeholders) ---
# TODO: Perfect timing bonuses - Complex: would require tracking click intervals precisely.
# TODO: Rhythm-based clicking - Very Complex: sequences like L-R-L clicks.
# TODO: Anti-spam with skill requirements - Could involve reducing power if click rate is too high without meeting certain conditions (e.g., target hits in a mini-game).
# For now, a simple diminishing return on extremely rapid, non-combo clicks could be considered if spam becomes an issue.

# --- Clicking Mini-games (Conceptual Placeholders) ---
# These would be separate systems, potentially triggered by commands or events.
# command /rcminigame [<text>]:
#    trigger:
#        if arg-1 is "targetpractice":
#            # TODO: Logic for target practice mini-game (e.g., spawning temporary targets)
#            send "{@prefix} &7Target Practice mini-game (Not Implemented)" to player
#        else if arg-1 is "clickaccuracy":
#            # TODO: Logic for click accuracy challenge
#            send "{@prefix} &7Click Accuracy mini-game (Not Implemented)" to player
#        else:
#            send "{@prefix} &cUnknown mini-game."

# --- Advanced Auto-Clicker System ---
every 1 second: # Auto-clicker runs every second
    loop all online players:
        if {player::%loop-player's uuid%::autoclicker_level} is set and {player::%loop-player's uuid%::autoclicker_level} > 0:
            set {_ac_level} to {player::%loop-player's uuid%::autoclicker_level}
            
            # Calculate auto-clicks per second (base on level)
            set {_autoclicks_per_second} to {_ac_level} * 0.5 # Example: 0.5 clicks per level per second

            # Auto-clicker efficiency / Diminishing returns (example)
            if {_ac_level} > 10:
                set {_efficiency_factor} to 1 - (({_ac_level} - 10) * 0.02) # 2% less efficient per level above 10
                if {_efficiency_factor} < 0.5: # Cap efficiency loss at 50%
                    set {_efficiency_factor} to 0.5
                set {_autoclicks_per_second} to {_autoclicks_per_second} * {_efficiency_factor}

            add {_autoclicks_per_second} to {player::%loop-player's uuid%::clicks}

            # Visual auto-clicker representation
            if {_ac_level} > 0 and chance of (20 + {_ac_level} * 2)%: # More frequent particles for higher levels
                spawn {@autoclick_particle_count} of {@autoclick_particle} at entity loop-player offset by vector(random number between -0.5 and 0.5, random number between 0.5 and 1.5, random number between -0.5 and 0.5)
                # TODO: Show floating items around citizens (more complex, involves entity manipulation near player or their citizen)
                # TODO: Upgrade level visual indicators (e.g., different particle color/type based on tiers of auto-clicker level)

            # Auto-clicker contributing to race progress
            if {player::%loop-player's uuid%::in_race} is true:
                set {_autoclick_race_power_base} to {_autoclicks_per_second} * 0.25 # Auto-clicks are less powerful for races than manual clicks
                set {_autoclick_race_power} to {_autoclick_race_power_base} * ({player::%loop-player's uuid%::speed_level} ? 1) # Scale with speed level
                set {_prestige_multiplier_ac} to ({player::%loop-player's uuid%::prestige_bonus_click_power} ? 1)
                set {_autoclick_race_power} to {_autoclick_race_power} * {_prestige_multiplier_ac}

                # Apply active obstacle effect to auto-clicker race power
                if {player::%loop-player's uuid%::active_obstacle_effect::type} is set and {player::%loop-player's uuid%::active_obstacle_effect::end_time} is set and {player::%loop-player's uuid%::active_obstacle_effect::end_time} > now:
                    set {_obstacle_magnitude_ac} to {player::%loop-player's uuid%::active_obstacle_effect::magnitude} ? 1
                    if {_obstacle_magnitude_ac} < 0: set {_obstacle_magnitude_ac} to 0
                    if {_obstacle_magnitude_ac} > 1: set {_obstacle_magnitude_ac} to 1
                    if {player::%loop-player's uuid%::active_obstacle_effect::type} is "slow_down":
                        set {_autoclick_race_power} to {_autoclick_race_power} * (1 - {_obstacle_magnitude_ac})
                        if {_autoclick_race_power} < 0: set {_autoclick_race_power} to 0
                
                # Apply active boost effect to auto-clicker race power
                if {player::%loop-player's uuid%::active_boost_effect::end_time} is set and {player::%loop-player's uuid%::active_boost_effect::end_time} > now:
                    set {_boost_magnitude_ac} to {player::%loop-player's uuid%::active_boost_effect::magnitude} ? 1
                    if {_boost_magnitude_ac} < 1: set {_boost_magnitude_ac} to 1
                    set {_autoclick_race_power} to {_autoclick_race_power} * {_boost_magnitude_ac}

                add {_autoclick_race_power} to {player::%loop-player's uuid%::race_progress_current_race}
                if {_autoclick_race_power} > 0.01: # Only show if significant
                    send action bar "&6Auto-Clicker: +%.2f Race Progress" to loop-player for 2 seconds with arguments {_autoclick_race_power}

            # Synergy with manual clicking (Conceptual)
            # TODO: If player manually clicked recently, slightly boost auto-clicker effectiveness for a short duration.
            # Example: if (now - ({player::%loop-player's uuid%::last_click_time} ? (now - 10 seconds))) < 5 seconds:
            #    multiply {_autoclicks_per_second} by 1.1 # 10% boost

            # Temporary boost mechanics (Conceptual)
            # TODO: Check for active global or player-specific auto-clicker boosts.
            # if {global_autoclick_boost_active} is true:
            #    multiply {_autoclicks_per_second} by {global_autoclick_boost_multiplier}

# --- Debug Commands (Optional) ---
command /rcdebugclick [<text>] [<offline player>] [<number>]:
    permission: "raceclicker.admin"
    trigger:
        if arg-1 is "setcombo":
            if arg-2 is set and arg-3 is set:
                set {player::%arg-2's uuid%::click_combo} to arg-3
                send "{@prefix} Set %arg-2%'s combo to %arg-3%" to sender
            else:
                send "{@prefix} Usage: /rcdebugclick setcombo <player> <amount>"
        else if arg-1 is "testpower":
            set {_power} to calculateClickPower(player)
            send "{@prefix} Your current calculated click power: %.2f" to player with arguments {_power}
        else:
            send "{@prefix} &7Debug: /rcdebugclick <setcombo|testpower> ..."
# File: data.sk
# Path: race-clicker/core/data.sk
# Description: Player data management, initialization, and access functions.

options:
    prefix: "&6&lRaceClicker &8»&7"
    # Skript handles variable persistence automatically in variables.csv (by default).
    # For larger scale or more complex data, external files (YAML/JSON/DB) would be better,
    # but for this project, we'll rely on Skript's native persistence for simplicity.

# --- Standard Player Variables --- #
# {player::%UUID%::name} - Player's last known name (for display)
# {player::%UUID%::clicks} - Total clicks/currency
# {player::%UUID%::speed-level} - Current speed upgrade level
# {player::%UUID%::autoclicker-level} - Current auto-clicker upgrade level
# {player::%UUID%::prestige-level} - Current prestige level
# {player::%UUID%::prestige-points} - Currency for prestige shop

# --- Statistics Variables --- #
# {player::%UUID%::stats::races_won} - Number of races won
# {player::%UUID%::stats::races_participated} - Total races participated in
# {player::%UUID%::stats::total_clicks_manual} - Total manual clicks made
# {player::%UUID%::stats::total_clicks_autoclicker} - Total auto-clicks generated
# {player::%UUID%::stats::best_times::%track_id%} - Best time for a specific track (timespan)
# {player::%UUID%::stats::join_date} - Timestamp of first join
# {player::%UUID%::stats::last_seen_date} - Timestamp of last quit

# --- Achievement Variables --- #
# {player::%UUID%::achievements::%achievement_id%::unlocked} - Boolean, true if unlocked
# {player::%UUID%::achievements::%achievement_id%::progress} - Current progress if applicable
# {player::%UUID%::achievements::%achievement_id%::unlock_date} - Timestamp of unlock

# --- Race-Specific Variables (Often temporary or session-based, but some might persist) --- #
# {player::%UUID%::in_race} - Boolean, true if currently in a race (managed by racing.sk)
# {player::%UUID%::current_track_id} - ID of the track (managed by racing.sk)
# {player::%UUID%::race_progress_current_race} - Progress in current race (managed by racing.sk/clicking.sk)
# {player::%UUID%::race_citizen_entity_id} - UUID of the citizen entity (managed by citizens.sk/racing.sk)
# {player::%UUID%::race_start_time_personal} - Timestamp for personal race duration (managed by racing.sk)

# --- Cached/Calculated Variables (Non-persistent, recalculated as needed) --- #
# {cache::%UUID%::effective_click_power} - Calculated click power including bonuses
# {cache::%UUID%::next_combo_reset_time} - Timestamp for combo system
# {cache::%UUID%::current_combo_multiplier} - Current combo multiplier

# --- Data Initialization and Management --- #

on join:
    set {_uuid} to player's uuid
    # Store/update player name
    set {player::%{_uuid}%::name} to player's name

    # Initialize core currency and upgrade levels
    if {player::%{_uuid}%::clicks} is not set:
        set {player::%{_uuid}%::clicks} to 0
    if {player::%{_uuid}%::speed-level} is not set:
        set {player::%{_uuid}%::speed-level} to 1
    if {player::%{_uuid}%::autoclicker-level} is not set:
        set {player::%{_uuid}%::autoclicker-level} to 0
    if {player::%{_uuid}%::prestige-level} is not set:
        set {player::%{_uuid}%::prestige-level} to 0
    if {player::%{_uuid}%::prestige-points} is not set:
        set {player::%{_uuid}%::prestige-points} to 0

    # Initialize statistics
    if {player::%{_uuid}%::stats::races_won} is not set:
        set {player::%{_uuid}%::stats::races_won} to 0
    if {player::%{_uuid}%::stats::races_participated} is not set:
        set {player::%{_uuid}%::stats::races_participated} to 0
    if {player::%{_uuid}%::stats::total_clicks_manual} is not set:
        set {player::%{_uuid}%::stats::total_clicks_manual} to 0
    if {player::%{_uuid}%::stats::total_clicks_autoclicker} is not set:
        set {player::%{_uuid}%::stats::total_clicks_autoclicker} to 0
    if {player::%{_uuid}%::stats::join_date} is not set:
        set {player::%{_uuid}%::stats::join_date} to now
    
    # Initialize race-specific (these are typically reset/managed by racing.sk per race)
    set {player::%{_uuid}%::in_race} to false
    delete {player::%{_uuid}%::current_track_id}
    delete {player::%{_uuid}%::race_progress_current_race}
    delete {player::%{_uuid}%::race_citizen_entity_id}
    delete {player::%{_uuid}%::race_start_time_personal}

    # Initialize achievement parent variable if not present (individual achievements handled by achievements.sk)
    if {player::%{_uuid}%::achievements::*} is not set:
        # This just ensures the parent list exists; specific achievements are added as they are defined/unlocked.
        pass 

    # Initialize cache variables (non-persistent)
    delete {cache::%{_uuid}%::*}
    set {cache::%{_uuid}%::current_combo_multiplier} to 1

    # Welcome message for new players
    if {player::%{_uuid}%::stats::join_date} is now: # A bit of a hack, assumes join_date was just set
        send "{@prefix} &aWelcome to Race Clicker, %player%! Click the special item in your hotbar to get started."
    else:
        send "{@prefix} &aWelcome back, %player%!"

on quit:
    set {_uuid} to player's uuid
    set {player::%{_uuid}%::stats::last_seen_date} to now
    # Skript automatically saves variables listed in variables.csv on server stop/reload.
    # No explicit save command is needed here for Skript's native variable system.
    # If using YAML/DB, saving would happen here or periodically.

    # Clear non-persistent cache for the player
    delete {cache::%{_uuid}%::*}

# --- Data Accessor Functions --- #

# Generic function to get a player's data value with a default if not set.
function getPlayerData(p: player, path: text, default_value: object = 0) :: object:
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::%{_path}%} is set:
        return {player::%{_uuid}%::%{_path}%}
    else:
        return {_default_value}

# Generic function to set a player's data value.
function setPlayerData(p: player, path: text, value: object):
    set {_uuid} to {_p}'s uuid
    set {player::%{_uuid}%::%{_path}%} to {_value}

# Generic function to add to a player's numerical data value.
function addPlayerData(p: player, path: text, value: number):
    set {_uuid} to {_p}'s uuid
    set {_current_value} to getPlayerData({_p}, {_path}, 0)
    if {_current_value} is a number and {_value} is a number:
        set {player::%{_uuid}%::%{_path}%} to {_current_value} + {_value}
    else:
        send console "[RaceClicker Data] Error: Tried to numerically add to non-numeric or unset path '%{_path}%' for player %{_p}%."

# Generic function to remove from a player's numerical data value.
function removePlayerData(p: player, path: text, value: number):
    addPlayerData({_p}, {_path}, -{_value})

# Generic function to delete a player's data path.
function deletePlayerData(p: player, path: text):
    set {_uuid} to {_p}'s uuid
    delete {player::%{_uuid}%::%{_path}%}

# --- Cache Management (Example) --- #
# This is a conceptual placeholder. Actual caching logic will be integrated
# into specific scripts (e.g., clicking.sk for click power) where calculations occur.

# function updatePlayerCache(p: player):
#     set {_uuid} to {_p}'s uuid
#     # Example: Recalculate effective click power (from clicking.sk logic)
#     set {_base_power} to getPlayerData({_p}, "speed-level", 1)
#     set {_prestige_bonus} to getPlayerData({_p}, "prestige-level", 0) * 0.1 # Example bonus
#     set {_combo_multiplier} to {cache::%{_uuid}%::current_combo_multiplier} ? 1
#     set {cache::%{_uuid}%::effective_click_power} to ({_base_power} + {_prestige_bonus}) * {_combo_multiplier}

# Periodically, or on demand, other scripts can call updatePlayerCache(player)
# or directly access/calculate values as needed. For a clicker, on-demand calculation
# during the click event is often sufficient unless calculations are extremely heavy.

# --- Data Reset Function (for admin or prestige) --- #
function resetPlayerDataForPrestige(p: player):
    set {_uuid} to {_p}'s uuid
    send "{@prefix} &eResetting your progress for prestige..." to {_p}

    # Variables to reset
    setPlayerData({_p}, "clicks", 0)
    setPlayerData({_p}, "speed-level", 1)
    setPlayerData({_p}, "autoclicker-level", 0)
    # Keep prestige level and points
    # {player::%{_uuid}%::prestige-level} - Handled by prestige.sk
    # {player::%{_uuid}%::prestige-points} - Handled by prestige.sk

    # Reset relevant stats (optional, depends on design)
    # setPlayerData({_p}, "stats::total_clicks_manual", 0)
    # setPlayerData({_p}, "stats::total_clicks_autoclicker", 0)
    # Clear best times for tracks, or keep them as a record of past glory
    # delete {player::%{_uuid}%::stats::best_times::*}

    # Clear current race state if any (shouldn't happen if prestige is from lobby)
    setPlayerData({_p}, "in_race", false)
    deletePlayerData({_p}, "current_track_id")
    deletePlayerData({_p}, "race_progress_current_race")
    # Citizen removal would be handled by racing.sk/citizens.sk if in race

    # Reset combo cache
    set {cache::%{_uuid}%::current_combo_multiplier} to 1
    delete {cache::%{_uuid}%::next_combo_reset_time}

    send "{@prefix} &aYour progress has been reset. You can now spend your prestige points!" to {_p}

# Full data wipe function (for admins)
function wipePlayerData(target_player_uuid: text, admin_player: player = unsetValue):
    if {player::%{_target_player_uuid}%::name} is not set:
        if {_admin_player} is set:
            send "{@prefix} &cNo data found for UUID %{_target_player_uuid}%." to {_admin_player}
        else:
            send console "[RaceClicker Data] No data found for UUID %{_target_player_uuid}% during wipe."
        return
    
    set {_target_name} to {player::%{_target_player_uuid}%::name}
    delete {player::%{_target_player_uuid}%::*}
    delete {cache::%{_target_player_uuid}%::*}
    # Note: This deletes ALL variables under {player::%uuid%::*}. 
    # If the player is online, they will need to re-join for data to re-initialize.

    if {_admin_player} is set:
        send "{@prefix} &aAll data for %{_target_name}% (UUID: %{_target_player_uuid}%) has been wiped." to {_admin_player}
        set {_target_offline_player} to {_target_player_uuid} parsed as offline player
        if {_target_offline_player} is online:
            kick {_target_offline_player} due to "&cYour player data has been reset by an administrator. Please rejoin."
    else:
        send console "[RaceClicker Data] All data for %{_target_name}% (UUID: %{_target_player_uuid}%) has been wiped."

# TODO: Consider batch YAML operations if switching from Skript vars for performance on large scale.
# TODO: Implement a command for admins to clean unused variables (e.g., from players who haven't joined in a long time).
#       This is complex as it requires iterating all stored UUIDs and checking last_seen_date.
".yml", "player::%player's uuid%::*")

# Function to get player data safely with defaults
# function getPlayerData(p: player, path: text, default: any = 0) :: any:
#     return {player::%{_p}'s uuid%::%{_path}%} ? {_default}

# --- Phase 1: Fix variable reference issues ---
# - Ensure all variable references throughout the project use a consistent format, e.g., {player::%player's uuid%::variable_name}
# - Replace `{_bonus}` placeholders with proper variable references (this will be done in other files where they appear)
# - Fix all variable formatting in send messages (this will be done in other files)

# --- Phase 7: Optimize Skript Performance ---
# Reduce variable operations
# Example from plan.md (conceptual, actual implementation might differ):
# # Cache frequently used calculations
# every 1 second:
#     loop all players:
#         calculateAndCachePlayerStats(loop-player)

# function calculateAndCachePlayerStats(p: player):
#     # Example: Calculate effective click power including all bonuses
#     set {_effective_power} to {player::%{_p}'s uuid%::speed-level}
#     # add prestige bonuses, temporary boosts, etc.
#     set {cache::%{_p}'s uuid%::effective_click_power} to {_effective_power}
#     # This cached value can then be used by clicking.sk or racing.sk
# File: racing.sk
# Path: race-clicker/core/racing.sk
# Description: Race mechanics, track management, and player race state.

# --- Required Scripts --- #
# Ensure all listed scripts exist in the specified paths or relative to the script's location.
# Skript will automatically look for .sk files.
options:
    required_scripts: core/utils, core/config, integration/citizens, integration/camera, dynamic_camera_effects, features/leaderboards

# Options specific to racing.sk, distinct from the global required_scripts
options:
    prefix: "&6&lRaceClicker &8»"
    admin_permission: "raceclicker.admin"
    default_race_length: 1000 # Arbitrary length for a race if not defined by track
    countdown_seconds: 5
    max_players_per_race: 10
    min_players_to_start: 1 # For testing, usually 2+

# Variables:
# {race::active} - boolean, true if a race is currently in countdown or progress
# {race::track_id} - string, ID of the current/upcoming track
# {race::status} - string, e.g., "lobby", "countdown", "inprogress", "finished"
# {race::players::*} - list of players participating in the current race
# {race::finished_players::*} - list of players who have finished, with their times/ranks
# {race::start_time} - timestamp when the race actually began (after countdown)

# Player-specific race variables (managed in data.sk, accessed here):
# {player::%uuid%::in_race} - boolean
# {player::%uuid%::current_track_id} - string
# {player::%uuid%::race_progress_current_race} - number (0 to track_length)
# {player::%uuid%::race_start_time_personal} - timestamp for personal race duration
# {player::%uuid%::race_citizen_entity_id} - from citizens.sk

# Track Data (Ideally loaded from YAML, for now, in-script definitions for simplicity)
# {tracks::%track_id%::name} - Display name
# {tracks::%track_id%::length} - Total progress units needed to finish
# {tracks::%track_id%::start_location} - Location for spawning citizens
# {tracks::%track_id%::waypoints::*} - List of locations defining the path
# {tracks::%track_id%::finish_region} - A region defining the finish line (requires a region addon or manual checks)
# {tracks::%track_id%::difficulty} - e.g., "Easy", "Medium", "Hard"
# {tracks::%track_id%::obstacles::*} - List of locations (as strings) for obstacles
# {tracks::%track_id%::obstacles::%location_as_string%::type} - e.g., \"slow_down\", \"temporary_blindness\" (string)
# {tracks::%track_id%::obstacles::%location_as_string%::duration} - duration of effect in ticks (number)
# {tracks::%track_id%::obstacles::%location_as_string%::magnitude} - magnitude of effect (e.g., speed reduction factor) (number)
# {tracks::%track_id%::boost_pads::*} - List of locations (as strings) for boost pads
# {tracks::%track_id%::boost_pads::%location_as_string%::duration} - duration of boost in ticks (number)
# {tracks::%track_id%::boost_pads::%location_as_string%::magnitude} - progress boost amount or speed multiplier (number)

# Player-specific effect variables (temporary, applied during race loop)
# {player::%uuid%::active_obstacle_effect::type} - string, type of current effect
# {player::%uuid%::active_obstacle_effect::end_time} - timestamp, when the effect wears off
# {player::%uuid%::active_obstacle_effect::magnitude} - number, current obstacle effect magnitude
# {player::%uuid%::active_boost_effect::end_time} - timestamp, when the boost wears off
# {player::%uuid%::active_boost_effect::magnitude} - number, current boost magnitude

on load:
    # Initialize some default tracks if none exist (for testing)
    if not {tracks::testtrack1::name} is set:
        set {tracks::testtrack1::name} to "Test Track Alpha"
        set {tracks::testtrack1::length} to 500
        set {tracks::testtrack1::start_location} to location(0, 64, 0, "world")
        add location(10, 64, 0, "world") to {tracks::testtrack1::waypoints::*}
        add location(20, 64, 10, "world") to {tracks::testtrack1::waypoints::*}
        add location(20, 64, 20, "world") to {tracks::testtrack1::waypoints::*}
        set {tracks::testtrack1::finish_region_loc1} to location(18, 63, 28, "world")
        set {tracks::testtrack1::finish_region_loc2} to location(22, 68, 32, "world")
        send console "[RaceClicker] Initialized default track 'testtrack1'. Use /rcadmin track setpoint for locations."
    set {race::status} to "lobby"

# --- Core Race Logic --- #
# Race Movement Mechanics
# - Smooth citizen movement along track waypoints
# - Proper track following with interpolation
# - Collision detection and boundaries

function startRaceCountdown(track_id: text):
    if not {race::status} is "lobby":
        broadcast "{@prefix} &cCannot start race: A race is already in progress or countdown (%{race::status}%)."
        return
    if not {_track_id} is set or not {tracks::%{_track_id}%::name} is set:
        broadcast "{@prefix} &cCannot start race: Track ID '%{_track_id}%' is invalid or not found."
        return
    if size of {race::players::*} < {@min_players_to_start}:
        broadcast "{@prefix} &cCannot start race: Not enough players. Need %{@min_players_to_start}%, have %{size of {race::players::*}}%"
        return

    set {race::track_id} to {_track_id}
    set {race::status} to "countdown"
    broadcast "{@prefix} &eRace on track &6%{tracks::%{_track_id}%::name}% &estarting in %{@countdown_seconds}% seconds!"

    loop {@countdown_seconds} times:
        set {_remaining_time} to {@countdown_seconds} - (loop-number - 1)
        broadcast "{@prefix} &eRace starting in &c%{_remaining_time}%..."
        loop {race::players::*}:
            set {_p_in_loop} to loop-value-1
            send title "&c%{_remaining_time}%" to {_p_in_loop} for 20 ticks
            play sound "block.note_block.pling" to {_p_in_loop} with pitch ((loop-number / {@countdown_seconds}) * 0.5) + 0.5
        wait 1 second
    
    triggerRaceStart({_track_id})

function triggerRaceStart(track_id: text):
    if not {race::status} is "countdown" or not {race::track_id} is {_track_id}:
        broadcast "{@prefix} &cRace start failed: Race status mismatch or track ID mismatch."
        return
    
    # Initialize race state
    set {race::status} to "inprogress"
    set {race::start_time} to now
    clear {race::finished_players::*}
    
    # Removed main race loop from here, it's a separate timed event

    # Position citizens at start line
    loop {race::players::*}:
        set {_p} to loop-value-1
        set {_uuid} to {_p}'s uuid
        
        # Create or get citizen
        if {player::%{_uuid}%::race_citizen_entity_id} is not set:
            create new citizen named "RaceCitizen_%{_uuid}%" at {tracks::%{_track_id}%::start_location}
            set {player::%{_uuid}%::race_citizen_entity_id} to last created citizen's uuid
        
        # Position citizen at start
        set {_citizen} to entity from uuid {player::%{_uuid}%::race_citizen_entity_id}
        set location of {_citizen} to {tracks::%{_track_id}%::start_location}
        
        # Reset race progress
        set {player::%{_uuid}%::race_progress_current_race} to 0
        set {player::%{_uuid}%::race_start_time_personal} to now
        
        # Enable race camera
        enableRaceCamera({_p}, {_citizen})
        send "{@prefix} &a3rd person race camera enabled!" to {_p}
        
        # Initialize position tracking
        set {player::%{_uuid}%::last_position_update} to now
        set {player::%{_uuid}%::current_waypoint} to 0
        set {player::%{_uuid}%::target_waypoint} to 1
    broadcast "{@prefix} &a&lGO! &eRace on &6%{tracks::%{_track_id}%::name}% &ehas started!"
    loop {race::players::*}:
        set {_p_in_loop} to loop-value-1 # Corrected loop-value to loop-value-1
        send title "&a&lGO!" to {_p_in_loop} with subtitle "&eRace has started!" for 40 ticks
        playSound("entity.ender_dragon.growl", 1, 1.2, {_p_in_loop})
        if {tracks::%{_track_id}%::start_location} is set:
            spawn 10 of particle "cloud" at {tracks::%{_track_id}%::start_location} offset by vector(2, 1, 2) with speed 0.1 for {_p_in_loop}

    loop {race::players::*}:
        set {_player} to loop-value
        set {player::%{_player}'s uuid%::in_race} to true
        set {player::%{_player}'s uuid%::current_track_id} to {_track_id}
        set {player::%{_player}'s uuid%::race_progress_current_race} to 0
        set {player::%{_player}'s uuid%::race_start_time_personal} to now

        # Spawn citizen for the player
        # TODO: Ensure citizens.sk's spawnRaceCitizen is robust and handles potential errors.
        # This requires {tracks::%{_track_id}%::start_location} to be set.
        if {tracks::%{_track_id}%::start_location} is set:
            set {_citizen} to spawnRaceCitizen({_player}, {tracks::%{_track_id}%::start_location}) # From citizens.sk
            if {_citizen} is set:
                # {player::%{_player}'s uuid%::race_citizen_entity_id} is set by spawnRaceCitizen
                send "{@prefix} &7Your racer has been spawned!" to {_player}
                # Call camera.sk to enable 3rd person race camera for {_player}, targeting {_citizen}
                execute function "enableRaceCamera" with arguments {_player}, {_citizen} # from camera.sk
                execute function "onRaceStartForPlayer" with arguments {_player}, {_citizen} # from camera.sk, for start-specific camera adjustments
            else:
                send "{@prefix} &cFailed to spawn your racer! You will race without one." to {_player}
        else:
            send "{@prefix} &cTrack start location not set! Racers cannot be spawned." to {_player}

function playerFinishRace(p: player):
    if not {player::%{_p}'s uuid%::in_race} is true or not {race::status} is "inprogress":
        return

    set {_time_taken} to now - {player::%{_p}'s uuid%::race_start_time_personal}
    add {_p} to {race::finished_players::*}
    set {_rank} to size of {race::finished_players::*}
    set {race::finished_players::%{_p}%::time} to {_time_taken}
    set {race::finished_players::%{_p}%::rank} to {_rank}

    set {player::%{_p}'s uuid%::in_race} to false
    # add 1 to {player::%{_p}'s uuid%::races_won} # Moved to reward section for actual 1st
    add 1 to {player::%{_p}'s uuid%::total_races_participated}

    broadcast "{@prefix} &6%{_p}% &ehas finished the race in position &a#%size of {race::finished_players::*}% &ewith a time of &b%formatTimespan({_time_taken})%&e!"
    send "{@prefix} &aYou finished! Rank: #%size of {race::finished_players::*}%. Time: %formatTimespan({_time_taken})%" to {_p}
    send title "&6&lFINISHED!" to {_p} with subtitle "&eRank #%size of {race::finished_players::*}% | Time: %formatTimespan({_time_taken})%" for 80 ticks
    playSound("entity.player.levelup", 1, 1, {_p})
    execute function "onRaceFinish" with arguments {_p}, {race::finished_players::%{_p}%::rank} # from dynamic_camera_effects.sk
    # Particle effect at finish line
    if {tracks::%{race::track_id}%::finish_line_center} is set:
        spawn 20 of particle firework at {tracks::%{race::track_id}%::finish_line_center} offset by vector(3, 2, 3) for {_p}
    else if {tracks::%{race::track_id}%::finish_region_loc1} is set and {tracks::%{race::track_id}%::finish_region_loc2} is set: # Fallback to midpoint of finish region corners
        set {_finish_mid_x} to (x-coordinate of {tracks::%{race::track_id}%::finish_region_loc1} + x-coordinate of {tracks::%{race::track_id}%::finish_region_loc2}) / 2
        set {_finish_mid_y} to (y-coordinate of {tracks::%{race::track_id}%::finish_region_loc1} + y-coordinate of {tracks::%{race::track_id}%::finish_region_loc2}) / 2
        set {_finish_mid_z} to (z-coordinate of {tracks::%{race::track_id}%::finish_region_loc1} + z-coordinate of {tracks::%{race::track_id}%::finish_region_loc2}) / 2
        set {_world_name} to world of {tracks::%{race::track_id}%::finish_region_loc1}
        set {_finish_center_loc} to location({_finish_mid_x}, {_finish_mid_y}, {_finish_mid_z}, world {_world_name})
        spawn 20 of particle firework at {_finish_center_loc} offset by vector(3, 2, 3) for {_p}

    # Distribute rewards based on rank
    set {_rank} to {race::finished_players::%{_p}%::rank}
    set {_reward_clicks} to 0
    if {_rank} is 1:
        set {_reward_clicks} to 100
        # Update races_won for global leaderboard, only if truly 1st
        add 1 to {player::%{_p}'s uuid%::races_won_global}
        execute function "updateGlobalLeaderboard" with arguments {_p}, "races_won", 1 # from features/leaderboards.sk
    else if {_rank} is 2:
        set {_reward_clicks} to 50
    else if {_rank} is 3:
        set {_reward_clicks} to 25
    else:
        set {_reward_clicks} to 10 # Participation reward for finishing
    
    if {_reward_clicks} > 0:
        add {_reward_clicks} to {player::%{_p}'s uuid%::clicks} # Assuming {player::%uuid%::clicks} is the variable for player's currency
        send "{@prefix} &eYou earned &6%{_reward_clicks}% clicks &efor finishing rank &a#%{_rank}%!" to {_p}
        execute function "updateGlobalLeaderboard" with arguments {_p}, "clicks_earned", {_reward_clicks} # from features/leaderboards.sk

    # Call camera.sk to disable 3rd person race camera for {_p}
    execute function "disableRaceCamera" with argument {_p} # from camera.sk
    execute function "onRaceEndForPlayer" with argument {_p} # from camera.sk, for finish-specific camera transitions
    # Update track leaderboard
    execute function "updateTrackLeaderboard" with arguments {_p}, {race::track_id}, {_time_taken} # from features/leaderboards.sk

    # Play victory pose if player is 1st
    if {race::finished_players::%{_p}%::rank} is 1:
        set {_citizen_uuid_victory} to {player::%{_p}'s uuid%::race_citizen_entity_id}
        if {_citizen_uuid_victory} is set:
            set {_citizen_entity_victory} to entity from uuid {_citizen_uuid_victory}
            if {_citizen_entity_victory} is set:
                execute function "playCitizenVictoryPose" with argument {_citizen_entity_victory} # from citizens.sk
    else: # Play idle for others who finished but didn't win (or before removal)
        set {_citizen_uuid_idle} to {player::%{_p}'s uuid%::race_citizen_entity_id}
        if {_citizen_uuid_idle} is set:
            set {_citizen_entity_idle} to entity from uuid {_citizen_uuid_idle}
            if {_citizen_entity_idle} is set:
                execute function "playCitizenIdleAnimation" with argument {_citizen_entity_idle} # from citizens.sk
                wait 10 ticks # Brief pause to see idle before removal, adjust as needed

    # Call citizens.sk to remove player's race citizen
    execute function "removeRaceCitizen" with argument {_p} # from citizens.sk

    # Check if all players finished
    if size of {race::finished_players::*} is equal to size of {race::players::*}:
        triggerRaceEnd()

function triggerRaceEnd():
    if not {race::status} is "inprogress" and not {race::status} is "finished": # Can be called if race times out too
        return
    broadcast "{@prefix} &eThe race on &6%{tracks::%{race::track_id}%::name}% &ehas concluded!"
    set {race::status} to "finished"

    # Display leaderboard for the race
    broadcast "{@prefix} &lRace Results:"
    sort {race::finished_players::*} by {race::finished_players::%loop-value%::time} numerically
    loop {race::finished_players::*}:
        set {_p_in_loop} to loop-value
        set {_rank_in_loop} to loop-index
        execute function "updateCitizenRaceIndicator" with arguments {_p_in_loop}, {_rank_in_loop}, size of {race::players::*} # Update final rank display
        # Ensure this doesn't conflict if removeCitizenRaceIndicator is called immediately after in playerFinishRace for this player.
        set {_player} to loop-value
        broadcast "&7- &e#%loop-index%: &b%{_player}% &7(&a%formatTimespan({race::finished_players::%{_player}%::time})%&7)"

    # Cleanup remaining players who might not have finished (e.g., if race ended by admin or timeout)
    loop {race::players::*}:
        if {player::%loop-value's uuid%::in_race} is true:
            # Play idle animation for players who DNF'd and are about to be cleaned up
            set {_citizen_uuid_dnf} to {player::%loop-value's uuid%::race_citizen_entity_id}
            if {_citizen_uuid_dnf} is set:
                set {_citizen_entity_dnf} to entity from uuid {_citizen_uuid_dnf}
                if {_citizen_entity_dnf} is set:
                    execute function "playCitizenIdleAnimation" with argument {_citizen_entity_dnf} # from citizens.sk
                    wait 10 ticks # Brief pause
            # End of DNF idle animation call

            set {player::%loop-value's uuid%::in_race} to false
            execute function "disableRaceCamera" with argument loop-value # from camera.sk
            execute function "removeRaceCitizen" with argument loop-value # from citizens.sk (this will also call removeCitizenRaceIndicator)
            send "{@prefix} &cThe race has ended." to loop-value

    clear {race::players::*}
    # {race::track_id} can remain for viewing last race info
    set {race::status} to "lobby" # Ready for a new race
    send "{@prefix} &aReturning to lobby state." to console

    # Potentially trigger idle animations for all remaining citizens if any are kept in lobby
    # For now, citizens are removed. If a lobby system with visible citizens is added,
    # this would be the place to loop through them and call playCitizenIdleAnimation.


# --- Player Progress and Movement Update Loop --- #
every 10 ticks: # Update rate for citizen movement and finish line checks (0.5 seconds)
    if {race::status} is not "inprogress":
        stop

    # Real-time Ranking Logic
    clear {_ranked_racers::*}
    loop {race::players::*}:
        if {player::%loop-value's uuid%::in_race} is true:
            # Play idle animation for players who DNF'd and are about to be cleaned up
            set {_citizen_uuid_dnf} to {player::%loop-value's uuid%::race_citizen_entity_id}
            if {_citizen_uuid_dnf} is set:
                set {_citizen_entity_dnf} to entity from uuid {_citizen_uuid_dnf}
                if {_citizen_entity_dnf} is set:
                    execute function "playCitizenIdleAnimation" with argument {_citizen_entity_dnf} # from citizens.sk
                    wait 10 ticks # Brief pause
            # End of DNF idle animation call

            add loop-value to {_ranked_racers::*}
    
    # Sort players by progress (descending). If progress is equal, maintain original order or use join time (not implemented here for simplicity)
    sort {_ranked_racers::*} by {player::%loop-value's uuid%::race_progress_current_race} numerically descending

    # Assign ranks and update indicators
    set {_total_racers_in_loop} to size of {_ranked_racers::*}
    loop {_ranked_racers::*}:
        set {_player_for_rank_update} to loop-value
        set {_current_rank_for_player} to loop-index
        # Call updateCitizenRaceIndicator for each player with their calculated rank
        execute function "updateCitizenRaceIndicator" with arguments {_player_for_rank_update}, {_current_rank_for_player}, {_total_racers_in_loop} # from citizens.sk

    # Main player loop for movement, effects, etc.
    loop {race::players::*}: # This loop is now primarily for game logic other than rank display which is handled above.
        set {_player} to loop-value-1 # Corrected loop-value to loop-value-1
        if {player::%{_player}'s uuid%::in_race} is true:
            set {_progress} to {player::%{_player}'s uuid%::race_progress_current_race} ? 0
            set {_track_id} to {player::%{_player}'s uuid%::current_track_id}
            set {_track_length} to {tracks::%{_track_id}%::length} ? {@default_race_length}

            # Rank display is now handled in the ranking logic at the start of the 'every 10 ticks' loop.
            # The call to updateCitizenRaceIndicator has been moved there.

            # Move citizen
            set {_citizen_uuid} to {player::%{_player}'s uuid%::race_citizen_entity_id}
            if {_citizen_uuid} is set:
                set {_citizen_entity} to entity from uuid {_citizen_uuid}
                if {_citizen_entity} is set:
                    set {_track_start_loc} to {tracks::%{_track_id}%::start_location}
                    set {_track_waypoints::*} to {tracks::%{_track_id}%::waypoints::*}
                    if {_track_start_loc} is set and {tracks::%{_track_id}%::waypoints::*} is set and size of {_track_waypoints::*} > 0:
                        execute function "moveCitizenOnTrack" with arguments {_citizen_entity}, {_track_start_loc}, {_track_waypoints::*}, {_progress}, {_track_length} # from citizens.sk
                        send action bar "&7Progress: %.1f / %.1f" to {_player} with arguments {_progress}, {_track_length}
                    else if {_track_start_loc} is set: # Fallback for tracks with no waypoints or empty waypoints list
                        if {tracks::%{_track_id}%::finish_line_center} is set:
                            set {_target_loc} to location between {_track_start_loc} and {tracks::%{_track_id}%::finish_line_center} at ratio ({_progress} / {_track_length})
                            teleport {_citizen_entity} to {_target_loc}
                            make {_citizen_entity} look at {tracks::%{_track_id}%::finish_line_center}
                            send action bar "&7Progress (approx): %.1f / %.1f" to {_player} with arguments {_progress}, {_track_length}
                        else if {tracks::%{_track_id}%::finish_region_loc1} is set: # Fallback to first corner of finish region
                            set {_target_loc} to location between {_track_start_loc} and {tracks::%{_track_id}%::finish_region_loc1} at ratio ({_progress} / {_track_length})
                            teleport {_citizen_entity} to {_target_loc}
                            make {_citizen_entity} look at {tracks::%{_track_id}%::finish_region_loc1}
                            send action bar "&7Progress (approx): %.1f / %.1f" to {_player} with arguments {_progress}, {_track_length}
                        else:
                            send action bar "&cTrack data incomplete for precise movement..." to {_player}
                    else:
                        send action bar "&cTrack start location missing for movement..." to {_player}

            # Check for finish line AFTER movement
            if {_progress} >= {_track_length}:
                if {player::%{_player}'s uuid%::in_race} is true: # Ensure they haven't already finished this tick
                    playerFinishRace({_player})
                    continue loop # Skip obstacle/boost checks for finished player

            # Obstacle and Boost Pad Logic (based on citizen's NEW location after movement)
            if {_citizen_uuid} is set and {_citizen_entity} is set: # Ensure citizen exists before checking its location
                # Round citizen's location to match how locations are stored for obstacles/boosts (integer coords)
                set {_cx} to round(x-coordinate of location of {_citizen_entity})
                set {_cy} to round(y-coordinate of location of {_citizen_entity})
                set {_cz} to round(z-coordinate of location of {_citizen_entity})
                set {_cw} to world of location of {_citizen_entity}
                set {_citizen_rounded_loc_string} to "%world of location of {_citizen_entity}%,%round(x-coordinate of location of {_citizen_entity})%,%round(y-coordinate of location of {_citizen_entity})%,%round(z-coordinate of location of {_citizen_entity})%"

                # Check for obstacles
                if {tracks::%{_track_id}%::obstacles::%{_citizen_rounded_loc_string}%::type} is set:
                    if {player::%{_player}'s uuid%::active_obstacle_effect::end_time} is not set or {player::%{_player}'s uuid%::active_obstacle_effect::end_time} < now:
                        set {_obstacle_type} to {tracks::%{_track_id}%::obstacles::%{_citizen_rounded_loc_string}%::type} ? "slow_down"
                        set {_obstacle_duration_ticks} to {tracks::%{_track_id}%::obstacles::%{_citizen_rounded_loc_string}%::duration} ? 60 # 3 seconds default
                        set {_obstacle_magnitude} to {tracks::%{_track_id}%::obstacles::%{_citizen_rounded_loc_string}%::magnitude} ? 0.5 # 50% speed reduction default
                        set {player::%{_player}'s uuid%::active_obstacle_effect::type} to {_obstacle_type}
                        set {player::%{_player}'s uuid%::active_obstacle_effect::end_time} to (now + {_obstacle_duration_ticks} ticks)
                        set {player::%{_player}'s uuid%::active_obstacle_effect::magnitude} to {_obstacle_magnitude}
                        send "{@prefix} &cYou hit an obstacle! (%{_obstacle_type}%) Effect active for %{_obstacle_duration_ticks} / 20% seconds." to {_player}
                        playSound("entity.zombie.hurt", 1, 0.8, {_player})
                        spawn 10 of particle crit at location of {_citizen_entity} offset by vector(0.5, 0.5, 0.5) with speed 0.1 for {_player}
                        execute function "onObstacleHit" with argument {_player} # from dynamic_camera_effects.sk
                # Check for boost pads
                else if {tracks::%{_track_id}%::boost_pads::%{_citizen_rounded_loc_string}%::magnitude} is set: # Use 'else if' to prevent applying boost and obstacle simultaneously from same block
                    if {player::%{_player}'s uuid%::active_boost_effect::end_time} is not set or {player::%{_player}'s uuid%::active_boost_effect::end_time} < now:
                        set {_boost_duration_ticks} to {tracks::%{_track_id}%::boost_pads::%{_citizen_rounded_loc_string}%::duration} ? 40 # 2 seconds default
                        set {_boost_magnitude} to {tracks::%{_track_id}%::boost_pads::%{_citizen_rounded_loc_string}%::magnitude} ? 1.5 # 1.5x progress gain default
                        set {player::%{_player}'s uuid%::active_boost_effect::end_time} to (now + {_boost_duration_ticks} ticks)
                        set {player::%{_player}'s uuid%::active_boost_effect::magnitude} to {_boost_magnitude}
                        send "{@prefix} &aBoost Pad! Effect active for %{_boost_duration_ticks} / 20% seconds." to {_player}
                        playSound("entity.generic.explode", 0.5, 1.5, {_player})
                        spawn 15 of particle flame at location of {_citizen_entity} offset by vector(0.5, 0.5, 0.5) with speed 0.05 for {_player}
                        execute function "onBoostPadHit" with argument {_player} # from dynamic_camera_effects.sk

            # Clear expired effects
            if {player::%{_player}'s uuid%::active_obstacle_effect::end_time} is set and {player::%{_player}'s uuid%::active_obstacle_effect::end_time} < now:
                delete {player::%{_player}'s uuid%::active_obstacle_effect::type}
                delete {player::%{_player}'s uuid%::active_obstacle_effect::end_time}
                delete {player::%{_player}'s uuid%::active_obstacle_effect::magnitude}
                send "{@prefix} &aObstacle effect wore off." to {_player}

            if {player::%{_player}'s uuid%::active_boost_effect::end_time} is set and {player::%{_player}'s uuid%::active_boost_effect::end_time} < now:
                delete {player::%{_player}'s uuid%::active_boost_effect::end_time}
                delete {player::%{_player}'s uuid%::active_boost_effect::magnitude}
                send "{@prefix} &eBoost wore off." to {_player}

# --- Player Commands --- #
command /race [<join|leave|info|list>] [<text>]:
    trigger:
        if arg-1 is not set or arg-1 is "info":
            send "{@prefix} &7Current race status: &e%{race::status}%"
            if {race::status} is not "lobby":
                send "{@prefix} &7Track: &6%{tracks::%{race::track_id}%::name}%"
                send "{@prefix} &7Players: &b%size of {race::players::*}% / %{@max_players_per_race}%"
            send "{@prefix} &7Available tracks: (use /race list)"
            send "{@prefix} &7Commands: /race join <track_id>, /race leave"
            stop

        if arg-1 is "list":
            send "{@prefix} &eAvailable Race Tracks:"
            if size of {tracks::*} is 0:
                send "&c - No tracks defined yet. An admin needs to create them."
                stop
            loop {tracks::*}:
                send "&7 - &b%loop-index%&7: &a%loop-value::name% &7(Length: %loop-value::length ? {@default_race_length}%, Difficulty: %loop-value::difficulty ? "N/A"%)"
            stop

        if arg-1 is "join":
            if {race::status} is not "lobby":
                send "{@prefix} &cCannot join: A race is already in %{race::status}% state."
                stop
            if size of {race::players::*} >= {@max_players_per_race}:
                send "{@prefix} &cCannot join: The race lobby is full (%{@max_players_per_race}% players)."
                stop
            if player is in {race::players::*}:
                send "{@prefix} &cYou are already in the race lobby."
                stop
            # For now, any race started by admin uses the admin-specified track.
            # If players could choose or vote, arg-2 would be track_id.
            add player to {race::players::*}
            broadcast "{@prefix} &b%player% &ehas joined the race lobby! (&a%size of {race::players::*}%/%{@max_players_per_race}%&e)"
            stop

        if arg-1 is "leave":
            if player is not in {race::players::*}:
                send "{@prefix} &cYou are not in the race lobby or current race."
                stop
            if {race::status} is "inprogress" and {player::%player's uuid%::in_race} is true:
                # Handle leaving mid-race (DNF - Did Not Finish)
                set {player::%player's uuid%::in_race} to false
                # removeRaceCitizen(player)
                # disableRaceCamera(player)
                send "{@prefix} &cYou have left the race."
                broadcast "{@prefix} &b%player% &chas left the ongoing race."
                remove player from {race::players::*} # Also remove from active list
                # Check if this ends the race (e.g., if last player leaves)
                if {race::status} is "inprogress" and size of {race::players::*} < {@min_players_to_start} and size of {race::players::*} < 1: # If all active players left
                    broadcast "{@prefix} &cAll players have left the race. Ending race."
                    triggerRaceEnd()
                stop

            remove player from {race::players::*}
            broadcast "{@prefix} &b%player% &ehas left the race lobby. (&a%size of {race::players::*}%/%{@max_players_per_race}%&e)"
            stop

# --- Admin Commands for Racing --- #
command /rcadmin race [<text>] [<text>] [<text>] [<text>] [<text>] [<text>]: # Increased args for obstacle/boost params
    permission: {@admin_permission}
    trigger:
        if arg-1 is "start":
            if arg-2 is not set:
                send "{@prefix} &cUsage: /rcadmin race start <track_id>"
                stop
            startRaceCountdown(arg-2)
            stop

        if arg-1 is "stop":
            if {race::status} is "lobby" or {race::status} is "finished":
                send "{@prefix} &cNo race is currently active to stop."
                stop
            broadcast "{@prefix} &cThe current race has been stopped by an administrator!"
            triggerRaceEnd() # This will handle cleanup
            stop
        
        if arg-1 is "createtrack":
            if arg-2 is not set:
                send "{@prefix} &cUsage: /rcadmin race createtrack <track_id> <Track Name>"
                stop
            if {tracks::%arg-2%::name} is set:
                send "{@prefix} &cTrack ID '%arg-2%' already exists."
                stop
            set {tracks::%arg-2%::name} to arg-3 ? arg-2 # Default name to ID if not provided
            set {tracks::%arg-2%::length} to {@default_race_length}
            send "{@prefix} &aTrack '%arg-3%' (ID: %arg-2%) created with default length. Use /rcadmin race setpoint to define its path."
            stop

        if arg-1 is "deletetrack":
            if arg-2 is not set or {tracks::%arg-2%::name} is not set:
                send "{@prefix} &cUsage: /rcadmin race deletetrack <track_id>. Track not found."
                stop
            clear {tracks::%arg-2%::*}
            send "{@prefix} &aTrack '%arg-2%' deleted."
            stop

        if arg-1 is "setpoint": 
            if arg-2 is not set or arg-3 is not set:
                send "{@prefix} &cUsage: /rcadmin race setpoint <track_id> <type> [value/here] [param1] [param2] [param3]"
                send "{@prefix} &cTypes: start, waypoint, clearwaypoints, finish1, finish2, length, name, difficulty, obstacle, boostpad, removelastobstacle, removelastboostpad, removelastwaypoint"
                stop
            set {_track_id} to arg-2
            if {tracks::%{_track_id}%::name} is not set and arg-3 is not "createtrack": # Allow createtrack without existing track
                send "{@prefix} &cTrack ID '%{_track_id}%' not found. Create it first."
                stop
            set {_point_type} to lowercased arg-3
            set {_value} to arg-4 # This can be 'here' or a specific value depending on _point_type

            if {_point_type} is "start":
                set {tracks::%{_track_id}%::start_location} to player's location
                send "{@prefix} &aStart point for track '%{_track_id}%' set to your location."
            else if {_point_type} is "waypoint":
                add player's location to {tracks::%{_track_id}%::waypoints::*}
                send "{@prefix} &aWaypoint #%size of {tracks::%{_track_id}%::waypoints::*}% for track '%{_track_id}%' added at your location."
            else if {_point_type} is "removelastwaypoint":
                if size of {tracks::%{_track_id}%::waypoints::*} > 0:
                    remove last element from {tracks::%{_track_id}%::waypoints::*}
                    send "{@prefix} &aLast waypoint removed from track '%{_track_id%}%'."
                else:
                    send "{@prefix} &cNo waypoints to remove from track '%{_track_id%}%'."
            else if {_point_type} is "clearwaypoints":
                clear {tracks::%{_track_id}%::waypoints::*}
                send "{@prefix} &aAll waypoints for track '%{_track_id}%' cleared."
            else if {_point_type} is "finish1": # Define one corner of finish region
                set {tracks::%{_track_id}%::finish_region_loc1} to player's location
                send "{@prefix} &aFinish region corner 1 for track '%{_track_id}%' set."
            else if {_point_type} is "finish2": # Define other corner of finish region
                set {tracks::%{_track_id}%::finish_region_loc2} to player's location
                send "{@prefix} &aFinish region corner 2 for track '%{_track_id}%' set."
            else if {_point_type} is "length":
                set {_len} to {_value} parsed as number
                if {_len} is not set or {_len} <= 0:
                    send "{@prefix} &cInvalid length: %{_value}%"
                    stop
                set {tracks::%{_track_id}%::length} to {_len}
                send "{@prefix} &aTrack '%{_track_id}%' length set to %{_len}% units."
            else if {_point_type} is "name":
                set {tracks::%{_track_id}%::name} to {_value}
                send "{@prefix} &aTrack '%{_track_id}%' name set to '%{_value}%'."
            else if {_point_type} is "difficulty":
                set {tracks::%{_track_id}%::difficulty} to {_value}
                send "{@prefix} &aTrack '%{_track_id}%' difficulty set to '%{_value}%'."
            else if {_point_type} is "obstacle":
                set {_loc_string} to "%player's location%"
                set {_obstacle_type} to arg-5 ? "slow_down"
                set {_obstacle_duration} to arg-6 parsed as number ? 60
                set {_obstacle_magnitude} to arg-7 parsed as number ? 0.5
                add {_loc_string} to {tracks::%{_track_id}%::obstacles::*}
                set {tracks::%{_track_id}%::obstacles::%{_loc_string}%::type} to {_obstacle_type}
                set {tracks::%{_track_id}%::obstacles::%{_loc_string}%::duration} to {_obstacle_duration}
                set {tracks::%{_track_id}%::obstacles::%{_loc_string}%::magnitude} to {_obstacle_magnitude}
                send "{@prefix} &aObstacle ('%{_obstacle_type}%', %{_obstacle_duration}%t, mag %{_obstacle_magnitude}%) added to '%{_track_id}%' at your location (%{_loc_string}%)."
            else if {_point_type} is "boostpad":
                set {_loc_string} to "%player's location%"
                set {_boost_duration} to arg-5 parsed as number ? 40
                set {_boost_magnitude} to arg-6 parsed as number ? 1.5
                add {_loc_string} to {tracks::%{_track_id}%::boost_pads::*}
                set {tracks::%{_track_id}%::boost_pads::%{_loc_string}%::duration} to {_boost_duration}
                set {tracks::%{_track_id}%::boost_pads::%{_loc_string}%::magnitude} to {_boost_magnitude}
                send "{@prefix} &aBoost pad (%{_boost_duration}%t, mag %{_boost_magnitude}%) added to '%{_track_id}%' at your location (%{_loc_string}%)."
            else if {_point_type} is "removelastobstacle":
                if size of {tracks::%{_track_id}%::obstacles::*} > 0:
                    set {_last_obstacle_loc_string} to last element of {tracks::%{_track_id}%::obstacles::*}
                    remove last element from {tracks::%{_track_id}%::obstacles::*}
                    delete {tracks::%{_track_id}%::obstacles::%{_last_obstacle_loc_string}%::type}
                    delete {tracks::%{_track_id}%::obstacles::%{_last_obstacle_loc_string}%::duration}
                    delete {tracks::%{_track_id}%::obstacles::%{_last_obstacle_loc_string}%::magnitude}
                    send "{@prefix} &aLast obstacle removed from track '%{_track_id}%'."
                else:
                    send "{@prefix} &cNo obstacles to remove from track '%{_track_id%}%'."
            else if {_point_type} is "removelastboostpad":
                if size of {tracks::%{_track_id}%::boost_pads::*} > 0:
                    set {_last_boost_loc_string} to last element of {tracks::%{_track_id}%::boost_pads::*}
                    remove last element from {tracks::%{_track_id}%::boost_pads::*}
                    delete {tracks::%{_track_id}%::boost_pads::%{_last_boost_loc_string}%::duration}
                    delete {tracks::%{_track_id}%::boost_pads::%{_last_boost_loc_string}%::magnitude}
                    send "{@prefix} &aLast boost pad removed from track '%{_track_id%}%'."
                else:
                    send "{@prefix} &cNo boost pads to remove from track '%{_track_id%}%'."
            else:
                send "{@prefix} &cInvalid setpoint type. Use: start, waypoint, clearwaypoints, finish1, finish2, length, name, difficulty, obstacle, boostpad, removelastobstacle, removelastboostpad, removelastwaypoint."
            stop

        if arg-1 is "trackinfo":
            if arg-2 is not set or {tracks::%arg-2%::name} is not set:
                send "{@prefix} &cUsage: /rcadmin race trackinfo <track_id>. Track not found."
                stop
            set {_track_id} to arg-2
            send "{@prefix} &6Track Info for: %{_track_id}% (%{tracks::%{_track_id}%::name}%)"
            send "&e - Length: &b%{tracks::%{_track_id}%::length}% units"
            send "&e - Difficulty: &b%{tracks::%{_track_id}%::difficulty ? "N/A"}%"
            send "&e - Start Location: &b%{tracks::%{_track_id}%::start_location}%"
            send "&e - Waypoints (%size of {tracks::%{_track_id}%::waypoints::*}%):"
            loop {tracks::%{_track_id}%::waypoints::*}:
                send "&7  - %loop-value%"
            send "&e - Finish Region Corner 1: &b%{tracks::%{_track_id}%::finish_region_loc1}%"
            send "&e - Finish Region Corner 2: &b%{tracks::%{_track_id}%::finish_region_loc2}%"
            send "&e - Obstacles (%size of {tracks::%{_track_id}%::obstacles::*}%):"
            loop {tracks::%{_track_id}%::obstacles::*}:
                set {_obs_loc_str} to loop-value
                send "&7  - Loc: %{_obs_loc_str}%, Type: %{tracks::%{_track_id}%::obstacles::%{_obs_loc_str}%::type}%, Dur: %{tracks::%{_track_id}%::obstacles::%{_obs_loc_str}%::duration}%, Mag: %{tracks::%{_track_id}%::obstacles::%{_obs_loc_str}%::magnitude}%"
            send "&e - Boost Pads (%size of {tracks::%{_track_id}%::boost_pads::*}%):"
            loop {tracks::%{_track_id}%::boost_pads::*}:
                set {_bst_loc_str} to loop-value
                send "&7  - Loc: %{_bst_loc_str}%, Dur: %{tracks::%{_track_id}%::boost_pads::%{_bst_loc_str}%::duration}%, Mag: %{tracks::%{_track_id}%::boost_pads::%{_bst_loc_str}%::magnitude}%"
            stop

        send "{@prefix} &cUnknown race admin command. See /rcadmin help (TODO)"

# --- Utility Functions --- #
function formatTimespan(t: timespan) :: text:
    set {_seconds} to total seconds of {_t}
    set {_minutes} to floor({_seconds} / 60)
    set {_remaining_seconds} to {_seconds} mod 60
    return "%%02d:%%.2f" formatted with {_minutes}, {_remaining_seconds} # Corrected formatting string

# TODO: Implement spectator mode
# TODO: Add team racing modes
# TODO: Dynamic track loading from YAML (Phase 4)
# TODO: Track-specific features like obstacles and boosts (Phase 4)
# TODO: More robust finish line detection (e.g., using Skript-Regions or similar addon if available, or more complex location math)
# TODO: Integrate calls to camera.sk for 3rd person camera management
# TODO: Integrate calls to citizens.sk for spawning, moving, and removing race citizens
# File: debug_system.sk
# Description: Debug system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    debug_mode: false # Global debug mode
    debug_commands: true # Enable debug commands
    debug_log_file: "raceclicker_debug.log" # Debug log file path
    debug_log_level: "INFO" # Debug log level (INFO, WARN, ERROR)
    
# Variables:
# {player::%uuid%::debug_mode} = boolean (player's debug mode)
# {player::%uuid%::debug_target} = text (debug target entity/player)

# Function to enable debug mode
function enableDebugMode(p: player):
    set {_uuid} to {_p}'s uuid
    set {player::%{_uuid}%::debug_mode} to true
    set {player::%{_uuid}%::debug_target} to null
    send "{@prefix} &aDebug Mode Enabled!" to {_p}
    
    # Send debug commands list
    send "&eDebug Commands:" to {_p}
    send "&7- /debug toggle - Toggle debug mode" to {_p}
    send "&7- /debug target <player/entity> - Set debug target" to {_p}
    send "&7- /debug stats - Show debug statistics" to {_p}
    send "&7- /debug log <level> - Set log level" to {_p}

# Function to disable debug mode
function disableDebugMode(p: player):
    set {_uuid} to {_p}'s uuid
    delete {player::%{_uuid}%::debug_mode}
    delete {player::%{_uuid}%::debug_target}
    send "{@prefix} &cDebug Mode Disabled!" to {_p}

# Function to set debug target
function setDebugTarget(p: player, target: text):
    set {_uuid} to {_p}'s uuid
    set {player::%{_uuid}%::debug_target} to {_target}
    send "{@prefix} &aDebug Target Set: %{_target}%" to {_p}

# Function to get debug stats
function getDebugStats(p: player) :: text:
    set {_uuid} to {_p}'s uuid
    set {_stats} to "&6Debug Stats:\n"
    
    # Add player stats
    append "&ePlayer: &a%{_p}%\n" to {_stats}
    append "&eUUID: &a%{_uuid}%\n" to {_stats}
    append "&eClicks: &a%{player::%{_uuid}%::clicks}%\n" to {_stats}
    append "&eRace Status: &a%{player::%{_uuid}%::in_race}%\n" to {_stats}
    
    # Add camera stats
    append "&eCamera Mode: &a%{player::%{_uuid}%::camera_mode}%\n" to {_stats}
    
    # Add achievement stats
    set {_ach_count} to 0
    loop all keys of {achievements_list::*}:
        if {player::%{_uuid}%::achievements::%loop-value%} is true:
            add 1 to {_ach_count}
    append "&eAchievements: &a%{_ach_count}%/%{size of {achievements_list::*}}%\n" to {_stats}
    
    # Add prestige stats
    append "&ePrestige Level: &a%{player::%{_uuid}%::prestige_level}%\n" to {_stats}
    
    return {_stats}

# Function to log debug message
function logDebug(message: text, level: text):
    if {debug_mode} is true:
        set {_timestamp} to now in "yyyy-MM-dd HH:mm:ss"
        set {_log_message} to "[%{_timestamp}%] [%{level}%] %{message}%"
        
        # Write to log file
        append line {_log_message} to file {@debug_log_file}
        
        # Send to console if level is INFO or higher
        if {level} is "INFO" or {level} is "WARN" or {level} is "ERROR":
            send "{@prefix} %{_log_message}%" to console

# Command to toggle debug mode
command /debug toggle:
    permission: raceclicker.debug
    trigger:
        if {player::%player's uuid%::debug_mode} is true:
            disableDebugMode(player)
        else:
            enableDebugMode(player)

# Command to set debug target
command /debug target <text>:
    permission: raceclicker.debug
    trigger:
        setDebugTarget(player, arg-1)

# Command to show debug stats
command /debug stats:
    permission: raceclicker.debug
    trigger:
        send "{@prefix} %{getDebugStats(player)}%" to player

# Command to set log level
command /debug log <text>:
    permission: raceclicker.admin
    trigger:
        if arg-1 is "INFO" or arg-1 is "WARN" or arg-1 is "ERROR":
            set {@debug_log_level} to arg-1
            send "{@prefix} &aLog level set to %{arg-1}%" to player
        else:
            send "{@prefix} &cInvalid log level! Use: INFO, WARN, ERROR" to player

# Event handler for debug events
every 1 tick:
    loop all players:
        if {player::%loop-player's uuid%::debug_mode} is true:
            set {_p} to loop-player
            set {_uuid} to {_p}'s uuid
            
            # Log player stats
            if {@debug_log_level} is "INFO":
                set {_stats} to getDebugStats({_p})
                logDebug({_stats}, "INFO")
            
            # Check debug target
            if {player::%{_uuid}%::debug_target} is set:
                set {_target} to {player::%{_uuid}%::debug_target}
                if {_target} is not null:
                    # Log target stats
                    if {@debug_log_level} is "INFO":
                        set {_target_stats} to "&6Target Stats:\n"
                        append "&eTarget: &a%{_target}%\n" to {_target_stats}
                        logDebug({_target_stats}, "INFO")

# Function to get debug mode status
function isDebugModeEnabled(p: player) :: boolean:
    set {_uuid} to {_p}'s uuid
    return {player::%{_uuid}%::debug_mode} is true
# File: economy_system.sk
# Description: Economy system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Currency settings
    currency_name: "ClickCoin"
    currency_symbol: "§" # ClickCoin symbol
    
    # Earning rates
    base_click_earnings: 1.0 # Base earnings per click
    race_win_bonus: 500 # Bonus for winning race
    track_completion_bonus: 250 # Bonus for completing track
    achievement_bonus: 100 # Bonus for achievements
    prestige_bonus: 1000 # Bonus for prestige
    
    # Shop settings
    shop_refresh_time: 5 minutes # How often shop refreshes
    max_items_per_page: 9 # Items per shop page
    
    # Upgrade costs
    speed_upgrade_cost: 1000 # Cost of speed upgrade
    power_upgrade_cost: 1500 # Cost of power upgrade
    combo_upgrade_cost: 800 # Cost of combo upgrade
    accuracy_upgrade_cost: 1200 # Cost of accuracy upgrade

# Variables:
# {player::%uuid%::clickcoins} = number (player's ClickCoins)
# {player::%uuid%::last_shop_refresh} = timestamp (last shop refresh)
# {shop::items::*} = text (list of shop items)
# {shop::prices::*} = number (list of item prices)

# Function to initialize economy
on join:
    set {_p} to player
    set {_uuid} to {_p}'s uuid
    
    # Initialize ClickCoins
    if not {player::%{_uuid}%::clickcoins} is set:
        set {player::%{_uuid}%::clickcoins} to 0
    
    # Initialize shop
    if not {shop::items::*} is set:
        initializeShop()

# Function to initialize shop
function initializeShop():
    # Clear existing shop
    clear {shop::items::*}
    clear {shop::prices::*}
    
    # Add basic upgrades
    add "Speed Upgrade" to {shop::items::*}
    add {@speed_upgrade_cost} to {shop::prices::*}
    
    add "Power Upgrade" to {shop::items::*}
    add {@power_upgrade_cost} to {shop::prices::*}
    
    add "Combo Upgrade" to {shop::items::*}
    add {@combo_upgrade_cost} to {shop::prices::*}
    
    add "Accuracy Upgrade" to {shop::items::*}
    add {@accuracy_upgrade_cost} to {shop::prices::*}
    
    # Add consumables
    add "Speed Boost" to {shop::items::*}
    add 500 to {shop::prices::*}
    
    add "Power Potion" to {shop::items::*}
    add 750 to {shop::prices::*}
    
    add "Combo Multiplier" to {shop::items::*}
    add 600 to {shop::prices::*}
    
    # Add prestige items
    add "Prestige Token" to {shop::items::*}
    add 10000 to {shop::prices::*}

# Function to earn ClickCoins
every 1 tick:
    loop all players:
        set {_p} to loop-player
        set {_uuid} to {_p}'s uuid
        
        # Check for clicks
        if {player::%{_uuid}%::clicks} is set:
            set {_clicks} to {player::%{_uuid}%::clicks}
            
            # Calculate earnings
            set {_earnings} to {_clicks} * {@base_click_earnings}
            
            # Apply prestige bonus
            if {player::%{_uuid}%::prestige_level} is set:
                set {_prestige_bonus} to {player::%{_uuid}%::prestige_level} * {@prestige_bonus}
                add {_prestige_bonus} to {_earnings}
            
            # Add to ClickCoins
            add {_earnings} to {player::%{_uuid}%::clickcoins}
            
            # Reset clicks
            set {player::%{_uuid}%::clicks} to 0

# Function to handle race rewards
every race ends:
    loop all players:
        set {_p} to loop-player
        set {_uuid} to {_p}'s uuid
        
        # Check if player won
        if {player::%{_uuid}%::race_position} is 1:
            add {@race_win_bonus} to {player::%{_uuid}%::clickcoins}
            send "{@prefix} &aYou won %{@race_win_bonus}% %{currency_name}% for winning the race!" to {_p}
        
        # Check if track completed
        if {player::%{_uuid}%::track_completed} is true:
            add {@track_completion_bonus} to {player::%{_uuid}%::clickcoins}
            send "{@prefix} &aYou earned %{@track_completion_bonus}% %{currency_name}% for completing the track!" to {_p}

# Function to handle achievement rewards
on achievement unlocked:
    set {_p} to player
    set {_uuid} to {_p}'s uuid
    add {@achievement_bonus} to {player::%{_uuid}%::clickcoins}
    send "{@prefix} &aYou earned %{@achievement_bonus}% %{currency_name}% for unlocking an achievement!" to {_p}

# Shop commands
command /shop:
    trigger:
        open shop gui to player

command /buy <text>:
    permission: raceclicker.shop.buy
    trigger:
        set {_item} to arg-1
        set {_p} to player
        set {_uuid} to {_p}'s uuid
        
        # Find item in shop
        set {_index} to 0
        loop {shop::items::*}:
            if loop-value is {_item}:
                break
            add 1 to {_index}
        
        # Check if item exists
        if {_index} >= size of {shop::items::*}:
            send "{@prefix} &cItem not found in shop!" to {_p}
            return
        
        # Get price
        set {_price} to {shop::prices::%{_index}%}
        
        # Check if player can afford
        if {player::%{_uuid}%::clickcoins} < {_price}:
            send "{@prefix} &cYou don't have enough %{currency_name}%!" to {_p}
            return
            
        # Deduct price
        subtract {_price} from {player::%{_uuid}%::clickcoins}
        
        # Apply purchase
        applyPurchase({_p}, {_item})
        
        # Send confirmation
        send "{@prefix} &aPurchased %{_item}% for %{_price}% %{currency_name}%!" to {_p}

# Function to apply purchase
function applyPurchase(p: player, item: text):
    set {_uuid} to {_p}'s uuid
    
    switch {_item}:
        case "Speed Upgrade":
            add 1 to {player::%{_uuid}%::speed_level}
            set {player::%{_uuid}%::speed_multiplier} to 1.2 ^ {player::%{_uuid}%::speed_level}
            break
        
        case "Power Upgrade":
            add 1 to {player::%{_uuid}%::power_level}
            set {player::%{_uuid}%::power_multiplier} to 1.3 ^ {player::%{_uuid}%::power_level}
            break
        
        case "Combo Upgrade":
            add 1 to {player::%{_uuid}%::combo_level}
            set {player::%{_uuid}%::combo_multiplier} to 1.1 ^ {player::%{_uuid}%::combo_level}
            break
        
        case "Accuracy Upgrade":
            add 1 to {player::%{_uuid}%::accuracy_level}
            set {player::%{_uuid}%::accuracy_multiplier} to 1.15 ^ {player::%{_uuid}%::accuracy_level}
            break
        
        case "Speed Boost":
            set {player::%{_uuid}%::speed_boost} to true
            start speedBoostEffect({_p})
            break
        
        case "Power Potion":
            set {player::%{_uuid}%::power_boost} to true
            start powerBoostEffect({_p})
            break
        
        case "Combo Multiplier":
            set {player::%{_uuid}%::combo_boost} to true
            start comboBoostEffect({_p})
            break
        
        case "Prestige Token":
            add 1 to {player::%{_uuid}%::prestige_tokens}
            break

# Function to get player's ClickCoins
function getClickCoins(p: player) :: number:
    set {_uuid} to {_p}'s uuid
    return {player::%{_uuid}%::clickcoins} ? 0

# Function to format ClickCoins
function formatClickCoins(amount: number) :: text:
    set {_amount} to {_amount} rounded to 2 decimal places
    return "%{_amount}% %{currency_symbol}%"

# Function to refresh shop
every {@shop_refresh_time}:
    initializeShop()
    broadcast "{@prefix} &aShop has been refreshed!" to players with permission "raceclicker.shop"

# Command to check balance
command /balance:
    trigger:
        set {_coins} to getClickCoins(player)
        send "{@prefix} &6Your Balance: %{formatClickCoins(_coins)}%" to player
# File: market_system.sk
# Description: Player-to-player market system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Market settings
    market_refresh_time: 10 minutes
    market_fee: 0.1 # 10% market fee
    market_max_listings: 100
    market_max_duration: 24 hours
    
    # Listing types
    listing_types:
        - "Speed Upgrades"
        - "Power Upgrades"
        - "Combo Upgrades"
        - "Accuracy Upgrades"
        - "Boosts"
        - "Prestige Tokens"
        - "Custom Items"
    
    # Market permissions
    market_permissions:
        list: "raceclicker.market.list"
        buy: "raceclicker.market.buy"
        manage: "raceclicker.market.manage"

# Variables:
# {market::listings::*} = text (market listings)
# {market::prices::*} = number (listing prices)
# {market::sellers::*} = text (seller uuids)
# {market::types::*} = text (listing types)
# {market::expiration::*} = timestamp (listing expiration)
# {market::quantity::*} = number (item quantity)
# {player::%uuid%::market_listings::*} = text (player's listings)

# Function to initialize market system
on join:
    set {_p} to player
    set {_uuid} to {_p}'s uuid
    
    # Initialize player's market listings
    if not {player::%{_uuid}%::market_listings::*} is set:
        set {player::%{_uuid}%::market_listings::*} to []

# Function to create market listing
command /marketlist <text> <number> <number>:
    permission: raceclicker.market.list
    trigger:
        set {_uuid} to player's uuid
        set {_item} to arg-1
        set {_price} to arg-2
        set {_quantity} to arg-3
        
        # Check if item is valid
        if not {_item} is in {@listing_types}:
            send "{@prefix} &cInvalid item type! Valid types: %{@listing_types}%" to player
            return
            
        # Check if player has enough items
        if {_item} is "Prestige Tokens":
            if {player::%{_uuid}%::prestige_tokens} < {_quantity}:
                send "{@prefix} &cYou don't have enough Prestige Tokens!" to player
                return
        else:
            if not {player::%{_uuid}%::%{_item}%} is set:
                set {player::%{_uuid}%::%{_item}%} to 0
            if {player::%{_uuid}%::%{_item}%} < {_quantity}:
                send "{@prefix} &cYou don't have enough %{_item}%!" to player
                return
                
        # Check if market is full
        if size of {market::listings::*} >= {@market_max_listings}:
            send "{@prefix} &cMarket is full! Please wait for listings to expire." to player
            return
            
        # Create listing
        set {_listing_id} to size of {market::listings::*} + 1
        add {_item} to {market::listings::*}
        add {_price} to {market::prices::*}
        add {_uuid} to {market::sellers::*}
        add {_item} to {market::types::*}
        add now + {@market_max_duration} to {market::expiration::*}
        add {_quantity} to {market::quantity::*}
        add {_listing_id} to {player::%{_uuid}%::market_listings::*}
        
        # Take items from player
        if {_item} is "Prestige Tokens":
            subtract {_quantity} from {player::%{_uuid}%::prestige_tokens}
        else:
            subtract {_quantity} from {player::%{_uuid}%::%{_item}%}
            
        # Notify players
        broadcast "{@prefix} &6%{player}% listed %{_quantity}% %{_item}% for %{_price}% ClickCoins!" to players with permission "raceclicker.market.view"
        send "{@prefix} &aSuccessfully listed %{_quantity}% %{_item}% for %{_price}% ClickCoins!" to player

# Function to buy market listing
command /marketbuy <number>:
    permission: raceclicker.market.buy
    trigger:
        set {_uuid} to player's uuid
        set {_listing_id} to arg-1 - 1
        
        # Check if listing exists
        if {_listing_id} >= size of {market::listings::*}:
            send "{@prefix} &cInvalid listing ID!" to player
            return
            
        # Get listing info
        set {_item} to {market::listings::%{_listing_id}%}
        set {_price} to {market::prices::%{_listing_id}%}
        set {_seller} to {market::sellers::%{_listing_id}%}
        set {_quantity} to {market::quantity::%{_listing_id}%}
        
        # Check if listing is expired
        if now > {market::expiration::%{_listing_id}%}:
            send "{@prefix} &cThis listing has expired!" to player
            return
            
        # Check if player can afford
        if {player::%{_uuid}%::clickcoins} < {_price}:
            send "{@prefix} &cYou don't have enough ClickCoins!" to player
            return
            
        # Deduct price and apply market fee
        set {_fee} to {_price} * {@market_fee}
        set {_final_price} to {_price} - {_fee}
        subtract {_final_price} from {player::%{_uuid}%::clickcoins}
        add {_final_price} to {player::%{_seller}%::clickcoins}
        
        # Give items to buyer
        if {_item} is "Prestige Tokens":
            add {_quantity} to {player::%{_uuid}%::prestige_tokens}
        else:
            if not {player::%{_uuid}%::%{_item}%} is set:
                set {player::%{_uuid}%::%{_item}%} to 0
            add {_quantity} to {player::%{_uuid}%::%{_item}%}
            
        # Remove listing
        remove {_listing_id} from {market::listings::*}
        remove {_listing_id} from {market::prices::*}
        remove {_listing_id} from {market::sellers::*}
        remove {_listing_id} from {market::types::*}
        remove {_listing_id} from {market::expiration::*}
        remove {_listing_id} from {market::quantity::*}
        remove {_listing_id} from {player::%{_seller}%::market_listings::*}
        
        # Notify players
        broadcast "{@prefix} &6%{player}% bought %{_quantity}% %{_item}% for %{_price}% ClickCoins!" to players with permission "raceclicker.market.view"
        send "{@prefix} &aSuccessfully bought %{_quantity}% %{_item}% for %{_price}% ClickCoins!" to player

# Function to view market listings
command /marketview:
    permission: raceclicker.market.view
    trigger:
        set {_listings} to "&6Market Listings:\n"
        
        loop {market::listings::*}:
            set {_index} to loop-index - 1
            set {_item} to loop-value
            set {_price} to {market::prices::%{_index}%}
            set {_seller} to {market::sellers::%{_index}%}
            set {_quantity} to {market::quantity::%{_index}%}
            set {_seller_name} to player from uuid {_seller}
            append "&7%{_index}%. %{_item}% &8x%{_quantity}% &6- %{_price}% ClickCoins &8(Seller: %{_seller_name}%)\n" to {_listings}
            
        send "{@prefix} %{_listings}%" to player

# Function to cancel market listing
command /marketcancel <number>:
    permission: raceclicker.market.list
    trigger:
        set {_uuid} to player's uuid
        set {_listing_id} to arg-1 - 1
        
        # Check if listing exists
        if {_listing_id} >= size of {market::listings::*}:
            send "{@prefix} &cInvalid listing ID!" to player
            return
            
        # Check if player owns listing
        if {market::sellers::%{_listing_id}%} is not {_uuid}:
            send "{@prefix} &cYou don't own this listing!" to player
            return
            
        # Get listing info
        set {_item} to {market::listings::%{_listing_id}%}
        set {_quantity} to {market::quantity::%{_listing_id}%}
        
        # Give items back to player
        if {_item} is "Prestige Tokens":
            add {_quantity} to {player::%{_uuid}%::prestige_tokens}
        else:
            add {_quantity} to {player::%{_uuid}%::%{_item}%}
            
        # Remove listing
        remove {_item} from {market::listings::*}
        remove {market::prices::%{_listing_id}%}
        remove {_uuid} from {market::sellers::*}
        remove {market::types::%{_listing_id}%}
        remove {market::expiration::%{_listing_id}%}
        remove {_quantity} from {market::quantity::*}
        remove {_listing_id} from {player::%{_uuid}%::market_listings::*}
        
        send "{@prefix} &aSuccessfully cancelled listing! Items returned to inventory." to player

# Function to refresh market
every {@market_refresh_time}:
    set {_expired_listings::*} to []
    
    # Identify expired listings
    loop {market::listings::*}:
        set {_index} to loop-index - 1
        if now > {market::expiration::%{_index}%}:
            add {_index} to {_expired_listings::*}
    
    # Remove expired listings and return items
    loop {_expired_listings::*}:
        set {_index} to loop-value
        set {_seller} to {market::sellers::%{_index}%}
        set {_item} to {market::listings::%{_index}%}
        set {_quantity} to {market::quantity::%{_index}%}
        
        # Return items to seller
        if {_item} is "Prestige Tokens":
            add {_quantity} to {player::%{_seller}%::prestige_tokens}
        else:
            add {_quantity} to {player::%{_seller}%::%{_item}%}
        
        # Remove listing
        remove {_index} from {market::listings::*}
        remove {_index} from {market::prices::*}
        remove {_index} from {market::sellers::*}
        remove {_index} from {market::types::*}
        remove {_index} from {market::expiration::*}
        remove {_index} from {market::quantity::*}
        
    # Notify players
    if size of {_expired_listings::*} > 0:
        broadcast "{@prefix} &aMarket has been refreshed! %{size of {_expired_listings::*}}% expired listings removed." to players with permission "raceclicker.market.view"
            
    broadcast "{@prefix} &aMarket has been refreshed! Expired listings removed." to players with permission "raceclicker.market.view"

# Function to collect market fees
every 24 hours:
    # Collect market fees
    set {_total_fees} to 0
    loop all players:
        set {_uuid} to loop-player's uuid
        if {player::%{_uuid}%::market_listings::*} is set:
            loop {player::%{_uuid}%::market_listings::*}:
                set {_index} to loop-value - 1
                set {_price} to {market::prices::%{_index}%}
                set {_fee} to {_price} * {@market_fee}
                add {_fee} to {_total_fees}
    
    if {_total_fees} > 0:
        add {_total_fees} to {market::total_fees}
        broadcast "{@prefix} &6Market fees collected: %{_total_fees}% ClickCoins!" to players with permission "raceclicker.market.admin"
# File: dynamic_camera_effects.sk
# Path: race-clicker/effects/dynamic_camera_effects.sk
# Description: Manages dynamic camera effects during races.

options:
    prefix: &6&lRaceClicker &8» &c&lCameraFX &8»

# --- Phase 2: Enhance Visual Systems ---
# Improve 3rd Person Integration
# - Add race-specific camera angles
#   - Dynamic camera positioning during races
#   - Spectator mode camera switching
#   - Cinematic finish line cameras

# Variables:
# {player::%player%::camera_effect_active::*} - Stores active camera effects for a player

# --- Core Functions ---

# Function to apply a screen shake effect
function applyScreenShake(p: player, intensity: number, duration: number):
    # This is a conceptual function. True screen shake is hard in Skript without client mods.
    # We can simulate it with rapid, small camera movements or FOV pulses.
    # Example: Rapidly change player's pitch/yaw slightly or FOV
    send "%{_p}%" title "" with subtitle "<shake intensity=%{_intensity}%, duration=%{_duration}%>" for {_duration} ticks
    # Actual implementation would involve a loop changing camera view or potion effects like nausea (subtle)
    # For now, this is a placeholder for a more complex effect.
    # Example using potion effect (less ideal for pure camera shake):
    # apply nausea of tier ({_intensity} - 1) to {_p} for {_duration} ticks
    send debug "%{options.prefix}% Applied screen shake to %{_p}% (Intensity: %{_intensity}%, Duration: %{_duration}%s)"

# Function to change Field of View (FOV)
function setPlayerFOV(p: player, fov_modifier: number, duration: number):
    # Skript cannot directly set FOV. This is usually done with potion effects (speed) or client-side mods.
    # We can simulate a narrow/wide FOV feel with speed/slowness or by adjusting camera distance if possible.
    # For actual FOV, this would require external plugin integration or specific client features.
    if {_fov_modifier} > 0:
        apply speed of tier ({_fov_modifier} - 1) to {_p} for {_duration} ticks # Wider FOV feel
    else if {_fov_modifier} < 0:
        apply slowness of tier (abs({_fov_modifier}) - 1) to {_p} for {_duration} ticks # Narrower FOV feel
    send debug "%{options.prefix}% Set FOV modifier for %{_p}% (Modifier: %{_fov_modifier}%, Duration: %{_duration}%s)"
    # Store effect to remove it later if needed
    set {player::%{_p}%::camera_effect_active::fov_duration} to game time
    set {player::%{_p}%::camera_effect_active::fov_end_time} to game time + {_duration} seconds

# Function to clear active FOV effects (e.g., restore normal FOV)
function clearPlayerFOV(p: player):
    remove speed from {_p}
    remove slowness from {_p}
    delete {player::%{_p}%::camera_effect_active::fov_duration}
    delete {player::%{_p}%::camera_effect_active::fov_end_time}
    send debug "%{options.prefix}% Cleared FOV effects for %{_p}%"

# Function to apply a cinematic effect (e.g., letterbox, slow motion - conceptual)
function applyCinematicEffect(p: player, effect_type: text, duration: number):
    # True cinematic effects are complex. Letterbox might be simulated with black GUI elements.
    # Slow motion is typically server-wide or requires advanced manipulation.
    send debug "%{options.prefix}% Applied cinematic effect '%{_effect_type}%' to %{_p}% for %{_duration}%s (Conceptual)"
    if {_effect_type} is "letterbox":
        # Placeholder: send action bar messages or use GUI tricks
        send action bar "<SOLID_BLACK_BAR_TOP>" to {_p}
        send action bar "<SOLID_BLACK_BAR_BOTTOM>" to {_p} # These would need to be actual GUI elements
    # Store effect
    set {player::%{_p}%::camera_effect_active::%{_effect_type}%_end_time} to game time + {_duration} seconds

# Function to clear a specific cinematic effect
function clearCinematicEffect(p: player, effect_type: text):
    delete {player::%{_p}%::camera_effect_active::%{_effect_type}%_end_time}
    if {_effect_type} is "letterbox":
        # Placeholder: clear action bar or remove GUI elements
        send action bar "" to {_p}
    send debug "%{options.prefix}% Cleared cinematic effect '%{_effect_type}%' for %{_p}%"

# --- Event Triggers (Examples - to be called from racing.sk or other scripts) ---

# Example: Trigger when hitting a boost pad
function onBoostPadHit(p: player):
    execute function setPlayerFOV({_p}, 1, 2) # Slight FOV increase for 2 seconds
    # Potentially a very minor, quick screen shake
    # execute function applyScreenShake({_p}, 1, 0.5)

# Example: Trigger when hitting an obstacle
function onObstacleHit(p: player):
    execute function applyScreenShake({_p}, 2, 1) # Moderate shake for 1 second
    execute function setPlayerFOV({_p}, -1, 1) # Slight FOV decrease for 1 second

# Example: Trigger when crossing finish line (especially for winner)
function onRaceFinish(p: player, position: integer):
    if {_position} is 1:
        execute function applyCinematicEffect({_p}, "letterbox", 5) # Letterbox for 5s
        # Potentially a slow-motion effect (conceptual)
        send debug "%{options.prefix}% Winner %{_p}% crossed finish line! Applying cinematic effects."
    else:
        # Minor effect for other finishers
        send debug "%{options.prefix}% Player %{_p}% finished in position %{_position}%."

# Periodically check and clear expired effects
every 1 second:
    loop all players:
        if {player::%loop-player%::camera_effect_active::fov_end_time} is set:
            if game time is after {player::%loop-player%::camera_effect_active::fov_end_time}:
                execute function clearPlayerFOV(loop-player)
        
        # Loop through other potential cinematic effects stored with _end_time
        # Example for letterbox, assuming it was stored similarly
        if {player::%loop-player%::camera_effect_active::letterbox_end_time} is set:
            if game time is after {player::%loop-player%::camera_effect_active::letterbox_end_time}:
                execute function clearCinematicEffect(loop-player, "letterbox")

# --- Helper Functions (if any) ---

# --- Commands (for testing) ---
command /rccamerafx <player> <effect> [<arg1>] [<arg2>]:
    permission: raceclicker.admin
    trigger:
        set {_p} to arg-1
        if {_p} is not set:
            send "%{options.prefix}% &cPlayer not found or offline."
            stop

        if arg-2 is "shake":
            set {_intensity} to arg-3 parsed as number ? 1
            set {_duration} to arg-4 parsed as number ? 1
            execute function applyScreenShake({_p}, {_intensity}, {_duration})
            send "%{options.prefix}% Applied screen shake to %{_p}%."
        else if arg-2 is "fov":
            set {_modifier} to arg-3 parsed as number ? 1
            set {_duration} to arg-4 parsed as number ? 1
            execute function setPlayerFOV({_p}, {_modifier}, {_duration})
            send "%{options.prefix}% Set FOV for %{_p}%."
        else if arg-2 is "clearfov":
            execute function clearPlayerFOV({_p})
            send "%{options.prefix}% Cleared FOV for %{_p}%."
        else if arg-2 is "cinematic":
            set {_type} to arg-3 ? "letterbox"
            set {_duration} to arg-4 parsed as number ? 5
            execute function applyCinematicEffect({_p}, {_type}, {_duration})
            send "%{options.prefix}% Applied cinematic '%{_type}%' to %{_p}%."
        else if arg-2 is "clearcinematic":
            set {_type} to arg-3 ? "letterbox"
            execute function clearCinematicEffect({_p}, {_type})
            send "%{options.prefix}% Cleared cinematic '%{_type}%' for %{_p}%."
        else:
            send "%{options.prefix}% &cUnknown effect. Usage: /rccamerafx <player> <shake|fov|clearfov|cinematic|clearcinematic> [args]"
# File: race_progress_effects.sk
# Description: Visual effects for race progress and position indicators

options:
    prefix: &6&lRaceClicker &8»
    progress_particle_interval: 5 ticks # How often to update progress particles
    position_indicator_interval: 10 ticks # How often to update position indicators
    position_indicator_height: 3 # Height above citizen for position indicator
    position_indicator_duration: 20 ticks # Duration of position indicator display
    
# Variables:
# {player::%player's uuid%::last_progress_particle_update} - Timestamp of last particle update
# {player::%player's uuid%::last_position_indicator_update} - Timestamp of last position update

# Function to create position indicator above citizen
function createPositionIndicator(p: player, position: number):
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::race_citizen_entity_id} is set:
        set {_citizen} to entity from uuid {player::%{_uuid}%::race_citizen_entity_id}
        if {_citizen} is set:
            set {_loc} to location of {_citizen}
            set {_loc} to {_loc} add vector(0, {@position_indicator_height}, 0)
            
            # Create position number above citizen
            spawn 10 of particle "text" with text "&e#%{_position}%" at {_loc}
            
            # Add small particles around the number for visual effect
            loop 5 times:
                set {_offset} to vector(random between -0.5 and 0.5, 0, random between -0.5 and 0.5)
                spawn particle "crit" at {_loc} add {_offset}

# Function to create progress trail particles
function createProgressTrail(p: player):
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::race_citizen_entity_id} is set:
        set {_citizen} to entity from uuid {player::%{_uuid}%::race_citizen_entity_id}
        if {_citizen} is set:
            set {_loc} to location of {_citizen}
            
            # Create trail particles showing progress
            set {_progress} to {player::%{_uuid}%::race_progress_current_race}
            set {_color} to "white"
            
            # Change color based on progress
            if {_progress} < 100:
                set {_color} to "red"
            else if {_progress} < 200:
                set {_color} to "orange"
            else if {_progress} < 300:
                set {_color} to "yellow"
            else if {_progress} < 400:
                set {_color} to "green"
            else:
                set {_color} to "blue"
            
            # Spawn colored particles
            spawn 5 of particle "{_color}_dust" at {_loc} offset by vector(0.2, 0.2, 0.2)

# Main loop for progress effects
every {@progress_particle_interval}:
    loop all players:
        if {player::%loop-player's uuid%::in_race} is true:
            set {_p} to loop-player
            
            # Update progress trail
            createProgressTrail({_p})
            
            # Update position indicator if enough time has passed
            if now - {player::%{_p}'s uuid%::last_position_indicator_update} > {@position_indicator_interval}:
                set {player::%{_p}'s uuid%::last_position_indicator_update} to now
                
                # Calculate position (1 for first, etc.)
                set {_position} to 1
                loop {race::finished_players::*}:
                    if loop-value-1 is not {_p}:
                        add 1 to {_position}
                
                createPositionIndicator({_p}, {_position})

# Function to create finish line celebration effects
function createFinishLineEffects(p: player):
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::race_citizen_entity_id} is set:
        set {_citizen} to entity from uuid {player::%{_uuid}%::race_citizen_entity_id}
        if {_citizen} is set:
            set {_loc} to location of {_citizen}
            
            # Create fireworks
            spawn particle "fireworks_spark" at {_loc} offset by vector(1, 1, 1)
            
            # Create confetti
            loop 20 times:
                set {_angle} to loop-number * (360 / 20)
                set {_offset} to vector(sin({_angle}), 0.5, cos({_angle})) multiply 2
                spawn particle "happy_villager" at {_loc} add {_offset}

# Function to create obstacle effects
function createObstacleEffect(p: player, type: text):
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::race_citizen_entity_id} is set:
        set {_citizen} to entity from uuid {player::%{_uuid}%::race_citizen_entity_id}
        if {_citizen} is set:
            set {_loc} to location of {_citizen}
            
            if {_type} is "slow_down":
                # Create slow motion visual
                spawn particle "slime" at {_loc} offset by vector(0.5, 0.5, 0.5)
                
            else if {_type} is "speed_boost":
                # Create speed boost visual
                spawn particle "speed" at {_loc} offset by vector(0.5, 0.5, 0.5)
# File: event_system.sk
# Description: Event system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Event settings
    event_start_time: 15 minutes # Time before event starts
    event_duration: 30 minutes # Duration of event
    event_cooldown: 1 hour # Cooldown between events
    
    # Event types
    event_types:
        - "Double Clicks"
        - "Speed Boost"
        - "Power Surge"
        - "Combo Multiplier"
        - "Achievement Bonus"
        - "Track Bonus"
        - "Race Bonus"
        - "Prestige Bonus"
        - "ClickCoin Bonus"
    
    # Event rewards
    event_rewards:
        clicks_multiplier: 2.0
        speed_multiplier: 1.5
        power_multiplier: 1.5
        combo_multiplier: 1.5
        achievement_multiplier: 2.0
        track_multiplier: 1.2
        race_multiplier: 1.2
        prestige_multiplier: 1.5
        clickcoins_multiplier: 2.0
    
    # Event chances
    event_chances:
        double_clicks: 20
        speed_boost: 15
        power_surge: 15
        combo_multiplier: 15
        achievement_bonus: 10
        track_bonus: 10
        race_bonus: 10
        prestige_bonus: 5
        clickcoin_bonus: 5

# Variables:
# {event::current_event} = text (current event type)
# {event::start_time} = timestamp (event start time)
# {event::end_time} = timestamp (event end time)
# {event::last_event} = timestamp (last event time)
# {player::%uuid%::event_points} = number (player's event points)

# Function to start event
every {@event_cooldown}:
    if now - {event::last_event} >= {@event_cooldown}:
        startEvent()

# Function to start event
function startEvent():
    # Choose random event
    set {_event} to random element of {@event_types::*}
    set {_chance} to random number between 1 and 100
    
    # Check event chance
    switch {_event}:
        case "Double Clicks":
            if {_chance} <= {@event_chances::double_clicks}:
                set {event::current_event} to "Double Clicks"
            break
        case "Speed Boost":
            if {_chance} <= {@event_chances::speed_boost}:
                set {event::current_event} to "Speed Boost"
            break
        case "Power Surge":
            if {_chance} <= {@event_chances::power_surge}:
                set {event::current_event} to "Power Surge"
            break
        case "Combo Multiplier":
            if {_chance} <= {@event_chances::combo_multiplier}:
                set {event::current_event} to "Combo Multiplier"
            break
        case "Achievement Bonus":
            if {_chance} <= {@event_chances::achievement_bonus}:
                set {event::current_event} to "Achievement Bonus"
            break
        case "Track Bonus":
            if {_chance} <= {@event_chances::track_bonus}:
                set {event::current_event} to "Track Bonus"
            break
        case "Race Bonus":
            if {_chance} <= {@event_chances::race_bonus}:
                set {event::current_event} to "Race Bonus"
            break
        case "Prestige Bonus":
            if {_chance} <= {@event_chances::prestige_bonus}:
                set {event::current_event} to "Prestige Bonus"
            break
        case "ClickCoin Bonus":
            if {_chance} <= {@event_chances::clickcoin_bonus}:
                set {event::current_event} to "ClickCoin Bonus"
            break

    # If no event selected, try again
    if {event::current_event} is not set:
        startEvent()
        return

    # Set event times
    set {event::start_time} to now + {@event_start_time}
    set {event::end_time} to {event::start_time} + {@event_duration}
    set {event::last_event} to now

    # Announce event
    broadcast "{@prefix} &6Event Alert: %{event::current_event}% event starting in %{@event_start_time}%!" to all players
    broadcast "{@prefix} &6Duration: %{@event_duration}%" to all players
    broadcast "{@prefix} &6Rewards: %{event::current_event}% bonus!" to all players

# Function to apply event bonus
every 1 tick:
    if {event::current_event} is set:
        if now >= {event::start_time} and now <= {event::end_time}:
            loop all players:
                set {_p} to loop-player
                set {_uuid} to {_p}'s uuid
                
                # Apply event bonus
                switch {event::current_event}:
                    case "Double Clicks":
                        set {player::%{_uuid}%::click_multiplier} to {@event_rewards::clicks_multiplier}
                        break
                    case "Speed Boost":
                        set {player::%{_uuid}%::speed_multiplier} to {@event_rewards::speed_multiplier}
                        break
                    case "Power Surge":
                        set {player::%{_uuid}%::power_multiplier} to {@event_rewards::power_multiplier}
                        break
                    case "Combo Multiplier":
                        set {player::%{_uuid}%::combo_multiplier} to {@event_rewards::combo_multiplier}
                        break
                    case "Achievement Bonus":
                        set {player::%{_uuid}%::achievement_multiplier} to {@event_rewards::achievement_multiplier}
                        break
                    case "Track Bonus":
                        set {player::%{_uuid}%::track_multiplier} to {@event_rewards::track_multiplier}
                        break
                    case "Race Bonus":
                        set {player::%{_uuid}%::race_multiplier} to {@event_rewards::race_multiplier}
                        break
                    case "Prestige Bonus":
                        set {player::%{_uuid}%::prestige_multiplier} to {@event_rewards::prestige_multiplier}
                        break
                    case "ClickCoin Bonus":
                        set {player::%{_uuid}%::clickcoins_multiplier} to {@event_rewards::clickcoins_multiplier}
                        break

# Function to end event
function endEvent():
    if {event::current_event} is set:
        broadcast "{@prefix} &6Event Alert: %{event::current_event}% event has ended!" to all players
        
        # Reset all multipliers
        loop all players:
            set {_uuid} to loop-player's uuid
            set {player::%{_uuid}%::click_multiplier} to 1
            set {player::%{_uuid}%::speed_multiplier} to 1
            set {player::%{_uuid}%::power_multiplier} to 1
            set {player::%{_uuid}%::combo_multiplier} to 1
            set {player::%{_uuid}%::achievement_multiplier} to 1
            set {player::%{_uuid}%::track_multiplier} to 1
            set {player::%{_uuid}%::race_multiplier} to 1
            set {player::%{_uuid}%::prestige_multiplier} to 1
            set {player::%{_uuid}%::clickcoins_multiplier} to 1
        
        # Reset event
        delete {event::current_event}
        delete {event::start_time}
        delete {event::end_time}

# Function to get event status
function getEventStatus() :: text:
    if {event::current_event} is not set:
        return "&cNo event active!"
    
    set {_time_left} to {event::end_time} - now
    set {_status} to "&6Event: %{event::current_event}%\n"
    append "&eTime Left: &a%{_time_left}%\n" to {_status}
    append "&eRewards: &a%{event::current_event}% bonus" to {_status}
    return {_status}

# Command to view event status
command /event:
    trigger:
        send "{@prefix} %{getEventStatus()}%" to player

# Function to give event points
function giveEventPoints(p: player, amount: number):
    set {_uuid} to {_p}'s uuid
    add {_amount} to {player::%{_uuid}%::event_points}
    
    # Check for event achievements
    checkEventAchievements({_p})

# Function to check event achievements
function checkEventAchievements(p: player):
    set {_uuid} to {_p}'s uuid
    set {_points} to {player::%{_uuid}%::event_points} ? 0
    
    # Event points achievements
    loop [1000, 5000, 10000, 50000, 100000]:
        if {_points} >= loop-value:
            if {player::%{_uuid}%::achievements::event_points_%{loop-value}%} is not true:
                unlockAchievement({_p}, "Event Master %{loop-value}%")

# Function to unlock achievement
function unlockAchievement(p: player, achievement: text):
    set {_uuid} to {_p}'s uuid
    set {player::%{_uuid}%::achievements::%{achievement.lower}%} to true
    
    # Give achievement reward
    giveAchievementReward({_p}, achievement)
    
    # Send achievement message
    send "{@prefix} &aUnlocked Achievement: %{achievement}%" to {_p}
    broadcast "{@prefix} &6%{_p}% unlocked achievement: %{achievement}%" to players with permission "raceclicker.achievements"

# Function to give achievement reward
function giveAchievementReward(p: player, achievement: text):
    set {_uuid} to {_p}'s uuid
    
    # Base reward
    set {_reward} to 100
    
    # Special rewards
    switch achievement:
        case "Event Master 100000":
            set {_reward} to 500
            break
        case "Event Master 50000":
            set {_reward} to 300
            break
        case "Event Master 10000":
            set {_reward} to 200
            break
    
    # Add reward
    add {_reward} to {player::%{_uuid}%::clickcoins}
    send "{@prefix} &aEarned %{@achievement_bonus}% ClickCoins for achievement!" to {_p}

# Event-specific effects
on click:
    if {event::current_event} is "Double Clicks":
        set {_p} to player
        set {_uuid} to {_p}'s uuid
        
        # Double click effect
        set {_click_power} to {player::%{_uuid}%::click_power} * {@event_rewards::clicks_multiplier}
        set {player::%{_uuid}%::click_power} to {_click_power}
        
        # Particle effect
        spawn particle "minecraft:happy_villager" at {_p}'s location

on race finish:
    if {event::current_event} is "Race Bonus":
        set {_p} to player
        set {_uuid} to {_p}'s uuid
        
        # Race bonus
        add {@event_rewards::race_multiplier} to {player::%{_uuid}%::races_won}
        
        # Give event points
        giveEventPoints({_p}, 100)

on track completion:
    if {event::current_event} is "Track Bonus":
        set {_p} to player
        set {_uuid} to {_p}'s uuid
        
        # Track bonus
        add {@event_rewards::track_multiplier} to {player::%{_uuid}%::tracks_completed}
        
        # Give event points
        giveEventPoints({_p}, 50)

on achievement unlock:
    if {event::current_event} is "Achievement Bonus":
        set {_p} to player
        set {_uuid} to {_p}'s uuid
        
        # Achievement bonus
        set {player::%{_uuid}%::achievement_multiplier} to {@event_rewards::achievement_multiplier}
        
        # Give event points
        giveEventPoints({_p}, 25)

# Event leaderboard
every 5 minutes:
    if {event::current_event} is set:
        set {_leaderboard} to []
        
        # Get top players
        loop all players sorted by {player::%{_uuid}%::event_points} descending:
            if size of {_leaderboard} >= 5:
                break
            set {_p} to loop-value
            set {_uuid} to {_p}'s uuid
            add "&e%{_p}%: &a%{player::%{_uuid}%::event_points}%" to {_leaderboard}
        
        # Broadcast leaderboard
        broadcast "{@prefix} &6Top Event Players:" to all players
        loop {_leaderboard}:
            broadcast "&7- %{loop-value}%" to all players
# File: achievements.sk
# Path: race-clicker/features/achievements.sk
# Description: Achievement system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    achievementGUIPages: true # Enable pagination for achievements GUI
    achievementsPerPage: 28 # Max 4*7 items per page (28) for a 6-row GUI with borders

# --- Achievement Definitions ---
# Structure: {achievement::ID::name}, {achievement::ID::description}, {achievement::ID::icon} (item type string)
#            {achievement::ID::reward::message}, {achievement::ID::reward::command}, {achievement::ID::reward::clicks}, {achievement::ID::reward::prestige_points}
#            {achievement::ID::condition::type} (e.g., "clicks", "speed_level", "races_won", "prestige_level")
#            {achievement::ID::condition::value} (target value for the condition type)

variables:
    {achievements_list::*} # List of all achievement IDs, populated on load
    {player::%uuid%::achievements::%id%} = boolean (unlocked status)
    {player::%uuid%::achievements_gui_page} = integer

on load:
    # Clear and define achievements
    delete {achievements_list::*}

    # Clicks Achievements
    defineAchievement("first_click", "&aFirst Click!", "&7Make your very first click.", "minecraft:lever", "clicks", 1, "&eYou've started your journey!", null, 10, null)
    defineAchievement("click_novice", "&aClick Novice", "&7Reach 100 total clicks.", "minecraft:stone_pickaxe", "clicks", 100, null, null, 50, null)
    defineAchievement("click_adept", "&aClick Adept", "&7Reach 1,000 total clicks.", "minecraft:iron_pickaxe", "clicks", 1000, "&eGetting the hang of it!", null, 250, null)
    defineAchievement("click_master", "&6Click Master", "&7Reach 10,000 total clicks.", "minecraft:diamond_pickaxe", "clicks", 10000, "&eMaster of Clicks!", null, 1000, 1)

    # Upgrade Achievements
    defineAchievement("speed_demon_1", "&bSpeed Demon I", "&7Upgrade your speed to level 5.", "minecraft:feather", "speed_level", 5, "&eFaster clicks!", null, null, null)
    defineAchievement("auto_helper_1", "&bAuto Helper I", "&7Upgrade auto-clicker to level 3.", "minecraft:clock", "autoclicker_level", 3, "&ePassive income!", null, null, null)

    # Racing Achievements
    defineAchievement("first_race", "&eFirst Race", "&7Participate in your first race.", "minecraft:leather_boots", "races_participated", 1, "&eWelcome to the track!", null, null, null)
    defineAchievement("first_win", "&6First Victory!", "&7Win your first race.", "minecraft:gold_ingot", "races_won", 1, "&eChampion in the making!", "rcgivepoints %player% 5", 200, 1) # Example: rcgivepoints is a placeholder for a custom point system

    # Prestige Achievements
    defineAchievement("first_prestige", "&dFirst Prestige", "&7Achieve your first prestige.", "minecraft:nether_star", "prestige_level", 1, "&eA new beginning!", null, null, 5)

    # Track-Specific Achievements
    defineAchievement("track_master_1", "&6Track Master I", "&7Win on 3 different tracks.", "minecraft:map", "tracks_won", 3, "&eTrack Conqueror!", null, 500, 2)
    defineAchievement("track_speedster", "&bTrack Speedster", "&7Complete a track in under 10 seconds.", "minecraft:clock", "track_time", 10, "&eLightning Fast!", null, 1000, 3)
    defineAchievement("track_perfectionist", "&aTrack Perfectionist", "&7Complete a track with max combo throughout.", "minecraft:ender_eye", "max_combo", 100, "&ePerfect Timing!", null, 1500, 4)
    
    # Combo Achievements
    defineAchievement("combo_streak", "&6Combo Streak", "&7Maintain a combo of 50 clicks.", "minecraft:ender_pearl", "combo", 50, "&ePerfect Rhythm!", null, 750, 2)
    defineAchievement("combo_master", "&6Combo Master", "&7Maintain a combo of 100 clicks.", "minecraft:dragon_head", "combo", 100, "&eMaster of Timing!", null, 2000, 5)
    
    # Multiplayer Achievements
    defineAchievement("race_champion", "&6Race Champion", "&7Win 10 races against others.", "minecraft:trophy", "multiplayer_wins", 10, "&eRace Dominator!", null, 3000, 6)
    defineAchievement("race_legend", "&6Race Legend", "&7Win 50 races against others.", "minecraft:dragon_breath", "multiplayer_wins", 50, "&eRace Legend!", null, 5000, 10)
    
    # Special Achievements
    defineAchievement("track_perfection", "&6Track Perfection", "&7Complete every track at least once.", "minecraft:emerald_block", "all_tracks", 1, "&eTrack Master!", null, 2500, 8)
    defineAchievement("speed_record", "&6Speed Record", "&7Set a new track record.", "minecraft:clock", "track_record", 1, "&eSpeed Demon!", null, 1500, 4)
    defineAchievement("combo_record", "&6Combo Record", "&7Set a new combo record.", "minecraft:ender_pearl", "combo_record", 1, "&eCombo King!", null, 2000, 5)
    
    # TODO: Add more achievements for different aspects: specific track wins, high combo, etc.
    if {rc.debug_mode} is true: # Assuming global debug_mode is {rc.debug_mode} from race_clicker.sk
        broadcast "&7[Debug] Achievements loaded: %size of {achievements_list::*}% achievements defined."

function defineAchievement(id: text, name: text, desc: text, icon: text, condType: text, condVal: number, rwdMsg: text, rwdCmd: text, rwdClicks: number, rwdPrestige: number):
    add {_id} to {achievements_list::*}
    set {achievement::%{_id}%::name} to {_name}
    set {achievement::%{_id}%::description} to {_desc}
    set {achievement::%{_id}%::icon} to {_icon}
    set {achievement::%{_id}%::condition::type} to {_condType}
    set {achievement::%{_id}%::condition::value} to {_condVal}
    if {_rwdMsg} is set:
        set {achievement::%{_id}%::reward::message} to {_rwdMsg}
    if {_rwdCmd} is set:
        set {achievement::%{_id}%::reward::command} to {_rwdCmd}
    if {_rwdClicks} is set:
        set {achievement::%{_id}%::reward::clicks} to {_rwdClicks}
    if {_rwdPrestige} is set:
        set {achievement::%{_id}%::reward::prestige_points} to {_rwdPrestige}

# --- Achievement Detection Logic ---
function checkAchievements(p: player):
    set {_uuid} to {_p}'s uuid
    loop {achievements_list::*}:
        set {_id} to loop-value
        if {player::%{_uuid}%::achievements::%{_id}%} is not set: # Only check if not already unlocked
            set {_cond_type} to {achievement::%{_id}%::condition::type}
            set {_cond_val} to {achievement::%{_id}%::condition::value}
            set {_player_val} to 0
            
            if {_cond_type} is "clicks":
                set {_player_val} to {player::%{_uuid}%::clicks} ? 0
            else if {_cond_type} is "speed_level":
                set {_player_val} to {player::%{_uuid}%::speed_level} ? 0
            else if {_cond_type} is "autoclicker_level":
                set {_player_val} to {player::%{_uuid}%::autoclicker_level} ? 0
            else if {_cond_type} is "races_won":
                set {_player_val} to {player::%{_uuid}%::races_won} ? 0
            else if {_cond_type} is "races_participated":
                set {_player_val} to {player::%{_uuid}%::total_races_participated} ? 0
            else if {_cond_type} is "prestige_level":
                set {_player_val} to {player::%{_uuid}%::prestige_level} ? 0
            else if {_cond_type} is "track_wins":
                set {_player_val} to {player::%{_uuid}%::track_wins} ? 0
            else if {_cond_type} is "track_time":
                set {_player_val} to {player::%{_uuid}%::track_time} ? 0
            else if {_cond_type} is "max_combo":
                set {_player_val} to {player::%{_uuid}%::max_combo} ? 0
            else if {_cond_type} is "multiplayer_wins":
                set {_player_val} to {player::%{_uuid}%::multiplayer_wins} ? 0
            else if {_cond_type} is "all_tracks":
                set {_player_val} to {player::%{_uuid}%::completed_tracks} ? 0
            else if {_cond_type} is "track_record":
                set {_player_val} to {player::%{_uuid}%::track_records} ? 0
            else if {_cond_type} is "combo_record":
                set {_player_val} to {player::%{_uuid}%::combo_records} ? 0
          
            if {_player_val} >= {_cond_val}:
                tryUnlockAchievement({_p}, {_id})

# Function to attempt unlocking an achievement and give rewards
function tryUnlockAchievement(p: player, id: text):
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::achievements::%{_id}%} is not set:
        set {player::%{_uuid}%::achievements::%{_id}%} to true
        set {_ach_name} to {achievement::%{_id}%::name}
        send title "&6Achievement Unlocked!" to {_p} with subtitle "&e%{_ach_name}%" for 3 seconds
        send "{@prefix} &aAchievement Unlocked: %{_ach_name}% &7- %{achievement::%{_id}%::description}%" to {_p}
        play sound "minecraft:ui.toast.challenge_complete" to {_p} with volume 1 pitch 1.2

        # Give rewards
        if {achievement::%{_id}%::reward::message} is set:
            send "{achievement::%{_id}%::reward::message}" to {_p}
        if {achievement::%{_id}%::reward::command} is set:
            execute console command "{achievement::%{_id}%::reward::command}" with arguments {_p}
        if {achievement::%{_id}%::reward::clicks} is set:
            add {achievement::%{_id}%::reward::clicks} to {player::%{_uuid}%::clicks}
        if {achievement::%{_id}%::reward::prestige_points} is set:
            set {_reward_prestige} to {achievement::%{_id}%::reward::prestige_points}
            add {_reward_prestige} to {player::%{_uuid}%::prestige_points}
            send "{@prefix} &dYou received %{_reward_prestige}% bonus prestige points!" to {_p}
            
        # Create achievement particles
        set {_loc} to location of {_p} add vector(0, 1, 0)
        loop 20 times:
            set {_angle} to loop-number * (360 / 20)
            set {_offset} to vector(sin({_angle}), 0, cos({_angle})) multiply 0.5
            spawn particle "happy_villager" at {_loc} add {_offset}
        # TODO: Add other reward types: exclusive upgrade discounts, special particle effects, unique citizen skins/accessories

# --- Visual Achievement Display (GUI) ---
command /achievements [<integer>]:
    aliases: /ach, /rcachievements
    trigger:
        if arg-1 is set:
            openAchievementsGUI(player, arg-1)
        else:
            openAchievementsGUI(player, 1)

function openAchievementsGUI(p: player, page: integer):
    set {_uuid} to {_p}'s uuid
    set {player::%{_uuid}%::achievements_gui_page} to {_page}
    create a gui with virtual chest inventory with 6 rows named "&8&nAchievements (Page %{_page}%)":
        set {_total_achievements} to size of {achievements_list::*}
        set {_totalPages} to ceil({_total_achievements} / {@achievementsPerPage})
        if {_totalPages} = 0:
            set {_totalPages} to 1 # Ensure totalPages is at least 1 to avoid division by zero or weird behavior
        if {_page} > {_totalPages}:
            set {_page} to {_totalPages}
        if {_page} < 1:
            set {_page} to 1
            
        # Check if achievements list is empty
        if size of {achievements_list::*} = 0:
            make gui slot 13 with red stained glass pane named "&cNo Achievements Available"
            make gui slot 45 with gray stained glass pane named " "
            make gui slot 49 with book named "&7Page %{_page}% of %{_totalPages}%"
            open last gui to {_p}
            return

        set {_start_index} to ({_page} - 1) * {@achievementsPerPage}
        set {_end_index} to {_start_index} + {@achievementsPerPage} - 1
        if {_end_index} >= {_total_achievements}:
            set {_end_index} to {_total_achievements} - 1

        set {_slot_index} to 0
        # Define the slots for achievements (center 4x7 area)
        set {_achievement_slots::*} to (10, 11, 12, 13, 14, 15, 16, 19, 20, 21, 22, 23, 24, 25, 28, 29, 30, 31, 32, 33, 34, 37, 38, 39, 40, 41, 42, 43)

        loop {_achievement_slots::*}:
            set {_gui_item_slot} to loop-value
            set {_current_ach_index} to {_start_index} + {_slot_index}
            if {_current_ach_index} <= {_end_index} and {_current_ach_index} < {_total_achievements}:
                set {_id} to {achievements_list::%{_current_ach_index}%}
                set {_name} to {achievement::%{_id}%::name} ? "&cUnknown Achievement"
                set {_description} to {achievement::%{_id}%::description} ? "&7No description."
                set {_icon_item_string} to {achievement::%{_id}%::icon} ? "minecraft:barrier"
                set {_icon_item} to {_icon_item_string} parsed as item
                set {_unlocked} to {player::%{_uuid}%::achievements::%{_id}%} is set

                set {_lore::*} to ("&7ID: &8%{_id}%", "&e%{_description}%")
                if {achievement::%{_id}%::reward::message} is set:
                    add "" to {_lore::*}
                    add "&6Reward: &f%{achievement::%{_id}%::reward::message}%" to {_lore::*}
                if {achievement::%{_id}%::reward::clicks} is set:
                    add "&6Reward: &f%{achievement::%{_id}%::reward::clicks}% Clicks" to {_lore::*}
                if {achievement::%{_id}%::reward::prestige_points} is set:
                    add "&6Reward: &d%{achievement::%{_id}%::reward::prestige_points}% Prestige Points" to {_lore::*}

                if {_unlocked}:
                    make gui slot {_gui_item_slot} with {_icon_item} named "&a%{_name}% &7(Unlocked)" with lore {_lore::*} and "" and "&aYou have completed this!"
                else:
                    set {_condition_text} to "&cRequirement: %{achievement::%{_id}%::description}%"
                    # More specific condition text if possible, fallback to generic
                    if {achievement::%{_id}%::condition::type} is "clicks":
                        set {_condition_text} to "&cReach %{achievement::%{_id}%::condition::value}% total clicks."
                    else if {achievement::%{_id}%::condition::type} is "speed_level":
                        set {_condition_text} to "&cUpgrade speed to level %{achievement::%{_id}%::condition::value}%."
                    else if {achievement::%{_id}%::condition::type} is "autoclicker_level":
                        set {_condition_text} to "&cUpgrade auto-clicker to level %{achievement::%{_id}%::condition::value}%."
                    else if {achievement::%{_id}%::condition::type} is "races_won":
                        set {_condition_text} to "&cWin %{achievement::%{_id}%::condition::value}% race(s)."
                    else if {achievement::%{_id}%::condition::type} is "races_participated":
                        set {_condition_text} to "&cParticipate in %{achievement::%{_id}%::condition::value}% race(s)."
                    else if {achievement::%{_id}%::condition::type} is "prestige_level":
                        set {_condition_text} to "&cReach prestige level %{achievement::%{_id}%::condition::value}%."
                    
                    make gui slot {_gui_item_slot} with gray dye named "&7%{_name}% &c(Locked)" with lore {_lore::*} and "" and {_condition_text}
            else:
                # Fill remaining slots with placeholders
                make gui slot {_gui_item_slot} with black stained glass pane named " " # Fill empty achievement slots if page not full
            add 1 to {_slot_index}

        # Pagination and Border
        loop integers from 0 to 53:
            set {_current_slot} to loop-value
            if {_current_slot} < 9 or {_current_slot} > 44 or {_current_slot} mod 9 is 0 or {_current_slot} mod 9 is 8:
                if gui slot {_current_slot} is not set:
                    make gui slot {_current_slot} with gray stained glass pane named " "
        
        if {_page} > 1:
            make gui slot 45 with arrow named "&ePrevious Page" with lore "&7Click to go to page %{_page} - 1%" to run function openAchievementsGUI({_p}, {_page} - 1)
        else:
            make gui slot 45 with gray stained glass pane named " "

        make gui slot 49 with book named "&7Page %{_page}% of %{_totalPages}%" with lore "&7Total Achievements: %{_total_achievements}%"

        if {_page} < {_totalPages}:
            make gui slot 53 with arrow named "&eNext Page" with lore "&7Click to go to page %{_page} + 1%" to run function openAchievementsGUI({_p}, {_page} + 1)
        else:
            make gui slot 53 with gray stained glass pane named " "

    open last created gui to {_p}

# Call checkAchievements at appropriate times:
# - In clicking.sk: after a click is registered and total clicks updated.
# - In shop.sk: after an upgrade is purchased and level updated.
# - In racing.sk: after a race is won/participated and stats updated.
# - In prestige.sk: after a prestige and level updated.
# File: leaderboards.sk
# Path: race-clicker/features/leaderboards.sk
# Description: Manages and displays leaderboards for various stats.

options:
    prefix: "&6&lRaceClicker &8» &bLeaderboards &8»"
    max_leaderboard_entries: 10 # How many top entries to show

# Leaderboard Data Structure (Example - adjust as needed):
# {leaderboards::track::%track_id%::top_times::%player_uuid%::time} - stores best time (as timespan or number of ticks)
# {leaderboards::track::%track_id%::top_times::%player_uuid%::name} - stores player name for display
# {leaderboards::global::clicks::%player_uuid%::amount} - stores total clicks
# {leaderboards::global::clicks::%player_uuid%::name} - stores player name
# {leaderboards::global::races_won::%player_uuid%::amount}
# {leaderboards::global::races_won::%player_uuid%::name}
# {leaderboards::global::prestige_level::%player_uuid%::amount}
# {leaderboards::global::prestige_level::%player_uuid%::name}

# --- Leaderboard Update Functions --- #

# Called when a player finishes a race with a new personal best on a track
function updateTrackLeaderboard(p: player, track_id: text, time_taken: timespan):
    set {_uuid} to {_p}'s uuid
    set {_time_ticks} to ticks from {_time_taken} # Store as ticks for easier comparison

    # Check if current time is better than existing, or if player is not on leaderboard yet
    if {leaderboards::track::%{_track_id}%::top_times::%{_uuid}%::time} is not set or {_time_ticks} < {leaderboards::track::%{_track_id}%::top_times::%{_uuid}%::time}:
        set {leaderboards::track::%{_track_id}%::top_times::%{_uuid}%::time} to {_time_ticks}
        set {leaderboards::track::%{_track_id}%::top_times::%{_uuid}%::name} to name of {_p}
        # Potentially prune leaderboard if it exceeds max_leaderboard_entries after adding
        # This requires sorting all entries and removing the worst ones, which can be complex with Skript's list vars.
        # A simpler approach is to just store all and display top N.
        send "{@prefix} &aNew personal best on %{tracks::%{_track_id}%::name}! Your time has been recorded." to {_p}
    # TODO: Add logic to sort and prune the leaderboard to keep only top N entries if desired.

# Called when a player's global stat (like total clicks) changes significantly
function updateGlobalLeaderboard(stat_type: text, p: player, value: number):
    set {_uuid} to {_p}'s uuid
    # Example for 'clicks'
    if {_stat_type} is "clicks":
        # Only update if new value is higher (or if not set)
        if {leaderboards::global::clicks::%{_uuid}%::amount} is not set or {_value} > {leaderboards::global::clicks::%{_uuid}%::amount}:
            set {leaderboards::global::clicks::%{_uuid}%::amount} to {_value}
            set {leaderboards::global::clicks::%{_uuid}%::name} to name of {_p}
    else if {_stat_type} is "races_won":
        if {leaderboards::global::races_won::%{_uuid}%::amount} is not set or {_value} > {leaderboards::global::races_won::%{_uuid}%::amount}:
            set {leaderboards::global::races_won::%{_uuid}%::amount} to {_value}
            set {leaderboards::global::races_won::%{_uuid}%::name} to name of {_p}
    else if {_stat_type} is "prestige_level":
        if {leaderboards::global::prestige_level::%{_uuid}%::amount} is not set or {_value} > {leaderboards::global::prestige_level::%{_uuid}%::amount}:
            set {leaderboards::global::prestige_level::%{_uuid}%::amount} to {_value}
            set {leaderboards::global::prestige_level::%{_uuid}%::name} to name of {_p}
    # Add more stat types as needed
    # TODO: Pruning logic similar to track leaderboards if storing all entries becomes an issue.

# --- Leaderboard Display Command --- #

command /leaderboard [<text>] [<text>]:
    aliases: /lb, /top
    trigger:
        if arg-1 is not set or arg-1 is "help":
            send "{@prefix} &eAvailable Leaderboards:"
            send "&7- &b/lb global <clicks|races_won|prestige>"
            send "&7- &b/lb track <track_id>"
            send "&7- &b/lb tracks &7(Lists available track leaderboards)"
            stop

        if arg-1 is "tracks":
            send "{@prefix} &eTrack Leaderboards Available For:"
            if size of {tracks::*} is 0:
                send "&c - No tracks defined yet."
                stop
            loop {tracks::*}:
                send "&7- &a%loop-value::name% &7(ID: &b%loop-index%&7)"
            stop

        if arg-1 is "global":
            if arg-2 is not set or arg-2 is not in ("clicks", "races_won", "prestige_level", "prestige"):
                send "{@prefix} &cUsage: /lb global <clicks|races_won|prestige_level>"
                stop
            set {_stat_to_display} to arg-2
            if {_stat_to_display} is "prestige": # alias
                set {_stat_to_display} to "prestige_level"
            
            send "{@prefix} &6&lGlobal Top %capitalize({_stat_to_display})%" 
            clear {_temp_lb_entries::*}
            loop {leaderboards::global::%{_stat_to_display}%::*}:
                add "%{leaderboards::global::%{_stat_to_display}%::%loop-index%::name}%:%{leaderboards::global::%{_stat_to_display}%::%loop-index%::amount}%" to {_temp_lb_entries::*}
            
            if size of {_temp_lb_entries::*} is 0:
                send "&c - No data available for this leaderboard yet."
                stop

            sort {_temp_lb_entries::*} by number split at ":" part 2 descending

            loop (min(size of {_temp_lb_entries::*}, {@max_leaderboard_entries})) times:
                set {_entry} to {_temp_lb_entries::%loop-number%}
                set {_name} to text split {_entry} at ":" part 1
                set {_score} to number split {_entry} at ":" part 2
                if {_stat_to_display} is "clicks" or {_stat_to_display} is "races_won" or {_stat_to_display} is "prestige_level":
                    send "&e#%loop-number% &7- &b%{_name}% &7- &a%{_score}%, %{_stat_to_display}%"
                else:
                    send "&e#%loop-number% &7- &b%{_name}% &7- &a%{_score}%"
            stop

        if arg-1 is "track":
            if arg-2 is not set or {tracks::%arg-2%::name} is not set:
                send "{@prefix} &cUsage: /lb track <track_id>. Track ID '%arg-2%' not found."
                send "{@prefix} &7Use /lb tracks to see available track IDs."
                stop
            set {_track_id_display} to arg-2
            send "{@prefix} &6&lTop Times for %{tracks::%{_track_id_display}%::name}%"
            clear {_temp_lb_entries::*}
            loop {leaderboards::track::%{_track_id_display}%::top_times::*}:
                add "%{leaderboards::track::%{_track_id_display}%::top_times::%loop-index%::name}%:%{leaderboards::track::%{_track_id_display}%::top_times::%loop-index%::time}%" to {_temp_lb_entries::*}

            if size of {_temp_lb_entries::*} is 0:
                send "&c - No times recorded for this track yet."
                stop

            sort {_temp_lb_entries::*} by number split at ":" part 2 ascending # Times: lower is better

            loop (min(size of {_temp_lb_entries::*}, {@max_leaderboard_entries})) times:
                set {_entry} to {_temp_lb_entries::%loop-number%}
                set {_name} to text split {_entry} at ":" part 1
                set {_time_ticks_lb} to number split {_entry} at ":" part 2
                set {_formatted_time} to formatTimespan({_time_ticks_lb} ticks) # Requires formatTimespan from utils
                send "&e#%loop-number% &7- &b%{_name}% &7- &a%{_formatted_time}%"
            stop

# --- Utility Functions (if needed) --- #
# Example: Function to prune leaderboards (more complex)
# function pruneLeaderboard(type: text, id: text optional, stat: text optional):
# This would involve getting all entries, sorting, and deleting extras.
# For Skript, it's often easier to just sort on display and limit display count.

on load:
    # Ensure utils/formatters.sk is loaded if not already handled by a core script
    # require script "utils/formatters.sk" # Assuming it's loaded elsewhere
    send console "[RaceClicker - Leaderboards] Loaded."
# File: pets.sk
# Path: race-clicker/features/pets.sk
# Description: Pet system for Race Clicker

options:
    prefix: &8[&6RaceClickerPets&8]&r
    debug_mode: {rc.debug_mode} # Inherit from a global debug mode if available, else set to false
    max_active_pets: 1 # Default max active pets if player-specific variable isn't set
    pet_follow_distance: 3 # Default distance before pets try to pathfind (pathfinding is basic)
    pet_follow_distance_teleport: 15 # Distance at which pets will teleport to the player

# --- Pet Definitions ---
# Structure: {pet::type::name}, {pet::type::entity_type}, {pet::type::skin_data} (e.g., for player heads)
#            {pet::type::bonus::type} (e.g., "click_multiplier", "autoclick_boost", "luck_increase")
#            {pet::type::bonus::value} (e.g., 1.1 for 10% boost, 5 for +5 autoclick)
#            {pet::type::rarity} (e.g., "common", "rare", "epic", "legendary")

variables:
    {player::%uuid%::pets::owned::*} # List of pet types owned by the player
    {player::%uuid%::pets::active::*} # List of currently active pet types for the player
    {player::%uuid%::pets::max_active} = integer # Player's personal max active pets limit
    {pet_entities::%uuid_of_pet_entity%} = text # Stores the pet type for a spawned entity

variables:
    {pet_types_list::*} # List of all defined pet IDs for easier iteration

on load:
    delete {pet_types_list::*}
    # Define pets
    # (id, display name, entity type, skin data (for heads), bonus type, bonus value, rarity)
    definePet("common_dog", "&7Common Dog", "WOLF", null, "click_multiplier_percent", 5, "common") # 5% click boost
    definePet("rare_cat", "&9Rare Cat", "CAT", null, "autoclick_add", 2, "rare") # +2 autoclicks/sec
    definePet("epic_fox", "&5Epic Fox", "FOX", null, "race_speed_boost_percent", 3, "epic") # 3% race speed boost
    definePet("legendary_dragon_head", "&6Legendary Dragon", "PLAYER_HEAD", "eyJ0ZXh0dXJlcyI6eyJTS0lOIjp7InVybCI6Imh0dHA6Ly90ZXh0dXJlcy5taW5lY3JhZnQubmV0L3RleHR1cmUvYjc4ZWYyZTRjZDBhZDRlYjViNDEwYjY1ZGU1NmMyOWE2YjhiMGIyYzQyNWZhZGU0NGFhNWM0NzY0M2VmZDAifX19", "prestige_points_multiplier_percent", 10, "legendary") # 10% more prestige points
    definePet("common_chicken", "&fCommon Chicken", "CHICKEN", null, "click_multiplier_percent", 2, "common")
    definePet("rare_pig", "&dRare Pig", "PIG", null, "autoclick_add", 1, "rare")

    if {rc.debug_mode} is true:
        broadcast "&7[Debug] Pet definitions loaded: %size of {pet_types_list::*}% pets defined."

function definePet(id: text, name: text, entityType: text, skinData: text, bonusType: text, bonusValue: number, rarity: text):
    set {pet::%{_id}%::name} to {_name}
    set {pet::%{_id}%::entity_type} to {_entityType}
    if {_skinData} is set:
        set {pet::%{_id}%::skin_data} to {_skinData} # For custom player head pets or textured mobs
    set {pet::%{_id}%::bonus::type} to {_bonusType}
    set {pet::%{_id}%::bonus::value} to {_bonusValue}
    set {pet::%{_id}%::rarity} to {_rarity}
    add {_id} to {pet_types_list::*}

# --- Pet Management --- 
# Implemented basic summon/desummon and effect application placeholders
# Following behavior is conceptual (see end of file)

command /pet [<text>] [<text>]:
    aliases: /pets, /rcpet
    trigger:
        if arg-1 is not set:
            openPetInventory(player)
            # Implemented openPetInventory(player) function
        else if arg-1 is "summon" or "activate":
            if arg-2 is set:
                activatePet(player, arg-2)
                # Implemented activatePet(player, pet_id) function
            else:
                send "{@prefix} &cUsage: /pet %arg-1% <pet_id>"
        else if arg-1 is "unsummon" or "deactivate":
            if arg-2 is set:
                deactivatePet(player, arg-2)
                # Implemented deactivatePet(player, pet_id) function
            else:
                send "{@prefix} &cUsage: /pet %arg-1% <pet_id>"
        else if arg-1 is "list":
            listOwnedPets(player)
            # Implemented listOwnedPets(player) function
        else:
            send "{@prefix} &cUnknown pet command. Use /pet [summon|unsummon|list] [pet_id] or /pet to open inventory."

# --- Pet Inventory GUI ---
# Implemented basic GUI for managing owned pets

# --- Pet Acquisition ---
# TODO: Implement pet egg/hatching system (could be in a separate 'hatching.sk' or here)
# TODO: Implement pet merging/evolution system
# TODO: Implement pet egg/hatching system (could be in a separate 'hatching.sk' or here)
# TODO: Implement pet merging/evolution system
# TODO: Add a way for players to get pets (e.g. /buypetegg command, drops from races, achievement rewards, shop purchase)

# --- Event Handlers ---
on quit:
    # Despawn active pets for the player
    despawnActivePets(player) # Implemented basic version

on damage:
    # Prevent pets from taking damage or being targeted by mobs
    if {pet_entities::%victim's uuid%} is set:
        cancel event

# --- Utility Functions (Placeholders) ---
function activatePet(p: player, pet_id: text):
    set {_uuid} to {_p}'s uuid
    if {_pet_id} is not in {player::%{_uuid}%::pets::owned::*}:
        send "{@prefix} &cYou do not own the pet '%{_pet_id}%'." to {_p}
        return

    set {_max_pets} to {player::%{_uuid}%::pets::max_active} ? {@max_active_pets}
    if size of {player::%{_uuid}%::pets::active::*} >= {_max_pets}:
        send "{@prefix} &cYou have reached your maximum number of active pets (%{_max_pets}%)." to {_p}
        return

    if {_pet_id} is in {player::%{_uuid}%::pets::active::*}:
        send "{@prefix} &cPet '%{_pet_id}%' is already active." to {_p}
        return

    set {_pet_entity_type_str} to {pet::%{_pet_id}%::entity_type}
    set {_pet_entity_type} to {_pet_entity_type_str} parsed as entity type
    if {_pet_entity_type} is not set:
        send "{@prefix} &cError: Invalid entity type for pet %{_pet_id}%: %{_pet_entity_type_str}%" to {_p}
        if {rc.debug_mode} is true:
            send "&c[Debug] Pet %{_pet_id}% has invalid entity type: %{_pet_entity_type_str}%" to console
        return

    set {_spawn_loc} to location of {_p}
    add 0.5 to y-coordinate of {_spawn_loc} # Spawn slightly above to prevent getting stuck in floor
    spawn {_pet_entity_type} at {_spawn_loc}
    set {_last_spawned_pet} to last spawned entity
    set name of {_last_spawned_pet} to "%{pet::%{_pet_id}%::name}% &7(&e%{_p}'s&7)"
    set {_last_spawned_pet} to tame
    set owner of {_last_spawned_pet} to {_p}
    set {pet_entities::%{_last_spawned_pet}'s uuid%} to "%{_uuid}%:%{_pet_id}%"

    if {_pet_entity_type_str} is "PLAYER_HEAD" or {_pet_entity_type_str} is "player_head":
        if {pet::%{_pet_id}%::skin_data} is set:
            pass

    add {_pet_id} to {player::%{_uuid}%::pets::active::*}
    send "{@prefix} &aPet %{pet::%{_pet_id}%::name}% &aactivated!" to {_p}
    play sound "minecraft:entity.wolf.howl" to {_p} with volume 0.8 pitch 1.2
    refreshPlayerPetBonuses({_p})

function deactivatePet(p: player, pet_id: text, silent: boolean = false):
    set {_uuid} to {_p}'s uuid
    if {_pet_id} is not in {player::%{_uuid}%::pets::active::*}:
        if {_silent} is false:
            send "{@prefix} &cPet '%{_pet_id}%' is not active." to {_p}
        return

    # Find and remove the pet entity
    loop all entities:
        if {pet_entities::%loop-entity's uuid%} is "%{_uuid}%:%{_pet_id}%":
            remove loop-entity # Replace delete with 'remove', proper entity removal effect in Skript
            delete {pet_entities::%loop-entity's uuid%}
            exit loop

    remove {_pet_id} from {player::%{_uuid}%::pets::active::*}
    if {_silent} is false:
        send "{@prefix} &ePet %{pet::%{_pet_id}%::name}% &edeactivated." to {_p}
        play sound "minecraft:entity.wolf.whine" to {_p} with pitch 1 volume 0.8
    refreshPlayerPetBonuses({_p})

function despawnActivePets(p: player):
    set {_uuid} to {_p}'s uuid
    loop {player::%{_uuid}%::pets::active::*} an NBT list:
        set {_pet_id_to_despawn} to loop-value
        deactivatePet({_p}, {_pet_id_to_despawn}, true) # Silent deactivation
    clear {player::%{_uuid}%::pets::active::*}
    if {rc.debug_mode} is true:
        send "&7[Debug] Despawned all active pets for %{_p}%." to console

function openPetInventory(p: player):
    set {_uuid} to {_p}'s uuid
    create a gui with virtual chest inventory with 6 rows named "&8&nPets":
        set {_slot} to 0
        # Owned Pets Section (first 4 rows for example)
        loop {player::%{_uuid}%::pets::owned::*}:
            set {_pet_id} to loop-value
            set {_pet_name} to {pet::%{_pet_id}%::name} ? "&cUnknown Pet"
            set {_pet_rarity} to {pet::%{_pet_id}%::rarity} ? "&7N/A"
            set {_pet_bonus_type} to {pet::%{_pet_id}%::bonus::type}
            set {_pet_bonus_value} to {pet::%{_pet_id}%::bonus::value}
            set {_pet_icon_str} to {pet::%{_pet_id}%::entity_type}
            set {_pet_icon} to paper # Default icon
            if {_pet_icon_str} is "WOLF": set {_pet_icon} to bone
            else if {_pet_icon_str} is "CAT": set {_pet_icon} to cod
            else if {_pet_icon_str} is "FOX": set {_pet_icon} to sweet_berries
            else if {_pet_icon_str} is "CHICKEN": set {_pet_icon} to feather
            else if {_pet_icon_str} is "PIG": set {_pet_icon} to carrot
            else if {_pet_icon_str} is "PLAYER_HEAD":
                if {pet::%{_pet_id}%::skin_data} is set:
                    set {_pet_icon} to player head with nbt "{SkullOwner:{Textures:[{Value:"%{pet::%{_pet_id}%::skin_data}%"}]}}"
                else:
                    set {_pet_icon} to player head
            
            set {_lore::*} to ("&7Rarity: %formatRarity({_pet_rarity})%", "")
            add "&6Bonus:&f %formatPetBonus({_pet_bonus_type}, {_pet_bonus_value})%" to {_lore::*}
            add "" to {_lore::*}

            if {_pet_id} is in {player::%{_uuid}%::pets::active::*}:
                add "&cClick to Deactivate" to {_lore::*}
                make gui slot {_slot} with {_pet_icon} named "&a%{_pet_name}% &7(Active)" with lore {_lore::*} to run function runPetInventoryAction({_p}, "deactivate", {_pet_id})
            else:
                add "&aClick to Activate" to {_lore::*}
                make gui slot {_slot} with {_pet_icon} named "&e%{_pet_name}% &7(Inactive)" with lore {_lore::*} to run function runPetInventoryAction({_p}, "activate", {_pet_id})
            
            add 1 to {_slot}
            if {_slot} >= 36: # Max items in first 4 rows
                stop loop

        # Fill remaining pet slots with glass panes
        loop integers from {_slot} to 35:
            make gui slot loop-value with light_gray_stained_glass_pane named " "

        # Info / Controls section (bottom 2 rows)
        make gui slot 49 with book named "&ePet Info" with lore "&7Manage your active pets." and "&7Max Active Pets: &6%{player::%{_uuid}%::pets::max_active} ? {@max_active_pets}%"
        
        # Fill border of bottom rows
        loop integers from 36 to 53:
            if gui slot loop-value is not set:
                if loop-value < 45 or loop-value > 53 or loop-value mod 9 = 0 or loop-value mod 9 = 8:
                    make gui slot loop-value with gray_stained_glass_pane named " "

    open last gui to {_p}

function runPetInventoryAction(p: player, action: text, pet_id: text):
    close inventory of {_p}
    if {_action} is "activate":
        activatePet({_p}, {_pet_id})
    else if {_action} is "deactivate":
        deactivatePet({_p}, {_pet_id})
    wait 1 tick # Give time for commands to process before reopening
    openPetInventory({_p}) # Refresh GUI

function formatRarity(rarity_text: text) -> text:
    if {_rarity_text} is "common": return "&fCommon"
    if {_rarity_text} is "rare": return "&9Rare"
    if {_rarity_text} is "epic": return "&5Epic"
    if {_rarity_text} is "legendary": return "&6Legendary"
    return "&7%{_rarity_text}%"

function formatPetBonus(type: text, value: number) -> text:
    if {_type} is "click_multiplier_percent": return "&e+% {_value}%%% Click Power"
    if {_type} is "autoclick_add": return "&e+% {_value}% Auto-Clicks/sec"
    if {_type} is "race_speed_boost_percent": return "&e+% {_value}%%% Race Speed"
    if {_type} is "prestige_points_multiplier_percent": return "&e+% {_value}%%% Prestige Points"
    return "&7Unknown Bonus"

function listOwnedPets(p: player):
    set {_uuid} to {_p}'s uuid
    if size of {player::%{_uuid}%::pets::owned::*} is 0:
        send "{@prefix} &7You do not own any pets yet." to {_p}
        return

    send "{@prefix} &6Your Pets:&r" to {_p}
    loop {player::%{_uuid}%::pets::owned::*}:
        set {_pet_id} to loop-value
        set {_pet_name} to {pet::%{_pet_id}%::name} ? "&cUnknown Pet"
        set {_status} to "&7(Inactive)"
        if {_pet_id} is in {player::%{_uuid}%::pets::active::*}:
            set {_status} to "&a(Active)"
        send " &7- %{_pet_name}% %{_status}%" to {_p}
    send "{@prefix} &7Use &e/pet&7 to manage them." to {_p}

# --- Pet Following Logic ---
every 1 second:
    loop all players:
        if loop-player is online:
            set {_player_uuid} to loop-player's uuid
            if {player::%{_player_uuid}%::pets::active::*} is set:
                loop {player::%{_player_uuid}%::pets::active::*}:
                    set {_active_pet_id} to loop-value
                    # Find the actual entity for this pet
                    loop all entities:
                        if {pet_entities::%loop-entity-2's uuid%} is "% {_player_uuid}%:%{_active_pet_id}%":
                            set {_pet_entity} to loop-entity-2
                            if {_pet_entity} is set:
                                if world of {_pet_entity} is world of loop-player: # Ensure same world
                                    set {_distance} to distance between loop-player and {_pet_entity}
                                    if {_distance} > {@pet_follow_distance_teleport}:
                                        teleport {_pet_entity} to location of loop-player
                                    else if {_distance} > {@pet_follow_distance}:
                                        # Simple teleport if pathfinding is not reliable or too complex for Skript
                                        # This ensures pets keep up without complex pathfinding logic
                                        teleport {_pet_entity} to behind loop-player at distance (random number between 1.5 and 2.5)
                                        # For a more advanced server, you'd use a proper pathfinding AI from a plugin.
                                        # Example of what you might try with Skript's limited pathfinding:
                                        # if {_pet_entity} is not an armor stand: # Pathfinding usually for mobs
                                        #    make {_pet_entity} pathfind to loop-player with speed 1.2
                                        # else:
                                        #    # Armor stands don't pathfind, so teleport is the only option
                                        #    teleport {_pet_entity} to behind loop-player at distance (random number between 1.5 and 2.5)
                            exit loop # Found the pet entity

# --- Applying Pet Bonuses ---

# --- Applying Pet Bonuses ---
# This function should be called whenever active pets change or relevant stats are calculated.
function getPetBonus(p: player, bonus_type_filter: text) -> number:
    set {_uuid} to {_p}'s uuid
    set {_total_bonus} to 0
    if {_bonus_type_filter} ends with "_percent": # For percentage bonuses, sum them up
        loop {player::%{_uuid}%::pets::active::*}:
            set {_pet_id} to loop-value
            if {pet::%{_pet_id}%::bonus::type} is {_bonus_type_filter}:
                add {pet::%{_pet_id}%::bonus::value} to {_total_bonus}
        return {_total_bonus} # Returns total percentage, e.g., 15 for 15%
    else if {_bonus_type_filter} ends with "_add": # For additive bonuses, sum them up
        loop {player::%{_uuid}%::pets::active::*}:
            set {_pet_id} to loop-value
            if {pet::%{_pet_id}%::bonus::type} is {_bonus_type_filter}:
                add {pet::%{_pet_id}%::bonus::value} to {_total_bonus}
        return {_total_bonus} # Returns total additive value, e.g., 5 for +5
    # Add other bonus calculation types if needed (e.g., multiplicative stacking)
    return 0

# Example of how to use getPetBonus in clicking.sk (conceptual)
# function calculateClickPower(p: player) -> number:
#     set {_power} to {player::%{_p}'s uuid%::base_click_power} ? 1
#     set {_click_multiplier_percent} to getPetBonus({_p}, "click_multiplier_percent")
#     set {_power} to {_power} * (1 + ({_click_multiplier_percent} / 100))
#     return {_power}

# This function should be called after activating/deactivating pets
function refreshPlayerPetBonuses(p: player):
    # This is a placeholder. In a real scenario, you might trigger updates
    # in other scripts that use these bonuses, or re-calculate cached stats.
    if {rc.debug_mode} is true:
        send "&7[Debug] Pet bonuses refreshed for %{_p}% (conceptual)." to console
        send "&7  Click Multiplier Bonus: %getPetBonus({_p}, "click_multiplier_percent")%%%" to console
        send "&7  Autoclick Add Bonus: +%getPetBonus({_p}, "autoclick_add")%" to console

# Admin commands for pets
command /rcpetadmin <player> <text> [<text>] [<text>]:
    permission: raceclicker.admin
    trigger:
        if arg-2 is "give":
            if arg-3 is set:
                if {pet::%arg-3%::name} is not set:
                    send "{@prefix} &cPet ID '%arg-3%' does not exist." to sender
                    return
                add arg-3 to {player::%arg-1's uuid%::pets::owned::*}
                send "{@prefix} &aGave pet %{pet::%arg-3%::name}%&r&a to %arg-1%." to sender
            else:
                send "{@prefix} &cUsage: /rcpetadmin <player> give <pet_id>" to sender
        else if arg-2 is "remove":
            if arg-3 is set:
                if arg-3 is in {player::%arg-1's uuid%::pets::active::*}:
                    deactivatePet(arg-1, arg-3, true) # Silent deactivate
                remove arg-3 from {player::%arg-1's uuid%::pets::owned::*}
                send "{@prefix} &aRemoved pet %arg-3% from %arg-1%." to sender
            else:
                send "{@prefix} &cUsage: /rcpetadmin <player> remove <pet_id>" to sender
        else if arg-2 is "clearowned":
            despawnActivePets(arg-1) # Despawns and clears active list
            delete {player::%arg-1's uuid%::pets::owned::*}
            send "{@prefix} &aCleared all owned pets for %arg-1%." to sender
        else if arg-2 is "setmaxactive":
            if arg-3 is set and arg-3 is a number:
                set {player::%arg-1's uuid%::pets::max_active} to arg-3 parsed as number
                send "{@prefix} &aSet max active pets for %arg-1% to %arg-3%." to sender
            else:
                send "{@prefix} &cUsage: /rcpetadmin <player> setmaxactive <number>" to sender
        else:
            send "{@prefix} &cUnknown pet admin command." to sender

# TODO: Add pet skin/appearance customization (e.g. for player head pets)
# TODO: Add pet leveling system (pets gain XP and level up for better bonuses)
# TODO: Add pet trading system between players
# File: prestige.sk
# Path: race-clicker/features/prestige.sk
# Description: Prestige mechanics

options:
    prefix: &6&lRaceClicker &8» # Example prefix
    prestige_base_cost: 1000000 # Example: Clicks needed for first prestige
    prestige_cost_multiplier: 2 # Cost increases for subsequent prestiges
    prestige_points_per_prestige: 1 # Points gained per prestige

# --- Phase 8: Content and Progression Systems ---
# Enhanced Progression Features
# - TODO: Complete prestige system
#   - Fix prestige calculation formulas (cost, points gained)
#   - Add prestige-only upgrades (would be in shop.sk or a new prestige_shop.sk)
#   - Implement prestige point spending (in shop.sk or prestige_shop.sk)

# --- Phase 1: Fix and Complete Core Systems (related to shop GUI) ---
# - TODO: Prestige confirmation system (slot 22 in shop.sk calls a function here)

# --- Phase 3: Complete GUI Systems (related to shop GUI) ---
# - TODO: Implement prestige confirmation GUI (called from shop.sk)

# Variables:
# {player::%player's uuid%::prestige-level} - Current prestige level
# {player::%player's uuid%::prestige-points} - Currency for prestige shop

# Function called from shop.sk to open prestige confirmation
function openPrestigeConfirmationGUI(p: player):
    set {_current_prestige_level} to {player::%{_p}'s uuid%::prestige-level} ? 0
    set {_next_prestige_level} to {_current_prestige_level} + 1
    # Prestige calculation formulas
    # Cost: base_cost * (multiplier ^ current_prestige_level)
    # Ensure current_prestige_level is not negative if it's ever manually set to avoid math errors with ^ operator.
    set {_effective_prestige_level_for_cost} to {_current_prestige_level}
    if {_effective_prestige_level_for_cost} < 0:
        set {_effective_prestige_level_for_cost} to 0 # Prevent issues with negative exponent
    set {_prestige_cost} to round({@prestige_base_cost} * ({@prestige_cost_multiplier} ^ {_effective_prestige_level_for_cost}))

    # Points gained can be simple or dynamic. For now, simple.
    set {_points_to_gain} to {@prestige_points_per_prestige}
    # Example of dynamic points: set {_points_to_gain} to {@prestige_points_per_prestige} + floor({_current_prestige_level} / 5) # Extra point every 5 levels

    # Check if player can prestige
    if {player::%{_p}'s uuid%::clicks} < {_prestige_cost}:
        send "{@prefix} &cYou need at least %{_prestige_cost}% clicks to prestige!" to {_p}
        play sound "minecraft:entity.villager.no" to {_p}
        return

    create a gui with virtual chest inventory with 3 rows named "&5&lConfirm Prestige Lvl %{_next_prestige_level}%?":
        make gui slot 4 with nether star named "&d&lPrestige Information" with lore "&7Current Prestige Level: &e%{_current_prestige_level}%" and "&7Next Prestige Level: &e%{_next_prestige_level}%" and "" and "&7Cost to Prestige: &c%{_prestige_cost}% Clicks" and "&7Points on Prestige: &b%{_points_to_gain}% Prestige Points" and "" and "&cWARNING: Prestiging will reset your" and "&cclicks, speed, and auto-clicker levels!"

        make gui slot 11 with lime stained_glass_pane named "&a&lYES, PRESTIGE!" with lore "&7Reset progress for &b%{_points_to_gain}% Prestige Points." and "&7This action is irreversible!" to run function attemptPrestige({_p}, {_prestige_cost}, {_points_to_gain})

        make gui slot 15 with red stained_glass_pane named "&c&lNO, CANCEL!" with lore "&7Return to the shop." to run function openUpgradeShop({_p}) # Assumes openUpgradeShop is globally accessible or defined in shop.sk

        # Fill border
        loop 27 times:
            if gui slot (loop-number - 1) is not set:
                make gui slot (loop-number - 1) with purple stained glass pane named " "

    open last gui to {_p}

# Function to handle the actual prestige process
function attemptPrestige(p: player, cost: number, points_gained: number):
    close inventory of {_p} # Close the confirmation GUI

    # Double check cost (should be redundant if GUI logic is correct)
    if {player::%{_p}'s uuid%::clicks} < {_cost}:
        send "{@prefix} &cSomething went wrong. You don't have enough clicks." to {_p}
        return

    # Reset progress
    # NOTE: Keep track of what needs to be reset. Achievements? Stats? Track best times?
    # The plan implies clicks, speed, and auto-clicker. Other things might persist.
    set {player::%{_p}'s uuid%::clicks} to 0
    set {player::%{_p}'s uuid%::speed-level} to 1 # Reset to base
    set {player::%{_p}'s uuid%::autoclicker-level} to 0 # Reset to base
    # Add any other variables that should be reset upon prestiging

    # Grant prestige benefits
    add 1 to {player::%{_p}'s uuid%::prestige-level}
    add {_points_gained} to {player::%{_p}'s uuid%::prestige-points}

    send "{@prefix} &d&lCongratulations! You have prestiged to Level %{player::%{_p}'s uuid%::prestige-level}%!" to {_p}
    send "{@prefix} &7Your Clicks, Speed Level, and Auto-Clicker Level have been reset." to {_p}
    send "{@prefix} &7You gained &b%{_points_gained}% Prestige Points&7. You now have &b%{player::%{_p}'s uuid%::prestige-points}% total." to {_p}
    play sound "minecraft:entity.player.levelup" to {_p} with volume 1 pitch 0.5
    play sound "minecraft:entity.ender_dragon.growl" to {_p} with volume 0.5 pitch 1.5

    # Call achievement check for prestige related achievements
    if function "checkAchievements" exists:
        checkAchievements({_p}) # (from achievements.sk)
    else if {rc.debug_mode} is true:
        send "{@prefix} &cWarning: Function 'checkAchievements' not found. Prestige achievements may not be awarded." to console

    # TODO: Implement prestige-only upgrades and prestige point spending (likely in shop.sk or a new prestige_shop.sk)
    # For now, direct players to the main shop (which might show new options based on prestige level or allow spending prestige points)
    send "{@prefix} &7Visit the &e/shop&7 to spend your Prestige Points and explore new upgrades!" to {_p}
    # Consider adding a specific command like /prestigeshop if it's a separate GUI.

# Command for admins to manage prestige (optional)
command /rcprestigeadmin <player> <text> <number>:
    permission: raceclicker.admin
    trigger:
        if arg-2 is "setlevel":
            set {player::%arg-1's uuid%::prestige-level} to arg-3
            send "{@prefix} &aSet %arg-1%'s prestige level to %arg-3%." to sender
        else if arg-2 is "addpoints":
            add arg-3 to {player::%arg-1's uuid%::prestige-points}
            send "{@prefix} &aAdded %arg-3% prestige points to %arg-1%." to sender
        else:
            send "{@prefix} &cUsage: /rcprestigeadmin <player> [setlevel|addpoints] <value>" to sender
# File: tournaments.sk
# Path: race-clicker/features/tournaments.sk
# Description: Competition systems

options:
    prefix: &6&lRaceClicker &8» # Example prefix

# --- Phase 6: Complete Multiplayer Features ---
# Enhanced Competition Features
# - TODO: Tournament bracket system
#   - Generate elimination brackets
#   - Manage multiple simultaneous races
#   - Track tournament progression
# - TODO: Seasonal competitions
#   - Monthly championship events
#   - Special reward tracks
#   - Limited-time upgrade opportunities

# --- Variables for Tournaments ---
# {tournament::current::id} = "unique_tournament_id"
# {tournament::%{_id}%::status} = "signups" / "running" / "finished"
# {tournament::%{_id}%::players::*} = list of participating player UUIDs
# {tournament::%{_id}%::bracket::round_1::match_1::player1} = player_uuid
# {tournament::%{_id}%::bracket::round_1::match_1::player2} = player_uuid
# {tournament::%{_id}%::bracket::round_1::match_1::winner} = player_uuid
# {tournament::%{_id}%::settings::track_id} = "track_for_tournament"
# {tournament::%{_id}%::settings::max_players} = 16
# {tournament::%{_id}%::settings::rewards::winner} = "command to give prize"

# --- Tournament Management Commands (Admin) ---
command /rctournamentadmin <text> [<text>]:
    permission: raceclicker.admin
    trigger:
        if arg-1 is "create":
            # Create a new tournament ID
            set {_new_id} to "tourney_" + random integer between 1000 and 9999
            set {tournament::current::id} to {_new_id}
            set {tournament::%{_new_id}%::status} to "signups"
            set {tournament::%{_new_id}%::settings::max_players} to 16 # Default
            set {tournament::%{_new_id}%::settings::min_players} to 4 # Minimum players to start
            set {tournament::%{_new_id}%::settings::track_id} to arg-2 ? "default_track"
            set {tournament::%{_new_id}%::current_round} to 0
            clear {tournament::%{_new_id}%::players::*}
            clear {tournament::%{_new_id}%::bracket::*}
            broadcast "{@prefix} &aA new tournament '%{_new_id}%' (Track: %{arg-2}% ? %{arg-2}% : "default_track") has been created! Type &e/tournament join&a to enter!" 
            send "{@prefix} &7Tournament '%{_new_id}%' created. Status: Signups. Track: %{tournament::%{_new_id}%::settings::track_id}%. Max Players: 16, Min Players: 4." to sender

        else if arg-1 is "start":
            set {_id} to {tournament::current::id}
            if not {_id} is set or {tournament::%{_id}%::status} is not "signups":
                send "{@prefix} &cNo tournament in signup phase to start." to sender
                stop
            if size of {tournament::%{_id}%::players::*} < {tournament::%{_id}%::settings::min_players}:
                send "{@prefix} &cNot enough players to start the tournament. (Need %{tournament::%{_id}%::settings::min_players}%, have %size of {tournament::%{_id}%::players::*}%)%" to sender
                stop
            
            generateTournamentBrackets({_id})
            if {tournament::%{_id}%::status} is "error_generating_brackets": # Check if bracket generation failed
                send "{@prefix} &cError generating brackets. Tournament not started." to sender
                delete {tournament::%{_id}%::status} # Reset status to allow re-attempt or cancellation
                stop

            set {tournament::%{_id}%::status} to "running"
            set {tournament::%{_id}%::current_round} to 1
            broadcast "{@prefix} &6Tournament '%{_id}%' has started! Check brackets with &e/tournament bracket&6."
            startNextTournamentRound({_id})

        else if arg-1 is "nextround": # Manually advance round if needed
            set {_id} to {tournament::current::id}
            if {_id} is not set or {tournament::%{_id}%::status} is not "running":
                send "{@prefix} &cNo tournament running or not ready for next round." to sender
                stop
            startNextTournamentRound({_id})

        else if arg-1 is "end":
            set {_id} to {tournament::current::id}
            if not {_id} is set:
                send "{@prefix} &cNo tournament to end." to sender
                stop
            
            # Announce winner and distribute prizes
            if {tournament::%{_id}%::status} is "running":
                set {_winner} to {tournament::%{_id}%::bracket::round_%{tournament::%{_id}%::current_round}%::match_1::winner}
                if {_winner} is set:
                    set {_winner_name} to name of {_winner} parsed as offline player
                    broadcast "{@prefix} &6Tournament '%{_id}%' has ended! Winner: %{_winner_name}%!"
                    # Give rewards
                    giveTournamentRewards({_id}, {_winner})
            
            # Clean up tournament data
            delete {tournament::current::id}
            delete {tournament::%{_id}%::*}
            broadcast "{@prefix} &cTournament '%{_id}%' has ended."

        else:
            send "{@prefix} &cUsage: /rctadmin [create <track_id>|start|nextround|end]" to sender

# --- Player Tournament Commands ---
command /tournament [<text>] [<text>]:
    trigger:
        if arg-1 is not set or arg-1 is "help":
            send "&6--- Tournament Commands ---"
            send "&e/tournament join &7- Join the current tournament during signups."
            send "&e/tournament leave &7- Leave the current tournament during signups."
            send "&e/tournament info &7- View info about the current tournament."
            send "&e/tournament bracket &7- View the current tournament bracket."
            send "&e/tournament spectate <match_id> &7- Spectate an ongoing match (conceptual)."
            # Potentially add /tournament list for past/upcoming tournaments
            stop

        set {_id} to {tournament::current::id}
        if {_id} is not set:
            send "{@prefix} &cThere is no active tournament currently." to player
            stop

        if arg-1 is "join":
            if {tournament::%{_id}%::status} is not "signups":
                send "{@prefix} &cTournament signups are closed." to player
                stop
            if player's uuid is in {tournament::%{_id}%::players::*}:
                send "{@prefix} &eYou are already in the tournament." to player
                stop
            if size of {tournament::%{_id}%::players::*} >= {tournament::%{_id}%::settings::max_players}:
                send "{@prefix} &cThe tournament is full." to player
                stop
            add player's uuid to {tournament::%{_id}%::players::*}
            send "{@prefix} &aYou have joined the tournament '%{_id}%'!" to player
            broadcast "{@prefix} &e%player% &7has joined the tournament! (%size of {tournament::%{_id}%::players::*}%/%{tournament::%{_id}%::settings::max_players}%)%"

        else if arg-1 is "leave":
            if {tournament::%{_id}%::status} is not "signups":
                send "{@prefix} &cYou can only leave a tournament during the signup phase." to player
                stop
            if player's uuid is not in {tournament::%{_id}%::players::*}:
                send "{@prefix} &eYou are not in this tournament." to player
                stop
            remove player's uuid from {tournament::%{_id}%::players::*}
            send "{@prefix} &aYou have left the tournament '%{_id}%'." to player
            broadcast "{@prefix} &e%player% &7has left the tournament. (%size of {tournament::%{_id}%::players::*}%/%{tournament::%{_id}%::settings::max_players}%)%"

        else if arg-1 is "info":
            send "{@prefix} &6--- Tournament Info: %{_id}% ---"
            send "&eStatus: &f%{tournament::%{_id}%::status}%"
            send "&eTrack: &f%{tournament::%{_id}%::settings::track_id}%"
            send "&ePlayers: &f%size of {tournament::%{_id}%::players::*}%/%{tournament::%{_id}%::settings::max_players}% (Min: %{tournament::%{_id}%::settings::min_players}%)%"
            if {tournament::%{_id}%::status} is "running":
                send "&eCurrent Round: &f%{tournament::%{_id}%::current_round}%"
            if {tournament::%{_id}%::status} is "finished":
                send "&eWinner: &f%name of {tournament::%{_id}%::winner} parsed as offline player%"
            send "&eTo view matches, use &6/tournament bracket&e."

        else if arg-1 is "bracket":
            send "{@prefix} &7Tournament bracket for '%{_id}%':"
            if {tournament::%{_id}%::status} is "signups":
                send "{@prefix} &7Signups are still open. Bracket will be generated when tournament starts."
                stop
            if {tournament::%{_id}%::status} is "error_generating_brackets" or {tournament::%{_id}%::status} is "error_no_matches":
                send "{@prefix} &cTournament bracket could not be generated or no matches formed."
                stop

            set {_max_rounds} to 0
            loop 10 times: # Assume max 10 rounds for now
                if {tournament::%{_id}%::bracket::round_%loop-number%::match_1::player1} is set or {tournament::%{_id}%::bracket::round_%loop-number%::match_1::winner} is set:
                    set {_max_rounds} to loop-number
                else:
                    stop loop
            
            if {_max_rounds} is 0 and {tournament::%{_id}%::status} is not "finished":
                send "&7No rounds or matches found. Tournament might be initializing or encountered an issue."
                stop

            send "&6--- Tournament: %{_id}% --- Track: %{tournament::%{_id}%::settings::track_id}% ---"
            loop integers from 1 to {_max_rounds}:
                set {_round_num} to loop-value
                if {tournament::%{_id}%::bracket::round_%{_round_num}%::match_1::player1} is not set and {tournament::%{_id}%::bracket::round_%{_round_num}%::match_1::winner} is not set:
                    if {_round_num} > {tournament::%{_id}%::current_round} and {tournament::%{_id}%::status} is not "finished": # Don't show empty future rounds
                        continue
                send "&b  --- Round %{_round_num}% ---"
                set {_any_match_in_round} to false
                loop {tournament::%{_id}%::bracket::round_%{_round_num}%::match_::*}:
                    set {_any_match_in_round} to true
                    set {_match_idx} to loop-index
                    set {_p1_uuid} to {tournament::%{_id}%::bracket::round_%{_round_num}%::match_%{_match_idx}%::player1}
                    set {_p2_uuid} to {tournament::%{_id}%::bracket::round_%{_round_num}%::match_%{_match_idx}%::player2}
                    set {_status} to {tournament::%{_id}%::bracket::round_%{_round_num}%::match_%{_match_idx}%::status}
                    set {_winner_uuid} to {tournament::%{_id}%::bracket::round_%{_round_num}%::match_%{_match_idx}%::winner}

                    set {_p1_name} to "(BYE)"
                    if {_p1_uuid} is set:
                        set {_p1_name} to name of {_p1_uuid} parsed as offline player
                    set {_p2_name} to "(BYE)"
                    if {_p2_uuid} is set:
                        set {_p2_name} to name of {_p2_uuid} parsed as offline player
                    
                    set {_match_display} to "&e    Match %{_match_idx}%: &f%{_p1_name}% &evs &f%{_p2_name}%"
                    if {_status} is "running":
                        set {_match_display} to "%{_match_display}% &7(&cRunning&7)"
                    else if {_status} is "finished" or {_status} is "finished_bye":
                        set {_winner_name} to name of {_winner_uuid} parsed as offline player if {_winner_uuid} is set else "N/A"
                        set {_match_display} to "&e    Match %{_match_idx}%: &f%{_p1_name}% &evs &f%{_p2_name}% &7(&aWinner: %{_winner_name}%&7)"
                        if {_p2_uuid} is not set and {_status} is "finished_bye":
                            set {_match_display} to "&e    Match %{_match_idx}%: &f%{_p1_name}% &7(BYE - Auto-advances)"
                    else if {_status} is "pending":
                        set {_match_display} to "%{_match_display}% &7(&6Pending&7)"
                    send "  %{_match_display}%"
                if {_any_match_in_round} is false and {_round_num} <= ({tournament::%{_id}%::current_round} ? 0) and {tournament::%{_id}%::status} is not "finished":
                    send "&7    (Waiting for matches to be generated or round to start)"
            
            if {tournament::%{_id}%::status} is "finished":
                set {_winner_name} to name of {tournament::%{_id}%::winner} parsed as offline player if {tournament::%{_id}%::winner} is set else "N/A"
                send "&6&lTournament Winner: &e&l%{_winner_name}%"
        
        else if arg-1 is "spectate":
            # Conceptual: /tournament spectate <match_id_from_bracket_display>
            # This would require integration with racing.sk to allow spectating ongoing races.
            send "{@prefix} &cSpectating tournament matches is not yet implemented." to player

        else:
            send "{@prefix} &cUsage: /tournament [help|join|leave|info|bracket|spectate <match_id>]" to player

# --- Tournament Logic Functions ---

# Function to give tournament rewards
function giveTournamentRewards(id: text, winner: text):
    set {_uuid} to {_winner}
    
    # Give ClickCoins
    add 100000 to {player::%{_uuid}%::clickcoins}
    
    # Give prestige points
    add 1000 to {player::%{_uuid}%::prestige_points}
    
    # Give special tournament title
    set {player::%{_uuid}%::tournament_titles::*} to {player::%{_uuid}%::tournament_titles::*} + ["Tournament Champion"]
    
    # Give tournament medal
    give tournament_medal to {_winner}

# Function to generate tournament brackets
function generateTournamentBrackets(id: text):
    set {_id} to {_id}
    set {_players} to {tournament::%{_id}%::players::*}
    set {_size} to size of {_players}
    
    # Check if we have a valid number of players
    if {_size} is not power of 2:
        set {tournament::%{_id}%::status} to "error_generating_brackets"
        return
    
    # Initialize bracket structure
    set {_rounds} to log({_size}) / log(2)
    set {_current_round} to 1
    
    # Create first round matches
    set {_index} to 1
    loop {_players}:
        set {_player1} to loop-value
        if {_index} % 2 = 0:
            set {_player2} to loop-value
            set {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%{(_index / 2)}%::player1} to {_player1}
            set {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%{(_index / 2)}%::player2} to {_player2}
            set {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%{(_index / 2)}%::winner} to null
        
        add 1 to {_index}
    
    # Set tournament status to ready for matches
    set {tournament::%{_id}%::status} to "ready_for_matches"

function generateTournamentBrackets(id: text):
    clear {tournament::%{_id}%::bracket::*}
    set {_player_uuids::*} to {tournament::%{_id}%::players::*}
    
    # Ensure player count is a power of 2 for a simple elimination bracket, or handle byes
    # For simplicity, we'll proceed if we have at least min_players. More complex logic needed for byes.
    if size of {_player_uuids::*} < {tournament::%{_id}%::settings::min_players}:
        send debug "[Tournament] Error: Not enough players for bracket generation in %{_id}%."
        set {tournament::%{_id}%::status} to "error_generating_brackets"
        return

    # Shuffle players
    set {_shuffled_players::*} to {_player_uuids::*}
    # Basic Fisher-Yates shuffle (Skript version)
    loop (size of {_shuffled_players::*}) times:
        set {_i} to (size of {_shuffled_players::*}) - loop-number + 1
        set {_j} to random integer between 1 and {_i}
        set {_temp} to {_shuffled_players::%{_i}%}
        set {_shuffled_players::%{_i}%} to {_shuffled_players::%{_j}%}
        set {_shuffled_players::%{_j}%} to {_temp}

    # Create round 1 matches
    set {_match_num} to 1
    set {_round} to 1
    loop {_shuffled_players::*}:
        if loop-index is odd:
            set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::player1} to loop-value
            set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::status} to "pending"
        else:
            set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::player2} to loop-value
            # If odd number of players, last player gets a bye (auto-win for this match)
            # This simple implementation doesn't handle byes gracefully across rounds yet.
            # For now, if player2 is not set, player1 advances.
            if {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::player2} is not set:
                set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::winner} to {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::player1}
                set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::status} to "finished_bye"
                send debug "[Tournament] %{_id}%: %{tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::player1}% gets a bye in round 1."
            add 1 to {_match_num}
    
    set {tournament::%{_id}%::total_initial_matches} to {_match_num} - 1
    send debug "[Tournament] Generated %{_match_num}-1% matches for round 1 of %{_id}%."

function startNextTournamentRound(id: text):
    # Determine current round and find matches to start.
    # This would involve:
    # 1. Checking which round is active or which was last completed.
    # 2. Finding all matches for the current round that haven't been played.
    # 3. For each match, start a race between the two players (using racing.sk functions).
    #    - This means multiple races might run simultaneously if the server can handle it.
    #    - Need a way to track when a tournament race finishes and who won.
    #    - The winner progresses in the {tournament::%{_id}%::bracket::...} variables.
    send debug "[Tournament] Attempting to start/progress round for %{_id}%."
    set {_current_round} to {tournament::%{_id}%::current_round} ? 1

    # Check if all matches in the current round are finished
    set {_all_matches_finished_this_round} to true
    set {_matches_in_current_round} to 0
    loop {tournament::%{_id}%::bracket::round_%{_current_round}%::match_::*}:
        add 1 to {_matches_in_current_round}
        if {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::status} is "pending" or {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::status} is "running":
            set {_all_matches_finished_this_round} to false
            # Start pending matches
            if {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::status} is "pending":
                set {_p1_uuid} to {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::player1}
                set {_p2_uuid} to {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::player2}
                if {_p1_uuid} is set and {_p2_uuid} is set:
                    send debug "[Tournament] Starting match %loop-index% of round %{_current_round}%: %name of {_p1_uuid} parsed as offline player% vs %name of {_p2_uuid} parsed as offline player%"
                    # TODO: Integrate with racing.sk to start the actual race
                    # This would involve calling a function in racing.sk, e.g.:
                    # callFunction "startRace" with arguments {_p1_uuid}, {_p2_uuid}, {tournament::%{_id}%::settings::track_id}, "tournament", {_id}, {_current_round}, loop-index
                    # For now, we simulate a race start and will need a way to report back results.
                    set {tournament::%{_id}%::bracket::round_%{_current_round}%::match_%loop-index%::status} to "running"
                    broadcast "{@prefix} &eTournament Match Starting on track '%{tournament::%{_id}%::settings::track_id}%': %name of {_p1_uuid} parsed as offline player% vs %name of {_p2_uuid} parsed as offline player%!"
                else if {_p1_uuid} is set and {_p2_uuid} is not set: # Bye already handled
                    pass 
                else:
                    send debug "[Tournament] Error: Players not set for match %loop-index% round %{_current_round}%."
    
    if {_matches_in_current_round} is 0 and {_current_round} is 1: # No matches generated for round 1 (e.g. only 1 player)
        send debug "[Tournament] Not enough matches to start round 1 for %{_id}%."
        # TODO: Handle this scenario, maybe declare winner if only one player signed up and met min requirements
        if size of {tournament::%{_id}%::players::*} is 1:
            set {_winner_uuid} to {tournament::%{_id}%::players::1}
            declareTournamentWinner({_id}, {_winner_uuid})
        else:
            set {tournament::%{_id}%::status} to "error_no_matches"
        return

    if {_all_matches_finished_this_round} is true:
        send debug "[Tournament] All matches in round %{_current_round}% finished for %{_id}%."
        # Check if this was the final round (only one match)
        if {_matches_in_current_round} is 1:
            set {_final_winner_uuid} to {tournament::%{_id}%::bracket::round_%{_current_round}%::match_1::winner}
            if {_final_winner_uuid} is set:
                declareTournamentWinner({_id}, {_final_winner_uuid})
                return
            else:
                send debug "[Tournament] Error: Final match winner not recorded for %{_id}%."
                # Potentially try to find winner if only one player left in bracket logic
                return

        # Proceed to next round
        set {_next_round} to {_current_round} + 1
        generateNextRoundMatches({_id}, {_current_round}, {_next_round})
        set {tournament::%{_id}%::current_round} to {_next_round}
        send debug "[Tournament] Advanced to round %{_next_round}% for %{_id}%."
        # Recursively call to start matches of the new round
        startNextTournamentRound({_id})
    else:
        send debug "[Tournament] Round %{_current_round}% for %{_id}% is still in progress or starting matches."

# When a tournament race (part of a match) finishes, racing.sk should call a function here:
function recordTournamentMatchResult(id: text, round: number, match_num: number, winner_uuid: text):
    set {tournament::%{_id}%::bracket::round_%{_round}%::match_%{_match_num}%::winner} to {_winner_uuid}
    send debug "[Tournament] Match %{_match_num}% of round %{_round}% in %{_id}% won by %name of {_winner_uuid} parsed as offline player%"
        # Check if all matches in this round are complete.
    send debug "[Tournament] Match result recorded. Checking round status for %{_id}%."
    startNextTournamentRound({_id}) # This will check and advance if ready

function generateNextRoundMatches(id: text, completed_round: number, next_round: number):
    send debug "[Tournament] Generating matches for round %{_next_round}% of %{_id}% from winners of round %{_completed_round}%."
    clear {tournament::%{_id}%::bracket::round_%{_next_round}%::*}
    set {_winners_this_round::*} to all indices of {tournament::%{_id}%::bracket::round_%{_completed_round}%::match_::*}
    set {_advancing_players::*}
    loop {_winners_this_round::*}:
        set {_match_idx} to loop-value
        set {_winner_uuid} to {tournament::%{_id}%::bracket::round_%{_completed_round}%::match_%{_match_idx}%::winner}
        if {_winner_uuid} is set:
            add {_winner_uuid} to {_advancing_players::*}
        else:
            send debug "[Tournament] Warning: Winner not found for round %{_completed_round}% match %{_match_idx}% in %{_id}%."

    if size of {_advancing_players::*} is 0:
        send debug "[Tournament] Error: No players advanced to round %{_next_round}% for %{_id}%."
        # This could mean an issue or the tournament ended prematurely.
        # Consider if there's a single overall winner if only one player was left from previous logic.
        return
    if size of {_advancing_players::*} is 1:
        send debug "[Tournament] Only one player advanced. %{_advancing_players::1}% is the winner of %{_id}% by default."
        declareTournamentWinner({_id}, {_advancing_players::1})
        return

    # Shuffle advancing players (optional, but good for fairness if pairings are static)
    # For simplicity, we'll pair them in order of their previous match indices for now.
    set {_match_num_next_round} to 1
    loop {_advancing_players::*}:
        if loop-index is odd:
            set {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::player1} to loop-value
            set {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::status} to "pending"
        else:
            set {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::player2} to loop-value
            if {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::player2} is not set: # Should not happen if even number of winners
                set {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::winner} to {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::player1}
                set {tournament::%{_id}%::bracket::round_%{_next_round}%::match_%{_match_num_next_round}%::status} to "finished_bye"
            add 1 to {_match_num_next_round}
    send debug "[Tournament] Generated %{_match_num_next_round}-1% matches for round %{_next_round}% of %{_id}%."

function declareTournamentWinner(id: text, winner_uuid: text):
    set {tournament::%{_id}%::status} to "finished"
    set {tournament::%{_id}%::winner} to {_winner_uuid}
    set {_winner_name} to name of {_winner_uuid} parsed as offline player
    broadcast "{@prefix} &6&lTournament '%{_id}%' Concluded! Winner: &e&l%{_winner_name}%&6&l!"
    send debug "[Tournament] %{_winner_name}% declared winner of %{_id}%."
    # TODO: Distribute prizes based on {tournament::%{_id}%::settings::rewards::winner}
    # Example: 
    # if {tournament::%{_id}%::settings::rewards::winner} is set:
    #     execute console command replace "<player>" with "%{_winner_name}%" in {tournament::%{_id}%::settings::rewards::winner}
    #     send "{@prefix} &aYou have received rewards for winning the tournament!" to {_winner_uuid} parsed as player
    
    # TODO: Clean up tournament data (or mark for cleanup)
    # For now, we'll clear the current tournament ID to allow a new one to be made.
    delete {tournament::current::id}
    send debug "[Tournament] Tournament %{_id}% finished. {tournament::current::id} cleared."

# --- Seasonal Competitions (Conceptual) ---
# This would be a layer on top of the tournament system, or a separate event system.
# - Monthly championship events: Could use the tournament system with special announcements/rewards.
# - Special reward tracks: Tracks could be flagged as "seasonal" or part of an event.
# - Limited-time upgrade opportunities: Could be temporary items in shop.sk or special event vendors.

# Example: Announce a seasonal event
# on load:
#    if today is between "01/12" and "31/12": # Crude date check for December
#        set {event::christmas::active} to true
#        broadcast "{@prefix} &c&lIt's Christmas time! Special events and rewards are active!"

# This is a very high-level overview. Tournament systems are one of the most complex features
# to implement in Skript due to data management, state tracking, and race coordination.
# Addons or a more robust database backend would be highly beneficial for this.
# File: leaderboards.sk
# Path: race-clicker/gui/leaderboards.sk
# Description: Ranking systems for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    leaderboardSize: 10 # Number of players to show on leaderboards
    leaderboardRefreshRate: 300 # Seconds (5 minutes)
    leaderboardTypes: "clicks", "races_won", "prestige_level"

# Initialize leaderboard variables on script load
on load:
    loop {@leaderboardTypes}:
        set {_type} to loop-value
        loop {@leaderboardSize} times:
            delete {leaderboard::%{_type}%::top::%loop-number-1%::uuid}
            delete {leaderboard::%{_type}%::top::%loop-number-1%::value}
            delete {leaderboard::%{_type}%::top::%loop-number-1%::name}
    broadcast "&7[Debug] Leaderboard variables initialized."
    # Initial population can be slow, consider doing it async or on first request if performance is an issue
    # For now, let's schedule a refresh shortly after load
    wait 10 seconds
    refreshAllLeaderboards()

# Command to open the leaderboards GUI
command /leaderboard [<text>]:
    aliases: /lb, /top, /rcleaderboard
    trigger:
        set {_type} to arg-1 ? "clicks"
        if {_type} is not "clicks" and {_type} is not "races_won" and {_type} is not "prestige_level":
            send "{@prefix} &cInvalid leaderboard type. Available: clicks, races_won, prestige_level." to player
            stop
        openLeaderboardGUI(player, {_type})

# Function to open the leaderboard GUI
function openLeaderboardGUI(p: player, type: text):
    set {_gui_title} to "&8&nLeaderboard - %capitalize({_type})%"
    replace all "_" with " " in {_gui_title}
    create a gui with virtual chest inventory with 6 rows named {_gui_title}:
        # Display top players
        loop {@leaderboardSize} times:
            set {_rank} to loop-number
            set {_slot} to 9 + (floor((_rank - 1) / 7)) * 9 + ((_rank - 1) mod 7) + 1 # Center items a bit
            if {_rank} > 7:
                set {_slot} = {_slot} + 2 # Shift second row of items
            if {_rank} > 14:
                set {_slot} = {_slot} + 2 # Shift third row if we had more items
            
            # Create item for this rank
            set {_player_uuid} to {leaderboard::%{_type}%::top::%{_rank}%::uuid}
            set {_player_value} to {leaderboard::%{_type}%::top::%{_rank}%::value}
            set {_player_name} to {leaderboard::%{_type}%::top::%{_rank}%::name}

            if {_player_uuid} is set and {_player_value} is set and {_player_name} is set:
                make gui slot {_slot} with player head of ({_player_uuid} parsed as offline player) named "&a&l#%{_rank}% %{_player_name}%" with lore "&7%capitalize({_type})%: &e%{_player_value}%"
            else:
                make gui slot {_slot} with barrier named "&c&l#%{_rank}%" with lore "&7No player data"

        # Sorting options
        make gui slot 48 with paper named "&eSort by Clicks" with lore "&7View top players by Clicks" to run function openLeaderboardGUI({_p}, "clicks")
        make gui slot 49 with emerald named "&eSort by Races Won" with lore "&7View top players by Races Won" to run function openLeaderboardGUI({_p}, "races_won")
        make gui slot 50 with nether star named "&eSort by Prestige Level" with lore "&7View top players by Prestige Level" to run function openLeaderboardGUI({_p}, "prestige_level")

        # Refresh button
        make gui slot 53 with clock named "&6Refresh Leaderboard" with lore "&7Click to manually update this view." to run function refreshAndReopenLeaderboard({_p}, {_type})

        # Fill border
        loop 54 times:
            set {_slot_index} to loop-number - 1
            if gui slot {_slot_index} is not set:
                if {_slot_index} < 9 or {_slot_index} > 44 or {_slot_index} mod 9 is 0 or {_slot_index} mod 9 is 8:
                    make gui slot {_slot_index} with gray stained glass pane named " "
    open last gui to {_p}

function refreshAndReopenLeaderboard(p: player, type: text):
    send "{@prefix} &7Refreshing leaderboard data..." to {_p}
    refreshLeaderboardData({_type}) # Refresh specific leaderboard
    wait 1 tick # Allow refresh to process
    openLeaderboardGUI({_p}, {_type})

# --- Leaderboard Data Management ---

# Function to update a player's score for a specific leaderboard type
# This should be called by other scripts when relevant data changes
# e.g., from clicking.sk for clicks, racing.sk for races_won, prestige.sk for prestige_level
function updatePlayerLeaderboardScore(p: player, type: text, value: number):
    if {_type} is not an element of {@leaderboardTypes}:
        send debug "&c[Leaderboard] Attempted to update invalid leaderboard type: %{_type}%"
        stop

    set {_uuid} to {_p}'s uuid
    set {_name} to name of {_p}

    # This is a simplified update. For true sorted insertion, it's more complex.
    # We'll rely on the periodic refresh to sort properly.
    # For now, just store the player's latest value for potential use in refresh.
    set {playerdata::%{_uuid}%::leaderboard::%{_type}%} to {_value}
    set {playerdata::%{_uuid}%::name} to {_name} # Keep name updated

    # Trigger a refresh for this specific leaderboard type if the value might be a new top score
    # This is a heuristic. A full check is done by refreshLeaderboardData.
    set {_current_lowest_top_score} to {leaderboard::%{_type}%::top::%{@leaderboardSize}%::value} ? 0
    if {_value} > {_current_lowest_top_score}:
        refreshLeaderboardData({_type})

# Periodically refresh all leaderboards
every {@leaderboardRefreshRate} seconds:
    refreshAllLeaderboards()

function refreshAllLeaderboards():
    # send debug "&7[Leaderboard] Starting periodic refresh of all leaderboards..."
    loop {@leaderboardTypes}:
        refreshLeaderboardData(loop-value)
    # send debug "&a[Leaderboard] All leaderboards refreshed."

# Core function to refresh a specific leaderboard type
function refreshLeaderboardData(type: text):
    # send debug "&7[Leaderboard] Refreshing leaderboard: %{_type}%..."
    # 1. Collect all relevant player data
    # This is the hardest part in Skript without database/YAML addons for *all* server players.
    # We will iterate known players who have data for this type.
    # This assumes {playerdata::UUID::leaderboard::TYPE} and {playerdata::UUID::name} are populated elsewhere.

    delete {_all_scores::*}
    loop all players:
        set {_uuid} to loop-player's uuid
        if {playerdata::%{_uuid}%::leaderboard::%{_type}%} is set:
            set {_all_scores::%{_uuid}%::value} to {playerdata::%{_uuid}%::leaderboard::%{_type}%}
            set {_all_scores::%{_uuid}%::name} to {playerdata::%{_uuid}%::name} ? name of loop-player
    
    # If you have a list of all player UUIDs that ever joined (e.g. {all_player_uuids::*}):
    # loop {all_player_uuids::*}:
    #     set {_uuid} to loop-value
    #     if {playerdata::%{_uuid}%::leaderboard::%{_type}%} is set:
    #         set {_all_scores::%{_uuid}%::value} to {playerdata::%{_uuid}%::leaderboard::%{_type}%}
    #         set {_all_scores::%{_uuid}%::name} to {playerdata::%{_uuid}%::name}

    # 2. Sort the data (simple bubble sort for demonstration, can be slow for many players)
    set {_sorted_uuids::*} to indices of {_all_scores::*}
    set {_size} to size of {_sorted_uuids::*}
    if {_size} < 1:
        # send debug "&e[Leaderboard] No data to sort for %{_type}%."
        # Clear existing top list for this type
        loop {@leaderboardSize} times:
            delete {leaderboard::%{_type}%::top::%loop-number%::uuid}
            delete {leaderboard::%{_type}%::top::%loop-number%::value}
            delete {leaderboard::%{_type}%::top::%loop-number%::name}
        stop

    loop {_size} times:
        set {_swapped} to false
        loop ({_size} - loop-value-1) times:
            set {_idx1} to loop-value-2 # current index in _sorted_uuids
            set {_idx2} to loop-value-1 # next index in _sorted_uuids
            set {_uuid1} to {_sorted_uuids::%{_idx1}%}
            set {_uuid2} to {_sorted_uuids::%{_idx2}%}
            if {_all_scores::%{_uuid1}%::value} < {_all_scores::%{_uuid2}%::value}: # Sort descending
                set {_temp_uuid} to {_sorted_uuids::%{_idx1}%}
                set {_sorted_uuids::%{_idx1}%} to {_sorted_uuids::%{_idx2}%}
                set {_sorted_uuids::%{_idx2}%} to {_temp_uuid}
                set {_swapped} to true
        if not {_swapped}:
            break

    # 3. Store the top N players
    loop {@leaderboardSize} times:
        set {_rank} to loop-number
        if {_sorted_uuids::%{_rank}%} is set:
            set {_top_uuid} to {_sorted_uuids::%{_rank}%}
            set {leaderboard::%{_type}%::top::%{_rank}%::uuid} to {_top_uuid}
            set {leaderboard::%{_type}%::top::%{_rank}%::value} to {_all_scores::%{_top_uuid}%::value}
            set {leaderboard::%{_type}%::top::%{_rank}%::name} to {_all_scores::%{_top_uuid}%::name}
        else:
            delete {leaderboard::%{_type}%::top::%{_rank}%::uuid}
            delete {leaderboard::%{_type}%::top::%{_rank}%::value}
            delete {leaderboard::%{_type}%::top::%{_rank}%::name}
    # send debug "&a[Leaderboard] Finished refreshing %{_type}%."

# Admin command to manually refresh leaderboards
command /rclbadmin <text>:
    permission: raceclicker.admin
    trigger:
        if arg-1 is "refreshall":
            send "{@prefix} &7Manually refreshing all leaderboards..." to sender
            refreshAllLeaderboards()
            send "{@prefix} &aAll leaderboards refreshed." to sender
        else if arg-1 is "refresh":
            if arg-2 is not set:
                send "{@prefix} &cUsage: /rclbadmin refresh <type>" to sender
                stop
            if arg-2 is not an element of {@leaderboardTypes}:
                send "{@prefix} &cInvalid leaderboard type. Available: %{@leaderboardTypes}%" to sender
                stop
            send "{@prefix} &7Manually refreshing %arg-2% leaderboard..." to sender
            refreshLeaderboardData(arg-2)
            send "{@prefix} &a%arg-2% leaderboard refreshed." to sender
        else if arg-1 is "testupdate": # For debugging
            if player is not set:
                send "{@prefix} &cThis command must be run by a player." to sender
                stop
            set {_random_score} to random integer between 100 and 10000
            updatePlayerLeaderboardScore(player, "clicks", {_random_score})
            send "{@prefix} &7Updated your 'clicks' score to %{_random_score}% for testing." to player

# Note on Player Heads:
# `player head of ({_uuid} parsed as offline player)` should work for displaying heads if the server
# can resolve the UUID to a skin. Ensure player data like names are stored/updated correctly.

# TODO: For a production server with many players, this Skript-native sorting can be very slow.
# Consider using Skript addons like Skript-YAML with custom sorting functions or Skript-DB (e.g., SQLite)
# for more efficient data storage and querying (ORDER BY clauses).
# TODO: The current refreshLeaderboardData only considers online players or those explicitly in {playerdata::*}.
# A robust system would need a list of all UUIDs that have ever played and have relevant data.
# This could be maintained in data.sk or by iterating player save files (if accessible and performant, usually not recommended directly from Skript).
# File: race_selection.sk
# Description: Race selection GUI for players to choose tracks

options:
    prefix: &6&lRaceClicker &8»
    gui_rows: 3
    min_players_to_start: 2 # Default minimum players to start a race
    
# Variables:
# {gui::race_selection::*} - List of available tracks in GUI

# Command to open race selection GUI
command /races:
    aliases: /tracks
    trigger:
        openRaceSelectionGUI(player)

# Function to open race selection GUI
function openRaceSelectionGUI(p: player):
    set {_uuid} to {_p}'s uuid
    
    # Get list of available tracks
    set {_tracks} to all keys of {tracks::*}
    if size of {_tracks} < 1:
        send "{@prefix} &cNo tracks available yet!" to {_p}
        stop
    
    # Sort tracks by difficulty
    set {_sorted_tracks::*} to []
    loop {_tracks}:
        set {_track_id} to loop-value
        set {_difficulty} to {tracks::%{_track_id}%::difficulty} ? 1
        add {_track_id} to {_sorted_tracks::*} sorted by {_difficulty}
    
    # Create GUI
    create a gui with virtual chest inventory with {%gui_rows%} rows named "&8&nRace Selection"
    
    # Add decorative items
    loop 27 times:
        if loop-number - 1 is 0 or 1 or 2 or 3 or 4 or 5 or 6 or 7 or 8 or 9 or 17 or 18 or 19 or 20 or 21 or 23 or 24 or 25 or 26:
            if gui-inventory is not set for slot (loop-number - 1) of current gui:
                make gui slot (loop-number - 1) with gray stained glass pane named " "
    
    # Add track selection buttons
    set {_slot} to 10
    loop {_sorted_tracks::*}:
        if loop-index > 9: # Only show first 9 tracks in GUI
            continue
            
        set {_track_id} to loop-value
        set {_track_name} to {tracks::%{_track_id}%::name}
        set {_track_length} to {tracks::%{_track_id}%::length}
        set {_difficulty} to {tracks::%{_track_id}%::difficulty} ? 1
        
        # Get player's best time for this track
        set {_best_time} to {player::%{_uuid}%::stats::best_times::%{_track_id}%}
        if {_best_time} is not set:
            set {_best_time} to "-"
        else:
            set {_best_time} to formatTimespan({_best_time})
            
        # Get track status
        set {_status} to "&aAvailable"
        if {track::%{_track_id}%::locked} is true:
            set {_status} to "&cLocked"
        else if {track::%{_track_id}%::maintenance} is true:
            set {_status} to "&eMaintenance"
        
        # Create track item
        if {_status} is "&aAvailable":
            make gui slot {_slot} with emerald block named "&a%{_track_name}%" with lore "&7Length: &e%{_track_length}% blocks" and "&7Difficulty: &e%{_difficulty}%" and "&7Best Time: &e%{_best_time}%" and "&7Status: %{_status}%" and "" and "&eClick to join race!" to run function joinRace({_p}, {_track_id})
        else:
            make gui slot {_slot} with gray stained glass pane named "&7%{_track_name}%" with lore "&7Length: &e%{_track_length}% blocks" and "&7Difficulty: &e%{_difficulty}%" and "&7Best Time: &e%{_best_time}%" and "&7Status: %{_status}%" and "" and "&cTrack Unavailable"
        
        add 1 to {_slot}
        
        # Add separator after every 3 tracks
        if loop-index % 3 = 0:
            make gui slot {_slot} with gray stained glass pane named " "
            add 1 to {_slot}
    
    # Add back button
    make gui slot 26 with red stained glass pane named "&cBack" to run function closeGUI({_p})
    
    open last gui to {_p}

# Function to handle track selection
function joinRace(p: player, track_id: text):
    set {_uuid} to {_p}'s uuid
    
    # Check if player is already in a race
    if {player::%{_uuid}%::in_race} is true:
        send "{@prefix} &cYou're already in a race!" to {_p}
        return
    
    # Check if track exists and is available
    if {tracks::%{_track_id}%::name} is not set:
        send "{@prefix} &cTrack %{_track_id}% not found!" to {_p}
        return
    if {track::%{_track_id}%::locked} is true:
        send "{@prefix} &cThis track is currently locked!" to {_p}
        return
    if {track::%{_track_id}%::maintenance} is true:
        send "{@prefix} &eThis track is under maintenance!" to {_p}
        return
    
    # Check player requirements
    set {_difficulty} to {tracks::%{_track_id}%::difficulty} ? 1
    if {_difficulty} > {player::%{_uuid}%::max_difficulty}:
        send "{@prefix} &cYou need to reach difficulty level %{_difficulty}% to access this track!" to {_p}
        return
    
    # Check race cooldown
    if {player::%{_uuid}%::last_race} is set:
        set {_last_race} to {player::%{_uuid}%::last_race}
        set {_cooldown} to 300 # 5 minutes cooldown
        if now - {_last_race} < {_cooldown}:
            set {_remaining} to {_cooldown} - (now - {_last_race})
            send "{@prefix} &cYou must wait %{formatTimespan({_remaining})}% before joining another race!" to {_p}
            return
    
    # Add player to race
    add {_p} to {race::players::*}
    set {player::%{_uuid}%::current_track_id} to {_track_id}
    set {player::%{_uuid}%::in_race} to true
    set {player::%{_uuid}%::last_race} to now
    
    # Create citizen for race
    create new citizen named "RaceCitizen_%{_uuid}_%{_track_id}%" at {tracks::%{_track_id}%::start_location}
    set {player::%{_uuid}%::race_citizen_entity_id} to last created citizen's uuid
    
    # Enable race camera
    enableRaceCamera({_p}, entity from uuid {player::%{_uuid}%::race_citizen_entity_id})
    
    # Start countdown if enough players
    if size({race::players::*}) >= {@min_players_to_start}:
        startRaceCountdown({_track_id})
    else:
        set {_player_count} to size({race::players::*})
        send "{@prefix} &aWaiting for more players... (%{_player_count}%/%{@min_players_to_start}%)
        send "{@prefix} &7Track: %{_track_name}% &7| Difficulty: %{_difficulty}%" to {_p}

# Function to close GUI
function closeGUI(p: player):
    close inventory of {_p}
    send "{@prefix} &aClosed race selection menu." to {_p}
# File: shop.sk
# Path: race-clicker/gui/shop.sk
# Description: Upgrade shop interface

options:
    prefix: &6&lRaceClicker &8»
    speedUpgradeBaseCost: 100
    speedUpgradeCostMultiplier: 1.5 # Cost increases by 50% each level
    autoclickerUpgradeBaseCost: 250
    autoclickerUpgradeCostMultiplier: 1.75 # Cost increases by 75% each level
    autoclickerClicksPerLevel: 1

# Command to open the shop
command /shop:
    aliases: /upgrades, /rcshop
    trigger:
        openUpgradeShop(player)

# Function to calculate speed upgrade cost
function calculateSpeedCost(level: number) :: number:
    return floor({@speedUpgradeBaseCost} * ({@speedUpgradeCostMultiplier}^{_level}))

# Function to calculate auto-clicker upgrade cost
function calculateAutoClickerCost(level: number) :: number:
    return floor({@autoclickerUpgradeBaseCost} * ({@autoclickerUpgradeCostMultiplier}^{_level}))

# Function to open the main upgrade shop GUI
function openUpgradeShop(p: player):
    set {_uuid} to {_p}'s uuid
    create a gui with virtual chest inventory with 3 rows named "&8&nRace Upgrades":
        # Decorative items
        loop 27 times:
            if loop-number - 1 is 0 or 1 or 2 or 3 or 4 or 5 or 6 or 7 or 8 or 9 or 17 or 18 or 19 or 20 or 21 or 23 or 24 or 25 or 26:
                if gui-inventory is not set for slot (loop-number - 1) of current gui:
                    make gui slot (loop-number - 1) with gray stained glass pane named " "

        # Speed Upgrade
        set {_speed_level} to {player::%{_uuid}%::speed-level} ? 0
        set {_speed_cost} to calculateSpeedCost({_speed_level})
        make gui slot 10 with lime stained clay named "&a&lSpeed Upgrade" with lore "&7Increases your click power per click." and "" and "&7Current Level: &e%{player::%{_uuid}%::speed-level}%" and "&7Next Level Cost: &c%{_speed_cost}% clicks" and "" and "&eClick to purchase!" to run function purchaseSpeedUpgrade({_p}, {_speed_cost})

        # Auto-Clicker Upgrade
        set {_autoclicker_level} to {player::%{_uuid}%::autoclicker-level} ? 0
        set {_autoclicker_cost} to calculateAutoClickerCost({_autoclicker_level})
        set {_clicks_per_sec} to {_autoclicker_level} * {@autoclickerClicksPerLevel}
        set {_next_clicks_per_sec} to ({_autoclicker_level} + 1) * {@autoclickerClicksPerLevel}
        make gui slot 14 with light blue stained clay named "&b&lAuto-Clicker Upgrade" with lore "&7Automatically clicks for you over time." and "" and "&7Current Level: &e%{player::%{_uuid}%::autoclicker-level}%" and "&7Current Clicks/sec: &e%{_clicks_per_sec}%" and "&7Next Level Clicks/sec: &e%{_next_clicks_per_sec}%" and "&7Next Level Cost: &c%{_autoclicker_cost}% clicks" and "" and "&eClick to purchase!" to run function purchaseAutoClickerUpgrade({_p}, {_autoclicker_cost})

        # Prestige Option
        # TODO: Add more detailed prestige eligibility check (e.g., minimum level for some upgrades)
        set {_prestige_points_on_prestige} to {player::%{_uuid}%::prestige-points-on-prestige} ? 0 # This should be calculated in prestige.sk
        make gui slot 22 with nether star named "&d&lPrestige" with lore "&7Reset progress for powerful bonuses!" and "&7You will gain ~%{_prestige_points_on_prestige}% Prestige Points." and "" and "&eClick to learn more!" to run function openPrestigeConfirmationGUI({_p}) # Calls function from prestige.sk

    open last gui to {_p}

# Function to handle speed upgrade purchase
function purchaseSpeedUpgrade(p: player, cost: number):
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::clicks} >= {_cost}:
        subtract {_cost} from {player::%{_uuid}%::clicks}
        add 1 to {player::%{_uuid}%::speed-level}
        send "{@prefix} &aSuccessfully upgraded speed to level %{player::%{_uuid}%::speed-level}%!" to {_p}
        play sound "minecraft:entity.experience_orb.pickup" to {_p} with volume 1 pitch 1.5
        # Particle effect at player's location
        spawn 10 of particle crit at location of {_p} offset by vector(0, 1, 0) # Spawn slightly above feet
        openUpgradeShop({_p}) # Re-open to show updated values and costs
    else:
        send "{@prefix} &cNot enough clicks! You need %{_cost}% clicks." to {_p}
        play sound "minecraft:entity.villager.no" to {_p} with volume 1 pitch 1

# Function to handle auto-clicker upgrade purchase
function purchaseAutoClickerUpgrade(p: player, cost: number):
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::clicks} >= {_cost}:
        subtract {_cost} from {player::%{_uuid}%::clicks}
        add 1 to {player::%{_uuid}%::autoclicker-level}
        send "{@prefix} &aSuccessfully upgraded auto-clicker to level %{player::%{_uuid}%::autoclicker-level}%!" to {_p}
        play sound "minecraft:entity.experience_orb.pickup" to {_p} with volume 1 pitch 1.5
        spawn 10 of particle villager happy at location of {_p} offset by vector(0, 1, 0) # Spawn slightly above feet
        openUpgradeShop({_p}) # Re-open
    else:
        send "{@prefix} &cNot enough clicks! You need %{_cost}% clicks." to {_p}
        play sound "minecraft:entity.villager.no" to {_p} with volume 1 pitch 1

# Note: openPrestigeConfirmationGUI is defined in features/prestige.sk
# The call in openUpgradeShop now correctly points to it.

# --- Phase 7: Optimize Skript Performance ---
# Optimize GUI updates
# - GUI is re-opened on purchase, which is a common and acceptable way in Skript for updates.
# - Caching GUI layouts: Skript's GUI creation is generally efficient for this scale.
#   Further optimization here might be over-engineering unless performance issues are observed.
# - Minimized inventory recreations: Achieved by functions like openUpgradeShop refreshing the view.

# TODO: Add upgrade preview system (e.g., show next level's benefit more clearly if complex)
# TODO: Consider adding a 'max buy' option for upgrades.
# File: stats.sk
# Path: race-clicker/gui/stats.sk
# Description: Statistics displays

options:
    prefix: &6&lRaceClicker &8» # Example prefix

# --- Phase 3: Complete GUI Systems ---
# Create Additional GUI Menus
# - TODO: Statistics GUI with visual elements
#   - Achievement progress bars (integrates with achievements.sk)
#   - Performance graphs (using item displays - advanced)
#   - Comparison with server averages (requires global data tracking)

# Command to open the statistics GUI
command /stats:
    aliases: /rcstats, /profil
    trigger:
        openStatsGUI(player)

function openStatsGUI(p: player):
    create a gui with virtual chest inventory with 4 rows named "&8&nPlayer Statistics":
        # Fetch player data (examples, ensure these are set in data.sk)
        set {_clicks} to {player::%{_p}'s uuid%::clicks} ? 0
        set {_speed_level} to {player::%{_p}'s uuid%::speed-level} ? 1
        set {_autoclicker_level} to {player::%{_p}'s uuid%::autoclicker-level} ? 0
        set {_prestige_level} to {player::%{_p}'s uuid%::prestige-level} ? 0
        set {_races_won} to {player::%{_p}'s uuid%::stats::races_won} ? 0

        # Display stats
        make gui slot 10 with paper named "&a&lTotal Clicks" with lore "&7You have accumulated: &e%{_clicks}% clicks."
        make gui slot 12 with iron boots named "&b&lSpeed Level" with lore "&7Your current speed level: &e%{_speed_level}%."
        make gui slot 14 with clock named "&c&lAuto-Clicker Level" with lore "&7Your auto-clicker level: &e%{_autoclicker_level}%."
        make gui slot 16 with nether star named "&d&lPrestige Level" with lore "&7Your prestige level: &e%{_prestige_level}%."

        make gui slot 20 with emerald named "&2&lRaces Won" with lore "&7Total races won: &e%{_races_won}%."

        # TODO: Achievement Progress Bar (Conceptual)
        # Example: Calculate completed / total achievements
        # set {_achievements_completed} to size of {player::%{_p}'s uuid%::achievements::*}
        # set {_total_achievements} to 20 # Example total
        # make gui slot 22 with experience bottle named "&6&lAchievements" with lore "&7Progress: &e%{_achievements_completed}% / %{_total_achievements}%" and "&7(More details in /achievements)"

        # TODO: Performance Graphs (Very Advanced - might require external tools or complex Skripting)
        # This would likely involve dynamically creating item displays or maps.
        # For now, a placeholder:
        make gui slot 24 with map named "&5&lPerformance Graphs" with lore "&7(Coming Soon)"

        # TODO: Comparison with server averages (Requires global data aggregation)
        # make gui slot 26 with comparator named "&3&lServer Comparison" with lore "&7(Coming Soon)"

        # Fill border with glass panes
        loop 36 times:
            if gui slot (loop-number - 1) is not set:
                make gui slot (loop-number - 1) with gray stained glass pane named " "

    open last gui to {_p}

# Note: For achievement progress bars and performance graphs,
# this GUI would likely call functions from achievements.sk or a dedicated visual elements script.
# The data itself (e.g., number of achievements) would come from data.sk.
# File: guild_system.sk
# Description: Guild system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Guild settings
    guild_creation_cost: 50000 # Cost to create a guild
    guild_name_length: [3, 20] # Minimum and maximum guild name length
    guild_tag_length: [2, 5] # Minimum and maximum guild tag length
    guild_max_members: 100 # Maximum guild members
    guild_invite_cooldown: 5 minutes # Cooldown between guild invites
    
    # Guild ranks
    guild_ranks:
        - "Guild Master"
        - "Officer"
        - "Member"
        - "Recruit"
    
    # Guild permissions
    guild_permissions:
        guild_master:
            - "guild.kick"
            - "guild.promote"
            - "guild.demote"
            - "guild.sethome"
            - "guild.setrank"
            - "guild.bank.admin"
            - "guild.town.admin"
        officer:
            - "guild.kick"
            - "guild.promote"
            - "guild.demote"
            - "guild.setrank"
            - "guild.bank.access"
            - "guild.town.access"
        member:
            - "guild.chat"
            - "guild.leave"
            - "guild.bank.deposit"
            - "guild.town.access"
        recruit:
            - "guild.chat"
            - "guild.leave"
            - "guild.bank.deposit"
            - "guild.town.access"
    
    # Guild town settings
    guild_town_cost: 100000 # Cost to create a guild town
    guild_town_max_level: 10 # Maximum guild town level
    guild_town_upkeep: 5000 # Daily guild town upkeep
    
    # Guild bank settings
    guild_bank_interest: 0.05 # 5% daily interest
    guild_bank_max: 10000000 # Maximum guild bank amount

# Variables:
# {guild::%guild_name%::tag} = text (guild tag)
# {guild::%guild_name%::master} = text (guild master)
# {guild::%guild_name%::members::*} = text (guild members)
# {guild::%guild_name%::rank::*} = text (guild member ranks)
# {guild::%guild_name%::bank} = number (guild bank)
# {guild::%guild_name%::town} = location (guild town)
# {guild::%guild_name%::town_level} = number (guild town level)
# {guild::%guild_name%::xp} = number (guild xp)
# {guild::%guild_name%::level} = number (guild level)
# {player::%uuid%::guild} = text (player's guild)
# {player::%uuid%::guild_rank} = text (player's guild rank)
# {guild::%guild_name%::town_upkeep} = number (guild town upkeep)

# Function to create guild
command /createguild <text>:
    permission: raceclicker.guild.create
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has guild
        if {player::%{_uuid}%::guild} is set:
            send "{@prefix} &cYou are already in a guild!" to player
            return
            
        # Check guild name
        if length of arg-1 is not between {@guild_name_length::0} and {@guild_name_length::1}:
            send "{@prefix} &cGuild name must be between %{guild_name_length::0}% and %{guild_name_length::1}% characters!" to player
            return
            
        # Check if guild exists
        if {guild::%arg-1%::master} is set:
            send "{@prefix} &cGuild %{arg-1}% already exists!" to player
            return
            
        # Check cost
        if {player::%{_uuid}%::clickcoins} < {@guild_creation_cost}:
            send "{@prefix} &cYou need %{@guild_creation_cost}% ClickCoins to create a guild!" to player
            return
            
        # Create guild
        set {guild::%arg-1%::master} to player
        set {guild::%arg-1%::members::*} to [player]
        set {guild::%arg-1%::rank::*} to ["Guild Master"]
        set {guild::%arg-1%::bank} to 0
        set {guild::%arg-1%::xp} to 0
        set {guild::%arg-1%::level} to 1
        set {guild::%arg-1%::town_level} to 1
        set {guild::%arg-1%::town_upkeep} to {@guild_town_upkeep}
        set {player::%{_uuid}%::guild} to arg-1
        set {player::%{_uuid}%::guild_rank} to "Guild Master"
        subtract {@guild_creation_cost} from {player::%{_uuid}%::clickcoins}
        
        # Announce guild creation
        broadcast "{@prefix} &6Guild created: %{arg-1}%" to all players
        send "{@prefix} &aCreated guild %{arg-1}%!" to player

# Function to join guild
command /joinguild <text>:
    permission: raceclicker.guild.join
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has guild
        if {player::%{_uuid}%::guild} is set:
            send "{@prefix} &cYou are already in a guild!" to player
            return
            
        # Check if guild exists
        if {guild::%arg-1%::master} is not set:
            send "{@prefix} &cGuild %{arg-1}% does not exist!" to player
            return
            
        # Check guild size
        if size of {guild::%arg-1%::members::*} >= {@guild_max_members}:
            send "{@prefix} &cGuild %{arg-1}% is full!" to player
            return
            
        # Add to guild
        add player to {guild::%arg-1%::members::*}
        add "Member" to {guild::%arg-1%::rank::*}
        set {player::%{_uuid}%::guild} to arg-1
        set {player::%{_uuid}%::guild_rank} to "Member"
        
        # Notify guild
        loop {guild::%arg-1%::members::*}:
            send "{@prefix} &6%{player}% joined guild %{arg-1}%" to loop-value
        
        send "{@prefix} &aJoined guild %{arg-1}%!" to player

# Function to leave guild
command /leaveguild:
    permission: raceclicker.guild.leave
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has guild
        if {player::%{_uuid}%::guild} is not set:
            send "{@prefix} &cYou are not in a guild!" to player
            return
            
        # Get guild info
        set {_guild} to {player::%{_uuid}%::guild}
        
        # Remove from guild
        remove player from {guild::%{_guild}%::members::*}
        remove {player::%{_uuid}%::guild_rank} from {guild::%{_guild}%::rank::*}
        set {player::%{_uuid}%::guild} to null
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6%{player}% left guild %{_guild}%" to loop-value
        
        send "{@prefix} &aLeft guild %{_guild}%!" to player

# Function to kick member
command /guildkick <player>:
    permission: raceclicker.guild.kick
    trigger:
        set {_uuid} to player's uuid
        set {_target} to arg-1
        set {_target_uuid} to {_target}'s uuid
        
        # Check permissions
        if {player::%{_uuid}%::guild_rank} is not "Guild Master" and {player::%{_uuid}%::guild_rank} is not "Officer":
            send "{@prefix} &cYou don't have permission to kick!" to player
            return
            
        # Check if target is in same guild
        if {player::%{_target_uuid}%::guild} is not {player::%{_uuid}%::guild}:
            send "{@prefix} &c%{_target}% is not in your guild!" to player
            return
            
        # Kick member
        set {_guild} to {player::%{_uuid}%::guild}
        remove {_target} from {guild::%{_guild}%::members::*}
        remove {player::%{_target_uuid}%::guild_rank} from {guild::%{_guild}%::rank::*}
        set {player::%{_target_uuid}%::guild} to null
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6%{player}% kicked %{_target}% from guild %{_guild}%" to loop-value
        
        send "{@prefix} &aKicked %{_target}% from guild %{_guild}%!" to player

# Function to promote member
command /guildpromote <player>:
    permission: raceclicker.guild.promote
    trigger:
        set {_uuid} to player's uuid
        set {_target} to arg-1
        set {_target_uuid} to {_target}'s uuid
        
        # Check permissions
        if {player::%{_uuid}%::guild_rank} is not "Guild Master":
            send "{@prefix} &cYou don't have permission to promote!" to player
            return
            
        # Check if target is in same guild
        if {player::%{_target_uuid}%::guild} is not {player::%{_uuid}%::guild}:
            send "{@prefix} &c%{_target}% is not in your guild!" to player
            return
            
        # Promote member
        set {_guild} to {player::%{_uuid}%::guild}
        set {_current_rank} to {player::%{_target_uuid}%::guild_rank}
        set {_new_rank} to next element of {@guild_ranks::*} after {_current_rank}
        
        if {_new_rank} is not set:
            send "{@prefix} &c%{_target}% is already at the highest rank!" to player
            return
            
        # Update rank
        remove {_current_rank} from {guild::%{_guild}%::rank::*}
        add {_new_rank} to {guild::%{_guild}%::rank::*}
        set {player::%{_target_uuid}%::guild_rank} to {_new_rank}
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6%{player}% promoted %{_target}% to %{_new_rank}%" to loop-value
        
        send "{@prefix} &aPromoted %{_target}% to %{_new_rank}%!" to player

# Function to demote member
command /guilddemote <player>:
    permission: raceclicker.guild.demote
    trigger:
        set {_uuid} to player's uuid
        set {_target} to arg-1
        set {_target_uuid} to {_target}'s uuid
        
        # Check permissions
        if {player::%{_uuid}%::guild_rank} is not "Guild Master":
            send "{@prefix} &cYou don't have permission to demote!" to player
            return
            
        # Check if target is in same guild
        if {player::%{_target_uuid}%::guild} is not {player::%{_uuid}%::guild}:
            send "{@prefix} &c%{_target}% is not in your guild!" to player
            return
            
        # Demote member
        set {_guild} to {player::%{_uuid}%::guild}
        set {_current_rank} to {player::%{_target_uuid}%::guild_rank}
        set {_new_rank} to previous element of {@guild_ranks::*} before {_current_rank}
        
        if {_new_rank} is not set:
            send "{@prefix} &c%{_target}% is already at the lowest rank!" to player
            return
            
        # Update rank
        remove {_current_rank} from {guild::%{_guild}%::rank::*}
        add {_new_rank} to {guild::%{_guild}%::rank::*}
        set {player::%{_target_uuid}%::guild_rank} to {_new_rank}
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6%{player}% demoted %{_target}% to %{_new_rank}%" to loop-value
        
        send "{@prefix} &aDemoted %{_target}% to %{_new_rank}%!" to player

# Function to set guild home
command /guildsethome:
    permission: raceclicker.guild.sethome
    trigger:
        set {_uuid} to player's uuid
        
        # Check permissions
        if {player::%{_uuid}%::guild_rank} is not "Guild Master" and {player::%{_uuid}%::guild_rank} is not "Officer":
            send "{@prefix} &cYou don't have permission to set guild home!" to player
            return
            
        # Set guild home
        set {_guild} to {player::%{_uuid}%::guild}
        set {guild::%{_guild}%::town} to player's location
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6%{player}% set guild home!" to loop-value
        
        send "{@prefix} &aSet guild home!" to player

# Function to teleport to guild home
command /guildhome:
    permission: raceclicker.guild.home
    trigger:
        set {_uuid} to player's uuid
        
        # Check if guild has home
        if {guild::%{player::%{_uuid}%::guild}%::town} is not set:
            send "{@prefix} &cGuild home not set!" to player
            return
            
        # Teleport to guild home
        teleport player to {guild::%{player::%{_uuid}%::guild}%::town}
        send "{@prefix} &aTeleported to guild home!" to player

# Function to view guild info
command /guildinfo:
    permission: raceclicker.guild.info
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has guild
        if {player::%{_uuid}%::guild} is not set:
            send "{@prefix} &cYou are not in a guild!" to player
            return
            
        # Get guild info
        set {_guild} to {player::%{_uuid}%::guild}
        set {_info} to "&6Guild Info: %{_guild}%\n"
        append "&eMaster: &a%{guild::%{_guild}%::master}%\n" to {_info}
        append "&eMembers: &a%{size of {guild::%{_guild}%::members::*}}%/%{@guild_max_members}%\n" to {_info}
        append "&eLevel: &a%{guild::%{_guild}%::level}%\n" to {_info}
        append "&eXP: &a%{guild::%{_guild}%::xp}%\n" to {_info}
        append "&eBank: &a%{guild::%{_guild}%::bank}% ClickCoins\n" to {_info}
        append "&eTown Level: &a%{guild::%{_guild}%::town_level}%\n" to {_info}
        append "&eMembers:\n" to {_info}
        
        # Add member list
        loop {guild::%{_guild}%::members::*}:
            set {_member} to loop-value
            set {_member_uuid} to {_member}'s uuid
            append "&7- %{_member}% &8(&a%{player::%{_member_uuid}%::guild_rank}%&8)\n" to {_info}
        
        send "{@prefix} %{_info}%" to player

# Function to deposit to guild bank
command /guilddeposit <number>:
    permission: raceclicker.guild.bank
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has guild
        if {player::%{_uuid}%::guild} is not set:
            send "{@prefix} &cYou are not in a guild!" to player
            return
            
        # Check if player has enough coins
        if {player::%{_uuid}%::clickcoins} < arg-1:
            send "{@prefix} &cYou don't have enough ClickCoins!" to player
            return
            
        # Check bank limit
        set {_guild} to {player::%{_uuid}%::guild}
        if {guild::%{_guild}%::bank} + arg-1 > {@guild_bank_max}:
            send "{@prefix} &cGuild bank is full!" to player
            return
            
        # Deposit coins
        add arg-1 to {guild::%{_guild}%::bank}
        subtract arg-1 from {player::%{_uuid}%::clickcoins}
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6%{player}% deposited %{arg-1}% ClickCoins to guild bank!" to loop-value
        
        send "{@prefix} &aDeposited %{arg-1}% ClickCoins to guild bank!" to player

# Function to withdraw from guild bank
command /guildwithdraw <number>:
    permission: raceclicker.guild.bank
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has guild
        if {player::%{_uuid}%::guild} is not set:
            send "{@prefix} &cYou are not in a guild!" to player
            return
            
        # Check if bank has enough coins
        set {_guild} to {player::%{_uuid}%::guild}
        if {guild::%{_guild}%::bank} < arg-1:
            send "{@prefix} &cGuild bank doesn't have enough ClickCoins!" to player
            return
            
        # Withdraw coins
        subtract arg-1 from {guild::%{_guild}%::bank}
        add arg-1 to {player::%{_uuid}%::clickcoins}
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6%{player}% withdrew %{arg-1}% ClickCoins from guild bank!" to loop-value
        
        send "{@prefix} &aWithdrew %{arg-1}% ClickCoins from guild bank!" to player

# Function to invite player to guild
command /guildinvite <player>:
    permission: raceclicker.guild.invite
    trigger:
        set {_uuid} to player's uuid
        set {_target} to arg-1
        set {_target_uuid} to {_target}'s uuid
        
        # Check if player has guild
        if {player::%{_uuid}%::guild} is not set:
            send "{@prefix} &cYou are not in a guild!" to player
            return
            
        # Check if target has guild
        if {player::%{_target_uuid}%::guild} is set:
            send "{@prefix} &c%{_target}% is already in a guild!" to player
            return
            
        # Check cooldown
        if {player::%{_uuid}%::last_invite} is set and now - {player::%{_uuid}%::last_invite} < {@guild_invite_cooldown}:
            send "{@prefix} &cYou must wait %{@guild_invite_cooldown}% between invites!" to player
            return
            
        # Send invite
        set {_guild} to {player::%{_uuid}%::guild}
        send "{@prefix} &6%{player}% invited you to guild %{_guild}%!" to {_target}
        send "{@prefix} &aSent invite to %{_target}%!" to player
        set {player::%{_uuid}%::last_invite} to now
        
        # Wait for response
        wait 30 seconds
        if {player::%{_target_uuid}%::guild} is not set:
            send "{@prefix} &cInvite to %{_target}% expired!" to player

# Function to accept guild invite
command /guildaccept <text>:
    permission: raceclicker.guild.accept
    trigger:
        set {_uuid} to player's uuid
        
        # Check if player has guild
        if {player::%{_uuid}%::guild} is set:
            send "{@prefix} &cYou are already in a guild!" to player
            return
            
        # Check if guild exists
        if {guild::%arg-1%::master} is not set:
            send "{@prefix} &cGuild %{arg-1}% does not exist!" to player
            return
            
        # Join guild
        set {_guild} to arg-1
        add player to {guild::%{_guild}%::members::*}
        add "Member" to {guild::%{_guild}%::rank::*}
        set {player::%{_uuid}%::guild} to {_guild}
        set {player::%{_uuid}%::guild_rank} to "Member"
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6%{player}% joined guild %{_guild}%" to loop-value
        
        send "{@prefix} &aJoined guild %{_guild}%!" to player

# Function to set guild tag
command /guildsettag <text>:
    permission: raceclicker.guild.tag
    trigger:
        set {_uuid} to player's uuid
        
        # Check permissions
        if {player::%{_uuid}%::guild_rank} is not "Guild Master":
            send "{@prefix} &cYou don't have permission to set guild tag!" to player
            return
            
        # Check tag length
        if length of arg-1 is not between {@guild_tag_length::0} and {@guild_tag_length::1}:
            send "{@prefix} &cGuild tag must be between %{guild_tag_length::0}% and %{guild_tag_length::1}% characters!" to player
            return
            
        # Set guild tag
        set {_guild} to {player::%{_uuid}%::guild}
        set {guild::%{_guild}%::tag} to arg-1
        
        # Update guild chat
        loop {guild::%{_guild}%::members::*}:
            set {_member} to loop-value
            set {_member_uuid} to {_member}'s uuid
            set {_member}'s display name to "&8[&6%{guild::%{_guild}%::tag}%&8] %{_member}%"
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6%{player}% set guild tag to %{arg-1}%" to loop-value
        
        send "{@prefix} &aSet guild tag to %{arg-1}%!" to player

# Function to handle guild chat
on chat:
    if player has guild:
        set {_guild} to {player::%player's uuid%::guild}
        set event-message to "&8[&6%{guild::%{_guild}%::tag}%&8] %{event-message}%"

# Function to calculate guild xp
# TODO: This is a custom event that needs to be called from other scripts
# on race completion:
#     set {_uuid} to player's uuid
#     if {player::%{_uuid}%::guild} is set:
#         set {_guild} to {player::%{_uuid}%::guild}
#         add 100 to {guild::%{_guild}%::xp}
#         
#         # Check level up
#         if {guild::%{_guild}%::xp} >= {guild::%{_guild}%::level} * 1000:
#             add 1 to {guild::%{_guild}%::level}
#             set {guild::%{_guild}%::xp} to 0
#             
#             # Give level up rewards
            set {_reward} to {guild::%{_guild}%::level} * 1000
            add {_reward} to {guild::%{_guild}%::bank}
            
            # Notify guild
            loop {guild::%{_guild}%::members::*}:
                send "{@prefix} &6Guild level up! New level: %{guild::%{_guild}%::level}%" to loop-value
                send "{@prefix} &6Guild bank received %{_reward}% ClickCoins!" to loop-value

# Function to handle guild bank interest
every 24 hours:
    loop all guilds:
        set {_guild} to loop-value
        set {_interest} to {guild::%{_guild}%::bank} * {@guild_bank_interest}
        add {_interest} to {guild::%{_guild}%::bank}
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6Guild bank received %{_interest}% ClickCoins interest!" to loop-value

# Function to handle guild town upkeep
every 24 hours:
    loop all guilds:
        set {_guild} to loop-value
        
        # Check if guild has enough coins
        if {guild::%{_guild}%::bank} < {guild::%{_guild}%::town_upkeep}:
            send "{@prefix} &cGuild town upkeep failed! Not enough ClickCoins!" to {_guild}'s master
            return
            
        # Deduct upkeep
        subtract {guild::%{_guild}%::town_upkeep} from {guild::%{_guild}%::bank}
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6Guild town upkeep paid!" to loop-value

# Function to create guild town
command /guildtowncreate:
    permission: raceclicker.guild.town.create
    trigger:
        set {_uuid} to player's uuid
        
        # Check permissions
        if {player::%{_uuid}%::guild_rank} is not "Guild Master":
            send "{@prefix} &cYou don't have permission to create a guild town!" to player
            return
            
        # Check if guild has town
        set {_guild} to {player::%{_uuid}%::guild}
        if {guild::%{_guild}%::town} is set:
            send "{@prefix} &cGuild already has a town!" to player
            return
            
        # Check if guild has enough coins
        if {guild::%{_guild}%::bank} < {@guild_town_cost}:
            send "{@prefix} &cGuild needs %{@guild_town_cost}% ClickCoins to create a town!" to player
            return
            
        # Create town
        set {guild::%{_guild}%::town} to player's location
        set {guild::%{_guild}%::town_level} to 1
        subtract {@guild_town_cost} from {guild::%{_guild}%::bank}
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6Guild town created! Level: 1" to loop-value
        
        send "{@prefix} &aCreated guild town!" to player

# Function to upgrade guild town
command /guildtownupgrade:
    permission: raceclicker.guild.town.upgrade
    trigger:
        set {_uuid} to player's uuid
        
        # Check permissions
        if {player::%{_uuid}%::guild_rank} is not "Guild Master":
            send "{@prefix} &cYou don't have permission to upgrade the guild town!" to player
            return
            
        # Check if guild has town
        set {_guild} to {player::%{_uuid}%::guild}
        if {guild::%{_guild}%::town} is not set:
            send "{@prefix} &cGuild doesn't have a town!" to player
            return
            
        # Check max level
        if {guild::%{_guild}%::town_level} >= {@guild_town_max_level}:
            send "{@prefix} &cGuild town is at maximum level!" to player
            return
            
        # Calculate upgrade cost
        set {_cost} to {guild::%{_guild}%::town_level} * 100000
        
        # Check if guild has enough coins
        if {guild::%{_guild}%::bank} < {_cost}:
            send "{@prefix} &cGuild needs %{_cost}% ClickCoins to upgrade town!" to player
            return
            
        # Upgrade town
        add 1 to {guild::%{_guild}%::town_level}
        subtract {_cost} from {guild::%{_guild}%::bank}
        
        # Notify guild
        loop {guild::%{_guild}%::members::*}:
            send "{@prefix} &6Guild town upgraded to level %{guild::%{_guild}%::town_level}%!" to loop-value
        
        send "{@prefix} &aUpgraded guild town!" to player
# File: camera.sk
# Path: race-clicker/integration/camera.sk
# Description: 3rd person camera integration

options:
    prefix: &6&lRaceClicker &8» # Example prefix
    camera_distance: 5 # Default distance behind player/citizen
    camera_height: 2   # Default height above player/citizen

# --- Phase 1: Fix and Complete Core Systems ---
# Complete Missing Race Mechanics
# - Integrated 3rd person camera with race system
#   - Camera follows citizen's race position
#   - Smooth transitions at race start/end
#   - Dynamic camera angles based on race state

# --- Phase 2: Enhance Visual Systems ---
# Improve 3rd Person Integration
# - Citizen positioning for races
#   - Camera follows citizen's movement
#   - Dynamic camera angles based on race progress
#   - Smooth transitions between camera modes

# --- Phase 6: Complete Multiplayer Features ---
# Fix Race Lobby System
# - TODO: Complete countdown system integration with 3rd person
#   - Synchronize camera positions at starting line

# --- Phase 9: Integration and Polish ---
# Seamless 3rd Person Race Integration
# - TODO: Perfect camera-citizen synchronization
# - TODO: Smooth race transitions (pre-race positioning, post-race, lobby return)
# - TODO: Dynamic camera effects (speed shake, zoom, cinematic finishes)

# Variables:
# {player::%player's uuid%::in_3rd_person_race_mode} = true/false
# {player::%player's uuid%::camera_target_entity} = the citizen entity the camera should follow
# {player::%player's uuid%::camera_offset_vector} = custom vector for camera position relative to target

# Command to toggle 3rd person (for testing, actual use is automated by race start/end)
command /toggle3rdpersonrace:
    permission: raceclicker.debug
    trigger:
        if {player::%player's uuid%::in_3rd_person_race_mode} is true:
            disableRaceCamera(player)
        else:
            # For testing, we need a dummy target if not in a race
            # In a real scenario, racing.sk would provide the citizen
            if {player::%player's uuid%::race_citizen} is set:
                enableRaceCamera(player, {player::%player's uuid%::race_citizen})
            else:
                send "{@prefix} &cNo race citizen target set for you. Start a race first."

# Function to enable 3rd person race camera for a player
function enableRaceCamera(p: player, target_entity: entity):
    if not {_target_entity} is set:
        return
    
    # Set camera variables
    set {player::%{_p}'s uuid%::in_3rd_person_race_mode} to true
    set {player::%{_p}'s uuid%::camera_target_entity} to {_target_entity}
    set {player::%{_p}'s uuid%::camera_offset_vector} to vector(0, {@camera_height}, -{@camera_distance})
    set {player::%{_p}'s uuid%::camera_mode} to "start"
    
    # Apply camera effects
    applyScreenShake(p, 1, 1)
    setPlayerFOV(p, 0.5, 5)
    
    # Set spectator mode
    set gamemode of {_p} to spectator
    make {_p} spectate {_target_entity}
    
    # Send feedback
    send "{@prefix} &a3rd person race camera enabled. (Spectating your racer)" to {_p}

# Function to disable 3rd person race camera
function disableRaceCamera(p: player):
    if not {player::%{_p}'s uuid%::in_3rd_person_race_mode} is true:
        return
    
    # Clean up variables
    set {player::%{_p}'s uuid%::in_3rd_person_race_mode} to false
    delete {player::%{_p}'s uuid%::camera_target_entity}
    delete {player::%{_p}'s uuid%::camera_offset_vector}
    delete {player::%{_p}'s uuid%::camera_mode}
    
    # Reset camera effects
    clearPlayerFOV(p)
    
    # Restore player state
    set gamemode of {_p} to survival
    
    # Send feedback
    send "{@prefix} &c3rd person race camera disabled." to {_p}

# Dynamic camera update loop
every 2 ticks:
    loop all players:
        set {_p} to loop-value
        if not {player::%{_p}'s uuid%::in_3rd_person_race_mode} is true:
            continue
            
        set {_target} to {player::%{_p}'s uuid%::camera_target_entity}
        if not {_target} is set or not {_target} is online:
            continue
            
        # Get race progress and calculate position
        set {_progress} to {player::%{_p}'s uuid%::race_progress_current_race}
        if not {_progress} is set:
            continue
            
        # Calculate camera position
        set {_citizen_loc} to location of {_target}
        set {_camera_loc} to {_citizen_loc} with offset vector(0, {@camera_height}, -{@camera_distance})
        
        # Apply camera effects based on race state
        if {race::status} is "countdown":
            applyScreenShake(p, 1, 1)
        else if {race::status} is "inprogress":
            setPlayerFOV(p, 0.5, 5)
        else if {race::status} is "finished":
            clearPlayerFOV(p)
            
        # Update player's position
        teleport {_p} to {_camera_loc}
        function updateCameraView(p: player):
            set {_current_mode} to {player::%{_p}'s uuid%::camera_mode} ? "normal"
            
            # Camera mode handling
            if {_current_mode} is "start":
                # Zoom in at race start
                setPlayerFOV(p, 0.5, 1)
                if {player::%{_p}'s uuid%::race_progress_current_race} >= 50: # After first 50 units
                    set {player::%{_p}'s uuid%::camera_mode} to "normal"
                    setPlayerFOV(p, 0, 1) # Reset FOV
            
            else if {_current_mode} is "normal":
                # Dynamic camera positioning based on race progress
                set {_progress} to {player::%{_p}'s uuid%::race_progress_current_race}
                set {_track_length} to {tracks::%{player::%{_p}'s uuid%::current_track_id}%::length}
                set {_percentage} to {_progress} / {_track_length}
                
                # Adjust camera distance based on progress
                if {_percentage} < 0.25:
                    set {player::%{_p}'s uuid%::camera_offset_vector} to vector(0, {@camera_height}, -{@camera_distance})
                else if {_percentage} < 0.75:
                    set {player::%{_p}'s uuid%::camera_offset_vector} to vector(0, {@camera_height}, -{@camera_distance} * 1.5)
                else:
                    set {player::%{_p}'s uuid%::camera_offset_vector} to vector(0, {@camera_height}, -{@camera_distance} * 2)
            
            else if {_current_mode} is "finish":
                # Zoom out at finish
                setPlayerFOV(p, -0.5, 1)
                if now - {player::%{_p}'s uuid%::race_start_time_personal} > 5 seconds:
                    set {player::%{_p}'s uuid%::camera_mode} to "normal"
                    setPlayerFOV(p, 0, 1)
            
            # Apply screen effects based on obstacles/boosts
            if {player::%{_p}'s uuid%::active_obstacle_effect::type} is "slow_down":
                applyScreenShake(p, 2, 0.5) # Strong shake for slowdown
            else if {player::%{_p}'s uuid%::active_boost_effect::end_time} is set and {player::%{_p}'s uuid%::active_boost_effect::end_time} > now:
                applyScreenShake(p, 1, 0.3) # Light shake for boost
# 
#                     # Convert yaw to radians for trigonometric functions
#                     set {_yaw_radians} to ({_target_yaw} + 90) * (pi / 180) # Adding 90 because Minecraft yaw is 0 for south
# 
#                     # Rotate the offset vector
#                     set {_rotated_dx} to ({_dx_offset} * cos({_yaw_radians})) - ({_dz_offset} * sin({_yaw_radians}))
#                     set {_rotated_dz} to ({_dx_offset} * sin({_yaw_radians})) + ({_dz_offset} * cos({_yaw_radians}))
# 
#                     set {_camera_loc} to {_target_loc} ~ vector({_rotated_dx}, {_dy_offset}, {_rotated_dz})
#                     teleport {_p} to {_camera_loc} facing {_target_loc}
#                 else:
#                     # Target lost or invalid, disable manual camera, fallback to spectator or disable full camera
#                     send "{@prefix} &cManual camera target lost, attempting to re-spectate or disable." to {_p}
#                     disableRaceCamera({_p}) # This will try to set to survival
#                     # Optionally, re-enable spectator if citizen still exists
#                     if {_target} is set and {_target} is online:
#                         enableRaceCamera({_p}, {_target}) # Re-enable to go back to spectator
#                     else:
#                         send "{@prefix} &cCamera target completely lost." to {_p}
#             else:
#                 disableRaceCamera({_p})
#                 send "{@prefix} &cNo camera target UUID set." to {_p}

# Function from plan.md (Phase 2: Improve 3rd Person Integration)
# function movePlayerInRace(p: player, progress: number):
#     # This function seems to be about moving the CITIZEN, not the player's camera directly.
#     # The camera (this script) would then follow the citizen.
#     # So, this function would likely be in citizens.sk or racing.sk.
#     # It would calculate the citizen's new position on the track.
#     # Then, the camera loop (or spectator mode) ensures the player's view follows.
#     pass

# Function from plan.md (Phase 9: Seamless 3rd Person Race Integration)
# function updateRaceCamera(p: player):
#     # This function is essentially what the `every tick` loop above does.
#     # It's called to reposition the player's camera to follow the citizen.
#     set {_progress} to {race.progress::%uuid of {_p}%} # This var needs to be from data.sk
#     # {_citizen_loc} = calculateTrackPosition({_progress}) # This function would be in racing.sk or track logic
#     # set {_camera_loc} to {_citizen_loc} with offset vector(0, 2, -5) # Simplified offset
#     # teleport {_p} to {_camera_loc}
#     # This is a simplified version. The `every tick` loop is more robust if not using spectator.
#     pass

# --- Race Start/End Integration (called by racing.sk) ---
function onRaceStartForPlayer(p: player, citizen_racer: entity):
    enableRaceCamera({_p}, {_citizen_racer})
    # TODO: Position camera at starting line view, e.g., slightly zoomed out or a different angle
    # Example: set {player::%{_p}'s uuid%::camera_offset_vector} to vector(0, {@camera_height} + 1, -{@camera_distance} - 2)
    send debug "%{options.prefix}% Camera adjusted for race start for %{_p}%."

function onRaceEndForPlayer(p: player):
    # disableRaceCamera({_p}) # This is already called by racing.sk in playerFinishRace
    # TODO: Transition camera to a podium view, results screen, or back to a standard lobby view.
    # This might involve teleporting the player if they are not spectating, or changing spectator target.
    send debug "%{options.prefix}% Camera transitioning for race end for %{_p}%."
    # Example: if a podium location is defined:
    # if {podium_location_for_winner} is set:
    #    make {_p} spectate some_entity_at_podium or teleport {_p} to a viewing spot

# --- Dynamic Camera Effects (Phase 9) ---
# TODO: Speed-based camera shake (e.g., apply small random offsets to camera_offset_vector)
# TODO: Zoom effects (e.g., change the Z component of camera_offset_vector)
# TODO: Cinematic finish sequences (pre-defined camera paths or movements)

# Note: True 3rd person camera systems in Minecraft without client mods are challenging.
# Using spectator mode is the easiest. Manual camera control via teleportation is more flexible
# but can be jittery and requires careful handling of player visibility and interaction.
# Consider addons if more advanced camera controls are needed (e.g., CamUtils, ReplayMod-like features for Skript).
# File: citizens.sk
# Path: race-clicker/integration/citizens.sk
# Description: Citizen management for racing

options:
    prefix: &6&lRaceClicker &8» # Example prefix
    citizen_type: VILLAGER # Default entity type for racers, can be ZOMBIE, ARMOR_STAND etc.
    # Ensure Citizens2 plugin is installed and functional if using its API.
    # This script will assume basic entity manipulation if Citizens2 is not directly used by Skript commands.

# --- Phase 1: Fix and Complete Core Systems ---
# Complete Missing Race Mechanics
# - TODO: Update citizen movement to follow race progress (function moveCitizenOnTrack)
# - TODO: Replace player teleportation with citizen movement

# --- Phase 2: Enhance Visual Systems ---
# Improve 3rd Person Integration
# - TODO: Modify citizen positioning for races (this script handles the actual moving)
# Implement citizen racing animations
# - TODO: Running animations during races (e.g., by changing pose for armor stands, or particle effects)
# - TODO: Victory poses for winners
# - TODO: Idle animations during waiting

# Variables:
# {player::%player's uuid%::race_citizen_entity_id} - Stores the UUID of the spawned entity representing the player.
# {race_citizens::%entity_uuid%::owner_player_uuid} - Maps a citizen entity back to its player owner.
# {player::%player's uuid%::race_indicator_entity_id} - Stores the UUID of an entity used for displaying race position (e.g., an armor stand).

# Function to spawn a race citizen for a player
function spawnRaceCitizen(p: player, spawn_location: location) :: entity:
    # Spawn a basic entity for racing
    spawn 1 of {@citizen_type} at {_spawn_location}
    set {_citizen} to last spawned entity
    if not {_citizen} is set:
        return null
    
    # Set entity properties
    set name of {_citizen} to "&7%name of {_p}%'s Racer"
    set AI of {_citizen} to false
    set gravity of {_citizen} to false
    set silent of {_citizen} to true
    
    # Store entity reference
    set {player::%{_p}'s uuid%::race_citizen_entity_id} to uuid of {_citizen}
    set {race_citizens::%uuid of {_citizen}%::owner_player_uuid} to uuid of {_p}
    return {_citizen}

# Function to remove a player's race citizen
function removeRaceCitizen(p: player):
    set {_citizen_uuid} to {player::%{_p}'s uuid%::race_citizen_entity_id}
    if not {_citizen_uuid} is set:
        return
    
    set {_citizen_entity} to entity from uuid {_citizen_uuid}
    if not {_citizen_entity} is set:
        return
    
    # Remove the entity
    delete {_citizen_entity}
    
    # Clean up variables
    delete {race_citizens::%{_citizen_uuid}%::owner_player_uuid}
    delete {player::%{_p}'s uuid%::race_citizen_entity_id}
    
    # Clean up race indicator if any
    execute function "removeCitizenRaceIndicator" with argument {_p}

# Function to move a citizen along a predefined race track based on progress
function moveCitizenOnTrack(citizen_entity: entity, start_location: location, waypoints: list of locations, progress: number, total_track_length: number):
    if not {_citizen_entity} is set:
        return
    
    # Validate track data
    if not {_start_location} is set or size of {_waypoints::*} = 0:
        if {_start_location} is set:
            teleport {_citizen_entity} to {_start_location}
        return
    
    # Validate track length
    if {_total_track_length} <= 0:
        teleport {_citizen_entity} to {_start_location}
        return
    
    # Build full path
    set {_full_path::*} to {_start_location}
    add all {_waypoints::*} to {_full_path::*}
    
    # Calculate segment information
    set {_num_segments} to size of {_full_path::*} - 1
    if {_num_segments} <= 0:
        set {_target_loc} to {_start_location}
        if {_progress} / {_total_track_length} >= 1 and size of {_full_path::*} > 0:
            set {_target_loc} to last element of {_full_path::*}
        teleport {_citizen_entity} to {_target_loc}
        return
    
    # Calculate progress
    set {_progress_percentage} to {_progress} / {_total_track_length}
    if {_progress_percentage} < 0:
        set {_progress_percentage} to 0
    if {_progress_percentage} > 1:
        set {_progress_percentage} to 1
    
    set {_target_segment_float} to {_progress_percentage} * {_num_segments}
    set {_current_segment_index} to floor({_target_segment_float})
    set {_ratio_in_segment} to {_target_segment_float} - {_current_segment_index}

    # Ensure segment index is valid
    if {_current_segment_index} >= {_num_segments}: # Happens at 100% progress
        set {_current_segment_index} to {_num_segments} - 1
        set {_ratio_in_segment} to 1
    if {_current_segment_index} < 0:
        set {_current_segment_index} to 0
        set {_ratio_in_segment} to 0
        
    set {_p1} to {_full_path::%{_current_segment_index} + 1%}
    set {_p2} to {_full_path::%{_current_segment_index} + 2%}

    if {_p1} is not set or {_p2} is not set: # Should not happen if logic above is correct
        send debug "[Citizens] Error calculating path points for %{_citizen_entity}% (p1 or p2 not set)"
        teleport {_citizen_entity} to last element of {_full_path::*} # Failsafe
        return

    set {_final_pos} to location between {_p1} and {_p2} at ratio {_ratio_in_segment}
    teleport {_citizen_entity} to {_final_pos}
    if y-coordinate of direction from {_p1} to {_p2} is not 0: # Avoid looking straight up/down if moving vertically, keep horizontal orientation
        make {_citizen_entity} look at location {_p2}.x, {_final_pos}.y, {_p2}.z
    else:
        make {_citizen_entity} look at {_p2}
    # send debug "[Citizens] Moved %{_citizen_entity}% to %{_final_pos}%, looking at %{_p2}% (Segment: %{_current_segment_index}%/%{_num_segments}%, Ratio: %{_ratio_in_segment}%)%"
    execute function "playCitizenRunningAnimation" with argument {_citizen_entity} # Play running animation
    # Potentially call updateCitizenRaceIndicator here if rank is passed or can be derived globally
    # For now, racing.sk will call it after ranks are known.

# Function to update or create a race position indicator above the citizen
function updateCitizenRaceIndicator(p: player, rank: integer, total_racers: integer):
    set {_citizen_uuid} to {player::%{_p}'s uuid%::race_citizen_entity_id}
    if {_citizen_uuid} is not set:
        return
    set {_citizen_entity} to entity from uuid {_citizen_uuid}
    if {_citizen_entity} is not set or {_citizen_entity} is not online:
        return

    # Option 1: Update citizen's name (simplest)
    set {_rank_color} to "&a"
    if {_rank} is 1:
        set {_rank_color} to "&6&l"
    else if {_rank} is 2:
        set {_rank_color} to "&e&l"
    else if {_rank} is 3:
        set {_rank_color} to "&c&l"
    else if {_rank} > (round({_total_racers} / 2)):
        set {_rank_color} to "&7"
    
    set name of {_citizen_entity} to "%name of {_p}% - %{_rank_color}##%{_rank}%"
    # Make nameplate always visible if possible (depends on entity type and server settings)
    # For armor stands, you can set customNameVisible to true.
    # For other entities, it's often default or controlled by client settings.

    # Option 2: Use a separate armor stand (more complex, better visuals)
    # This is a placeholder for future enhancement if direct name update is insufficient.
    # delete {player::%{_p}'s uuid%::race_indicator_entity_id} # remove old one
    # spawn armor stand at location of {_citizen_entity} ~ vector(0, 0.5, 0) # Spawn above citizen
    # set {_indicator_entity} to last spawned entity
    # set custom name of {_indicator_entity} to "%name of {_p}% - Rank: %{_rank}%"
    # set custom name visible of {_indicator_entity} to true
    # set visible of {_indicator_entity} to false # Make armor stand invisible
    # set gravity of {_indicator_entity} to false
    # set marker of {_indicator_entity} to true # Make it non-interactive
    # set {player::%{_p}'s uuid%::race_indicator_entity_id} to uuid of {_indicator_entity}
    # Periodically teleport this indicator to follow the main citizen.

# Function to remove the race position indicator
function removeCitizenRaceIndicator(p: player):
    # If using Option 1 (name update), reset name or let spawnRaceCitizen handle it.
    set {_citizen_uuid} to {player::%{_p}'s uuid%::race_citizen_entity_id}
    if {_citizen_uuid} is set:
        set {_citizen_entity} to entity from uuid {_citizen_uuid}
        if {_citizen_entity} is set:
            set name of {_citizen_entity} to "&7%name of {_p}%'s Racer" # Reset to default

    # If using Option 2 (separate armor stand):
    # set {_indicator_uuid} to {player::%{_p}'s uuid%::race_indicator_entity_id}
    # if {_indicator_uuid} is set:
    #    set {_indicator_entity} to entity from uuid {_indicator_uuid}
    #    if {_indicator_entity} is set:
    #        delete {_indicator_entity}
    #    delete {player::%{_p}'s uuid%::race_indicator_entity_id}

# --- Animations (Conceptual) ---
# These would be called at appropriate times by racing.sk or other scripts.

# Variable to control running animation state
# {citizen_animation_state::%entity_uuid%::running_leg} - stores 0 or 1 to alternate legs/arms

function playCitizenRunningAnimation(citizen_entity: entity):
    if {_citizen_entity} is not set or {_citizen_entity} is not online:
        return

    # For Armor Stands: change pose (right arm, left arm, etc.) periodically.
    if type of {_citizen_entity} is armor stand:
        set {_state} to {citizen_animation_state::%uuid of {_citizen_entity}%::running_leg} ? 0
        if {_state} is 0:
            set pose of {_citizen_entity} to (0, 0, 0, -20, 20, 0) # Right arm forward, Left arm back
            set {citizen_animation_state::%uuid of {_citizen_entity}%::running_leg} to 1
        else:
            set pose of {_citizen_entity} to (0, 0, 0, 20, -20, 0) # Left arm forward, Right arm back
            set {citizen_animation_state::%uuid of {_citizen_entity}%::running_leg} to 0
    # For other entities: spawn particles (e.g., footstep dust) or play sounds.
    else:
        spawn 1 of cloud at location of {_citizen_entity} ~ vector(random double between -0.2 and 0.2, 0.1, random double between -0.2 and 0.2) with speed 0
    # send debug "[Citizens] Playing running animation for %{_citizen_entity}%" 

# Function to be called within moveCitizenOnTrack or a separate loop
function triggerCitizenRunningAnimation(citizen_entity: entity):
    # This function is a wrapper that could be used if running animation needs its own tick loop
    # For now, we'll integrate directly into moveCitizenOnTrack for simplicity
    execute function "playCitizenRunningAnimation" with argument {_citizen_entity}

# function playCitizenRunningAnimation(citizen_entity: entity):
    # For Armor Stands: change pose (right arm, left arm, etc.) periodically.
    # For other entities: spawn particles (e.g., footstep dust) or play sounds.
    # if type of {_citizen_entity} is armor stand:
    #    set pose of {_citizen_entity} to (0, 0, 0, -20, 0, 0) # Example: one arm forward
    #    wait 5 ticks
    #    set pose of {_citizen_entity} to (0, 0, 0, 0, -20, 0) # Example: other arm forward
    #    # Loop this with a flag
    # else:
    #    spawn 1 of cloud at location of {_citizen_entity} ~ vector(0, 0.1, 0)
    # send debug "[Citizens] Playing running animation for %{_citizen_entity}%"

function playCitizenIdleAnimation(citizen_entity: entity):
    if {_citizen_entity} is not set or {_citizen_entity} is not online:
        return
    # For Armor Stands: subtle head movement or arm twitch.
    if type of {_citizen_entity} is armor stand:
        if random integer between 1 and 100 <= 5: # 5% chance each time called
            set {_rand} to random integer between 1 and 3
            if {_rand} is 1:
                set pose of {_citizen_entity} to (random integer between -5 and 5, 0, 0, 0, 0, 0) # Head tilt
            else if {_rand} is 2:
                set pose of {_citizen_entity} to (0, 0, 0, random integer between -5 and 5, 0, 0) # Slight arm move
            else:
                set pose of {_citizen_entity} to (0,0,0,0,0,0) # Reset to default
            wait 10 ticks
            set pose of {_citizen_entity} to (0,0,0,0,0,0) # Ensure reset to default pose
    # For other entities: occasional particle puff or sound.
    else:
        if random integer between 1 and 200 <= 2: # 1% chance
            spawn 1 of crit at location of {_citizen_entity} ~ vector(0, 0.5, 0) with speed 0.05
    # send debug "[Citizens] Playing idle animation for %{_citizen_entity}%"

function playCitizenVictoryPose(citizen_entity: entity):
    if {_citizen_entity} is not set or {_citizen_entity} is not online:
        return
    # For Armor Stands: set a specific victory pose.
    if type of {_citizen_entity} is armor stand:
        set pose of {_citizen_entity} to (0, 0, 0, -140, 140, 0) # Example: Arms raised
        # Play a particle effect like fireworks or totems
        loop 5 times:
            spawn 1 of totem_of_undying at location of {_citizen_entity} ~ vector(random double between -0.5 and 0.5, 1.5 + random double between -0.2 and 0.2, random double between -0.5 and 0.5) with speed 0.1
            wait 2 ticks
    # For other entities: spawn celebratory particles.
    else:
        loop 10 times:
            spawn 1 of fireworks_spark at location of {_citizen_entity} ~ vector(random double between -0.5 and 0.5, 1, random double between -0.5 and 0.5) with speed 0.2
            wait 1 tick
    send debug "[Citizens] Playing victory pose for %{_citizen_entity}%"

# function playCitizenVictoryPose(citizen_entity: entity):
    # For Armor Stands: set a specific victory pose.
    # For other entities: spawn celebration particles (fireworks), play sounds.
    # spawn 1 of fireworks at location of {_citizen_entity}
    # send debug "[Citizens] Playing victory pose for %{_citizen_entity}%"

# function playCitizenIdleAnimation(citizen_entity: entity):
    # Small movements, looking around, etc.
    # send debug "[Citizens] Playing idle animation for %{_citizen_entity}%"

# --- Integration with Racing System (called by racing.sk) ---

# When a race starts for a player:
# racing.sk -> spawnRaceCitizen(player, start_location) -> returns citizen entity
# racing.sk -> stores this entity, passes it to camera.sk for 3rd person view

# During the race, as player's progress changes:
# racing.sk -> calculates new progress -> calls moveCitizenOnTrack(citizen_entity, track, new_progress)

# When a race ends:
# racing.sk -> removeRaceCitizen(player)

# Note: If not using the Citizens2 plugin, entity management (especially for non-living entities
# like Armor Stands) requires careful handling of persistence, chunk loading, and removal.
# Living entities like Villagers or Zombies will have their own AI unless fully disabled,
# which might interfere with precise movement control.
# File: performance_optimization.sk
# Description: Performance optimization system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Performance settings
    max_particles_per_player: 50 # Maximum particles per player
    particle_cleanup_interval: 10 ticks # How often to clean up particles
    max_updates_per_tick: 100 # Maximum updates per tick
    update_batch_size: 10 # Number of players to update per batch
    
# Variables:
# {player::%uuid%::particles::*} = text (list of active particles)
# {player::%uuid%::last_update_time} = timestamp (last update time)
# {player::%uuid%::update_priority} = number (update priority)

# Function to optimize particle effects
every {@particle_cleanup_interval}:
    loop all players:
        set {_p} to loop-player
        set {_uuid} to {_p}'s uuid
        
        # Clean up old particles
        if size of {player::%{_uuid}%::particles::*} > {@max_particles_per_player}:
            loop {player::%{_uuid}%::particles::*}:
                set {_particle} to loop-value
                remove {_particle} from {player::%{_uuid}%::particles::*}
                stop loop if size of {player::%{_uuid}%::particles::*} <= {@max_particles_per_player}
        
        # Optimize particle rendering
        if {player::%{_uuid}%::particles::*} is set:
            set {_count} to 0
            loop {player::%{_uuid}%::particles::*}:
                if {_count} >= {@max_particles_per_player}:
                    break
                add 1 to {_count}
            
            # Remove excess particles
            if {_count} > {@max_particles_per_player}:
                loop {player::%{_uuid}%::particles::*}:
                    remove loop-value from {player::%{_uuid}%::particles::*}
                    stop loop if size of {player::%{_uuid}%::particles::*} <= {@max_particles_per_player}

# Function to batch process updates
every 1 tick:
    set {_batch_size} to {@update_batch_size}
    set {_processed} to 0
    
    # Sort players by priority
    set {_players} to all players sorted by {player::%uuid%::update_priority} descending
    
    # Process players in batches
    loop {_players}:
        if {_processed} >= {@max_updates_per_tick}:
            break
            
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        
        # Update player state
        updatePlayerState({_p})
        
        # Update camera if in race
        if {player::%{_uuid}%::in_race} is true:
            updateCameraPosition({_p})
        
        # Update particles
        updateParticles({_p})
        
        add 1 to {_processed}
        
        # Break if reached batch size
        if {_processed} >= {_batch_size}:
            break

# Function to update player state
function updatePlayerState(p: player):
    set {_uuid} to {_p}'s uuid
    
    # Update click stats
    if {player::%{_uuid}%::clicks} is set:
        set {player::%{_uuid}%::clicks} to {player::%{_uuid}%::clicks}
    
    # Update race progress
    if {player::%{_uuid}%::in_race} is true:
        updateRaceProgress({_p})
    
    # Update achievements
    checkAchievements({_p})

# Function to update particles
function updateParticles(p: player):
    set {_uuid} to {_p}'s uuid
    
    if {player::%{_uuid}%::particles::*} is set:
        loop {player::%{_uuid}%::particles::*}:
            set {_particle} to loop-value
            
            # Update particle position
            set {_loc} to location of {_p}
            
            # Remove old particles
            if now - {player::%{_uuid}%::last_update_time} > 200 ticks:
                remove {_particle} from {player::%{_uuid}%::particles::*}

# Function to optimize memory usage
function optimizeMemory():
    # Clean up unused variables
    loop all players:
        set {_uuid} to loop-player's uuid
        
        # Clean up camera variables
        if {player::%{_uuid}%::in_race} is not true:
            delete {player::%{_uuid}%::camera::*}
        
        # Clean up race variables
        if {player::%{_uuid}%::in_race} is not true:
            delete {player::%{_uuid}%::race::*}
        
        # Clean up achievement variables
        if size of {player::%{_uuid}%::achievements::*} > 100:
            loop all keys of {player::%{_uuid}%::achievements::*}:
                if {player::%{_uuid}%::achievements::%loop-value%} is false:
                    delete {player::%{_uuid}%::achievements::%loop-value%}

# Function to set update priority
function setUpdatePriority(p: player, priority: number):
    set {_uuid} to {_p}'s uuid
    set {player::%{_uuid}%::update_priority} to {_priority}
    
    # Send debug message if enabled
    if {rc.debug_mode} is true:
        send "{@prefix} &7[Debug] Set update priority for %{_p}% to %{_priority}%" to console

# Function to get update priority
function getUpdatePriority(p: player) :: number:
    set {_uuid} to {_p}'s uuid
    return {player::%{_uuid}%::update_priority} ? 0

# Command to force optimization
command /optimize:
    permission: raceclicker.admin
    trigger:
        optimizeMemory()
        send "{@prefix} &aOptimized memory usage!" to player

# Event handler for player join
every player joins:
    set {_uuid} to player's uuid
    set {player::%{_uuid}%::update_priority} to 0
    set {player::%{_uuid}%::last_update_time} to now
    set {player::%{_uuid}%::particles::*} to []

# Event handler for player quit
every player quits:
    set {_uuid} to player's uuid
    delete {player::%{_uuid}%::*}
    optimizeMemory()
# File: prestige_eligibility.sk
# Description: Prestige eligibility system with detailed requirements

options:
    prefix: &6&lRaceClicker &8»

options:
    # Click requirements
    prestige_requirements::clicks_base: 1000000 # Base clicks needed
    prestige_requirements::clicks_per_prestige: 1000000 # Additional clicks needed per prestige level
    
    # Race requirements
    prestige_requirements::races_won_base: 100 # Base races won needed
    prestige_requirements::races_won_per_prestige: 50 # Additional races won needed per prestige level
    
    # Track completion requirements
    prestige_requirements::tracks_completed_base: 50 # Base tracks completed needed
    prestige_requirements::tracks_completed_per_prestige: 25 # Additional tracks needed per prestige level
    
    # Achievement requirements
    prestige_requirements::achievements_base: 50 # Base achievements needed
    prestige_requirements::achievements_per_prestige: 25 # Additional achievements needed per prestige level
    
    # Combo requirements
    prestige_requirements::max_combo_base: 100 # Base max combo needed
    prestige_requirements::max_combo_per_prestige: 50 # Additional combo needed per prestige level
    
    # Time requirements
    prestige_requirements::total_time_base: 36000 # Base time needed (in seconds - 10 hours)
    prestige_requirements::total_time_per_prestige: 18000 # Additional time needed per prestige level (in seconds - 5 hours)
    
    # Multiplayer requirements
    prestige_requirements::multiplayer_wins_base: 50 # Base multiplayer wins needed
    prestige_requirements::multiplayer_wins_per_prestige: 25 # Additional multiplayer wins needed per prestige level

options:
    # Power bonus per prestige
    prestige_rewards::power_bonus: 2.0 # Multiplier for click power
    
    # Speed bonus per prestige
    prestige_rewards::speed_bonus: 1.5 # Multiplier for speed
    
    # Combo bonus per prestige
    prestige_rewards::combo_bonus: 1.2 # Multiplier for combo
    
    # Accuracy bonus per prestige
    prestige_rewards::accuracy_bonus: 1.1 # Multiplier for accuracy
    
    # Points bonus per prestige
    prestige_rewards::points_bonus: 5000 # Points awarded per prestige
    
    # Achievement bonus per prestige
    prestige_rewards::achievement_bonus: 10 # Achievements unlocked per prestige

# Function to check prestige eligibility
function checkPrestigeEligibility(p: player) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_current_prestige} to {player::%{_uuid}%::prestige_level} ? 0
    
    # Check all requirements
    if not checkClickRequirement({_p}, {_current_prestige}):
        return false
    if not checkRaceRequirement({_p}, {_current_prestige}):
        return false
    if not checkTrackRequirement({_p}, {_current_prestige}):
        return false
    if not checkAchievementRequirement({_p}, {_current_prestige}):
        return false
    if not checkComboRequirement({_p}, {_current_prestige}):
        return false
    if not checkTimeRequirement({_p}, {_current_prestige}):
        return false
    if not checkMultiplayerRequirement({_p}, {_current_prestige}):
        return false
    
    return true

# Function to check click requirement
function checkClickRequirement(p: player, prestige_level: number) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_clicks} to {player::%{_uuid}%::clicks} ? 0
    set {_required_clicks} to {@prestige_requirements::clicks_base} + ({@prestige_requirements::clicks_per_prestige} * {_prestige_level})
    return {_clicks} >= {_required_clicks}

# Function to check race requirement
function checkRaceRequirement(p: player, prestige_level: number) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_races_won} to {player::%{_uuid}%::races_won} ? 0
    set {_required_races} to {@prestige_requirements::races_won_base} + ({@prestige_requirements::races_won_per_prestige} * {_prestige_level})
    return {_races_won} >= {_required_races}

# Function to check track requirement
function checkTrackRequirement(p: player, prestige_level: number) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_tracks_completed} to {player::%{_uuid}%::tracks_completed} ? 0
    set {_required_tracks} to {@prestige_requirements::tracks_completed_base} + ({@prestige_requirements::tracks_completed_per_prestige} * {_prestige_level})
    return {_tracks_completed} >= {_required_tracks}

# Function to check achievement requirement
function checkAchievementRequirement(p: player, prestige_level: number) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_achievements} to 0
    loop all keys of {achievements_list::*}:
        if {player::%{_uuid}%::achievements::%loop-value%} is true:
            add 1 to {_achievements}
    set {_required_achievements} to {@prestige_requirements::achievements_base} + ({@prestige_requirements::achievements_per_prestige} * {_prestige_level})
    return {_achievements} >= {_required_achievements}

# Function to check combo requirement
function checkComboRequirement(p: player, prestige_level: number) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_max_combo} to {player::%{_uuid}%::max_combo} ? 0
    set {_required_combo} to {@prestige_requirements::max_combo_base} + ({@prestige_requirements::max_combo_per_prestige} * {_prestige_level})
    return {_max_combo} >= {_required_combo}

# Function to check time requirement
function checkTimeRequirement(p: player, prestige_level: number) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_total_time} to {player::%{_uuid}%::total_time} ? 0
    set {_required_time} to {@prestige_requirements::total_time_base} + ({@prestige_requirements::total_time_per_prestige} * {_prestige_level})
    return {_total_time} >= {_required_time}

# Function to check multiplayer requirement
function checkMultiplayerRequirement(p: player, prestige_level: number) :: boolean:
    set {_uuid} to {_p}'s uuid
    set {_multiplayer_wins} to {player::%{_uuid}%::multiplayer_wins} ? 0
    set {_required_wins} to {@prestige_requirements::multiplayer_wins_base} + ({@prestige_requirements::multiplayer_wins_per_prestige} * {_prestige_level})
    return {_multiplayer_wins} >= {_required_wins}

# Function to get prestige requirements
function getPrestigeRequirements(p: player) :: text:
    set {_uuid} to {_p}'s uuid
    set {_current_prestige} to {player::%{_uuid}%::prestige_level} ? 0
    
    set {_clicks} to {player::%{_uuid}%::clicks} ? 0
    set {_races_won} to {player::%{_uuid}%::races_won} ? 0
    set {_tracks_completed} to {player::%{_uuid}%::tracks_completed} ? 0
    set {_achievements} to 0
    loop all keys of {achievements_list::*}:
        if {player::%{_uuid}%::achievements::%loop-value%} is true:
            add 1 to {_achievements}
    set {_max_combo} to {player::%{_uuid}%::max_combo} ? 0
    set {_total_time} to {player::%{_uuid}%::total_time} ? 0
    set {_multiplayer_wins} to {player::%{_uuid}%::multiplayer_wins} ? 0
    
    set {_req_clicks} to {@prestige_requirements::clicks_base} + ({@prestige_requirements::clicks_per_prestige} * {_current_prestige})
    set {_req_races} to {@prestige_requirements::races_won_base} + ({@prestige_requirements::races_won_per_prestige} * {_current_prestige})
    set {_req_tracks} to {@prestige_requirements::tracks_completed_base} + ({@prestige_requirements::tracks_completed_per_prestige} * {_current_prestige})
    set {_req_achievements} to {@prestige_requirements::achievements_base} + ({@prestige_requirements::achievements_per_prestige} * {_current_prestige})
    set {_req_combo} to {@prestige_requirements::max_combo_base} + ({@prestige_requirements::max_combo_per_prestige} * {_current_prestige})
    set {_req_time} to {@prestige_requirements::total_time_base} + ({@prestige_requirements::total_time_per_prestige} * {_current_prestige})
    set {_req_wins} to {@prestige_requirements::multiplayer_wins_base} + ({@prestige_requirements::multiplayer_wins_per_prestige} * {_current_prestige})
    
    return "&6Prestige Requirements (Level %{_current_prestige}%):\n" +
        "&eClicks: &a%{_clicks}%/%{_req_clicks}%\n" +
        "&eRaces Won: &a%{_races_won}%/%{_req_races}%\n" +
        "&eTracks Completed: &a%{_tracks_completed}%/%{_req_tracks}%\n" +
        "&eAchievements: &a%{_achievements}%/%{_req_achievements}%\n" +
        "&eMax Combo: &a%{_max_combo}%/%{_req_combo}%\n" +
        "&eTime Played: &a%{_total_time}%/%{_req_time}%\n" +
        "&eMultiplayer Wins: &a%{_multiplayer_wins}%/%{_req_wins}%"

# Command to check prestige requirements
command /prestige:
    trigger:
        send "{@prefix} %{getPrestigeRequirements(player)}%" to player
        if checkPrestigeEligibility(player) is true:
            send "{@prefix} &aYou are eligible for prestige! Type /prestigeup to prestige!" to player
        else:
            send "{@prefix} &cYou need to meet all requirements to prestige!" to player

# Command to prestige up
command /prestigeup:
    trigger:
        if checkPrestigeEligibility(player) is true:
            prestigeUp(player)
        else:
            send "{@prefix} &cYou don't meet the requirements to prestige yet!" to player

# Function to prestige up
function prestigeUp(p: player):
    set {_uuid} to {_p}'s uuid
    set {_current_prestige} to {player::%{_uuid}%::prestige_level} ? 0
    
    # Reset stats
    set {player::%{_uuid}%::clicks} to 0
    set {player::%{_uuid}%::races_won} to 0
    set {player::%{_uuid}%::tracks_completed} to 0
    set {player::%{_uuid}%::max_combo} to 0
    set {player::%{_uuid}%::total_time} to 0
    set {player::%{_uuid}%::multiplayer_wins} to 0
    
    # Increment prestige level
    add 1 to {_current_prestige}
    set {player::%{_uuid}%::prestige_level} to {_current_prestige}
    
    # Apply prestige rewards
    set {_power_bonus} to {@prestige_rewards::power_bonus} * {_current_prestige}
    set {_speed_bonus} to {@prestige_rewards::speed_bonus} * {_current_prestige}
    set {_combo_bonus} to {@prestige_rewards::combo_bonus} * {_current_prestige}
    set {_accuracy_bonus} to {@prestige_rewards::accuracy_bonus} * {_current_prestige}
    set {_points_bonus} to {@prestige_rewards::points_bonus} * {_current_prestige}
    set {_achievement_bonus} to {@prestige_rewards::achievement_bonus} * {_current_prestige}
    
    # Update bonuses
    set {player::%{_uuid}%::prestige_bonus_click_power} to {_power_bonus}
    set {player::%{_uuid}%::prestige_bonus_speed} to {_speed_bonus}
    set {player::%{_uuid}%::prestige_bonus_combo} to {_combo_bonus}
    set {player::%{_uuid}%::prestige_bonus_accuracy} to {_accuracy_bonus}
    
    # Give points and achievements
    add {_points_bonus} to {player::%{_uuid}%::points}
    
    # Send message
    send title "&6Prestige Up!" to {_p} with subtitle "&eLevel %{_current_prestige}%" for 3 seconds    send "{@prefix} &aYou've prestiged to Level %{_current_prestige}%!\n" +
    "&ePower Bonus: &a+%{_power_bonus}x\n" +
    "&eSpeed Bonus: &a+%{_speed_bonus}x\n" +
    "&eCombo Bonus: &a+%{_combo_bonus}x\n" +
    "&eAccuracy Bonus: &a+%{_accuracy_bonus}x\n" +
    "&ePoints Bonus: &a+%{_points_bonus}\n" +
    "&eAchievement Bonus: &a+%{_achievement_bonus}" to {_p}
    
    # Play prestige sound
    play sound "minecraft:entity.player.levelup" to {_p} with volume 1 pitch 2.0
    
    # Broadcast to nearby players
    broadcast "{@prefix} &6%{_p}% has prestiged to Level %{_current_prestige}%!" to players within 100 blocks of {_p}

function showPrestigeProgress(p: player):
    "&eClicks: &a%{_clicks}%/%{_req_clicks}%\n" +
    "&eRaces Won: &a%{_races_won}%/%{_req_races}%\n" +
    "&eTracks Completed: &a%{_tracks_completed}%/%{_req_tracks}%\n" +
    "&eAchievements: &a%{_achievements}%/%{_req_achievements}%\n" +
    "&eMax Combo: &a%{_max_combo}%/%{_req_combo}%\n" +
    "&eTime Played: &a%{_total_time}%/%{_req_time}%\n" +
    "&eMultiplayer Wins: &a%{_multiplayer_wins}%/%{_req_wins}%"

function showPrestigeBonuses(p: player):
    "&ePower Bonus: &a+%{_power_bonus}x\n" +
    "&eSpeed Bonus: &a+%{_speed_bonus}x\n" +
    "&eCombo Bonus: &a+%{_combo_bonus}x\n" +
    "&eAccuracy Bonus: &a+%{_accuracy_bonus}x\n" +
    "&ePoints Bonus: &a+%{_points_bonus}\n" +
    "&eAchievement Bonus: &a+%{_achievement_bonus}" to {_p}
# File: prestige_system.sk
# Description: Prestige system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Prestige settings
    prestige_levels: ["Bronze", "Silver", "Gold", "Platinum", "Diamond", "Master", "Grandmaster", "Champion"]
    
    # Prestige requirements
    prestige_requirements:
        bronze: 1000000
        silver: 5000000
        gold: 10000000
        platinum: 50000000
        diamond: 100000000
        master: 500000000
        grandmaster: 1000000000
        champion: 5000000000
    
    # Prestige rewards
    prestige_rewards:
        bronze: ["ClickCoins:100000", "Speed Boost:500", "Prestige Title:Bronze"]
        silver: ["ClickCoins:250000", "Speed Boost:1000", "Power Boost:500", "Prestige Title:Silver"]
        gold: ["ClickCoins:500000", "Speed Boost:2000", "Power Boost:1000", "Combo Boost:500", "Prestige Title:Gold"]
        platinum: ["ClickCoins:1000000", "Speed Boost:5000", "Power Boost:2000", "Combo Boost:1000", "Accuracy Boost:500", "Prestige Title:Platinum"]
        diamond: ["ClickCoins:2000000", "Speed Boost:10000", "Power Boost:5000", "Combo Boost:2000", "Accuracy Boost:1000", "Prestige Title:Diamond"]
        master: ["ClickCoins:5000000", "Speed Boost:20000", "Power Boost:10000", "Combo Boost:5000", "Accuracy Boost:2000", "Prestige Title:Master", "Special Item:Master's Token"]
        grandmaster: ["ClickCoins:10000000", "Speed Boost:50000", "Power Boost:20000", "Combo Boost:10000", "Accuracy Boost:5000", "Prestige Title:Grandmaster", "Special Item:Grandmaster's Token", "Guild Boost:1000"]
        champion: ["ClickCoins:50000000", "Speed Boost:100000", "Power Boost:50000", "Combo Boost:20000", "Accuracy Boost:10000", "Prestige Title:Champion", "Special Item:Champion's Token", "Guild Boost:2000", "Market Boost:1000"]

# Variables:
# {player::%uuid%::prestige_level} = text (current prestige level)
# {player::%uuid%::prestige_points} = number (prestige points)
# {player::%uuid%::prestige_title} = text (prestige title)
# {player::%uuid%::prestige_rewards::*} = text (claimed prestige rewards)

# Function to initialize prestige system
on join:
    set {_p} to player
    set {_uuid} to {_p}'s uuid
    
    # Initialize prestige variables
    if not {player::%{_uuid}%::prestige_level} is set:
        set {player::%{_uuid}%::prestige_level} to "Bronze"
    if not {player::%{_uuid}%::prestige_points} is set:
        set {player::%{_uuid}%::prestige_points} to 0
    if not {player::%{_uuid}%::prestige_title} is set:
        set {player::%{_uuid}%::prestige_title} to "Bronze"
    if not {player::%{_uuid}%::prestige_rewards::*} is set:
        set {player::%{_uuid}%::prestige_rewards::*} to []

# Function to check prestige requirements
function checkPrestigeRequirements(p: player):
    set {_uuid} to {_p}'s uuid
    set {_current_level} to {player::%{_uuid}%::prestige_level}
    set {_current_index} to index of {_current_level} in {@prestige_levels}
    
    # Check if player can prestige
    if {_current_index} < size of {@prestige_levels} - 1:
        set {_next_level} to element of {@prestige_levels} at {_current_index} + 1
        set {_required_points} to {@prestige_requirements::%{_next_level}%}
        
        if {player::%{_uuid}%::clickcoins} >= {_required_points}:
            # Check if player has already claimed this prestige level
            if {_next_level} in {player::%{_uuid}%::prestige_rewards::*}:
                send "{@prefix} &cYou have already claimed this prestige level!" to {_p}
                return
            
            # Give prestige rewards
            givePrestigeRewards({_p}, {_next_level})
            
            # Update prestige level
            set {player::%{_uuid}%::prestige_level} to {_next_level}
            set {player::%{_uuid}%::prestige_title} to {_next_level}
            
            # Reset ClickCoins
            set {player::%{_uuid}%::clickcoins} to 0
            
            # Update prestige rewards list
            add {_next_level} to {player::%{_uuid}%::prestige_rewards::*}
            
            # Notify player
            send "{@prefix} &6Prestige Upgraded! New level: %{_next_level}%" to {_p}
            broadcast "{@prefix} &6%{_p}% reached prestige level %{_next_level}%!" to players with permission "raceclicker.prestige.view"

# Function to give prestige rewards
function givePrestigeRewards(p: player, level: text):
    set {_uuid} to {_p}'s uuid
    
    # Get rewards for this level
    set {_rewards} to {@prestige_rewards::%{_level}%}
    
    # Give each reward
    loop {_rewards}:
        set {_reward} to loop-value
        split {_reward} by ":"
        set {_type} to element 0 of {_reward}
        set {_amount} to element 1 of {_reward} as number
        
        switch {_type}:
            case "ClickCoins":
                add {_amount} to {player::%{_uuid}%::clickcoins}
                break
            case "Speed Boost":
                add {_amount} to {player::%{_uuid}%::speed_boost}
                break
            case "Power Boost":
                add {_amount} to {player::%{_uuid}%::power_boost}
                break
            case "Combo Boost":
                add {_amount} to {player::%{_uuid}%::combo_boost}
                break
            case "Accuracy Boost":
                add {_amount} to {player::%{_uuid}%::accuracy_boost}
                break
            case "Prestige Title":
                set {player::%{_uuid}%::prestige_title} to {_amount}
                break
            case "Special Item":
                give {_amount} to {_p}
                break
            case "Guild Boost":
                add {_amount} to {player::%{_uuid}%::guild_boost}
                break
            case "Market Boost":
                add {_amount} to {player::%{_uuid}%::market_boost}
                break
            case "Prestige Points":
                add {_amount} to {player::%{_uuid}%::prestige_points}
                break
            case "Track Boost":
                add {_amount} to {player::%{_uuid}%::track_boost}
                break
            case "Race Boost":
                add {_amount} to {player::%{_uuid}%::race_boost}
                break
            case "Combo Multiplier":
                add {_amount} to {player::%{_uuid}%::combo_multiplier}
                break
            case "Click Multiplier":
                add {_amount} to {player::%{_uuid}%::click_multiplier}
                break
        
        # Send reward notification
        send "{@prefix} &6Received %{_amount}% %{_type}% from prestige level %{_level}%" to {_p}

# Function to prestige
command /prestige:
    permission: raceclicker.prestige
    trigger:
        set {_p} to player
        set {_uuid} to {_p}'s uuid
        
        # Check if player can prestige
        if {player::%{_uuid}%::prestige_level} is "Champion":
            send "{@prefix} &cYou have reached the maximum prestige level!" to {_p}
            return
            
        set {_current_level} to {player::%{_uuid}%::prestige_level}
        set {_current_index} to index of {_current_level} in {@prestige_levels}
        set {_next_level} to element of {@prestige_levels} at {_current_index} + 1
        set {_required_points} to {@prestige_requirements::%{_next_level}%}
        
        if {player::%{_uuid}%::clickcoins} < {_required_points}:
            send "{@prefix} &cYou need %{_required_points}% ClickCoins to prestige!" to {_p}
            return
            
        # Confirm prestige
        send "{@prefix} &6Type /prestigeconfirm to confirm prestige to %{_next_level}%" to {_p}
        set {player::%{_uuid}%::prestige_confirm} to true
        wait 30 seconds
        if {player::%{_uuid}%::prestige_confirm} is true:
            set {player::%{_uuid}%::prestige_confirm} to false
            send "{@prefix} &cPrestige confirmation expired!" to {_p}

command /prestigeconfirm:
    permission: raceclicker.prestige
    trigger:
        set {_p} to player
        set {_uuid} to {_p}'s uuid
        
        if {player::%{_uuid}%::prestige_confirm} is not true:
            send "{@prefix} &cNo pending prestige confirmation!" to {_p}
            return
            
        # Process prestige
        checkPrestigeRequirements({_p})
        set {player::%{_uuid}%::prestige_confirm} to false

# Function to view prestige
command /prestigeview:
    permission: raceclicker.prestige.view
    trigger:
        set {_p} to player
        set {_uuid} to {_p}'s uuid
        
        # Get current prestige info
        set {_current_level} to {player::%{_uuid}%::prestige_level}
        set {_current_index} to index of {_current_level} in {@prestige_levels}
        
        # Get next level info
        if {_current_index} < size of {@prestige_levels} - 1:
            set {_next_level} to element of {@prestige_levels} at {_current_index} + 1
            set {_required_points} to {@prestige_requirements::%{_next_level}%}
            set {_progress} to "&eNext Level: %{_next_level}% &7(%{player::%{_uuid}%::clickcoins}%/%{_required_points}% ClickCoins)"
        else:
            set {_progress} to "&eMaximum Prestige Level Reached!"
            
        # Get prestige rewards
        set {_rewards} to "&6Prestige Rewards:\n"
        loop {@prestige_rewards::%{_current_level}%}:
            split loop-value by ":"
            set {_type} to element 0 of loop-value
            set {_amount} to element 1 of loop-value
            append "&7- %{_type}%: &a%{_amount}%\n" to {_rewards}
            
        # Send info
        send "{@prefix} &6Prestige Info:\n" to {_p}
        send "{@prefix} &eCurrent Level: &a%{_current_level}%" to {_p}
        send "{@prefix} %{_progress}%" to {_p}
        send "{@prefix} %{_rewards}%" to {_p}

# Function to view prestige leaderboard
every 5 minutes:
    set {_leaderboard} to "&6Prestige Leaderboard:\n"
    set {_players::*} to all players

    broadcast "{@prefix} %{_leaderboard}%" to players with permission "raceclicker.prestige.view"
    
    loop {_players}:
        set {_index} to loop-index
        if {_index} > 10:
            break
            
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        append "&7%{_index}%. %{_p}% &8(&6%{player::%{_uuid}%::prestige_level}%&8) &e%{player::%{_uuid}%::prestige_points}% points\n" to {_leaderboard}
        
    broadcast "{@prefix} %{_leaderboard}%" to players with permission "raceclicker.prestige.leaderboard"
# File: quest_system.sk
# Description: Quest system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Quest settings
    daily_quest_reset: 00:00 # Daily quest reset time
    weekly_quest_reset: monday 00:00 # Weekly quest reset time
    
    # Quest types
    quest_types:
        - "Click Challenge"
        - "Race Challenge"
        - "Track Challenge"
        - "Achievement Challenge"
        - "Social Challenge"
        - "Event Challenge"
        - "Combo Challenge"
        - "Speed Challenge"
        - "Power Challenge"
    
    # Quest rewards
    quest_rewards:
        daily: 1000
        weekly: 2000
        monthly: 5000
        special: 10000
    
    # Quest difficulties
    quest_difficulties:
        easy: 1
        medium: 2
        hard: 3
        expert: 4
        master: 5

# Variables:
# {player::%uuid%::quests::*} = text (active quests)
# {player::%uuid%::quest_progress::*} = number (quest progress)
# {player::%uuid%::completed_quests::*} = text (completed quests)
# {quest::%id%::type} = text (quest type)
# {quest::%id%::target} = number (quest target)
# {quest::%id%::reward} = number (quest reward)
# {quest::%id%::difficulty} = number (quest difficulty)
# {quest::%id%::description} = text (quest description)

# Function to generate daily quests
every day at {@daily_quest_reset}:
    loop all players:
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        
        # Clear old quests
        clearQuests({_p})
        
        # Generate new quests
        generateQuests({_p}, 3)

# Function to generate weekly quests
every week at {@weekly_quest_reset}:
    loop all players:
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        
        # Clear old quests
        clearQuests({_p})
        
        # Generate new quests
        generateQuests({_p}, 5)

# Function to clear quests
function clearQuests(p: player):
    set {_uuid} to {_p}'s uuid
    
    # Clear active quests
    delete {player::%{_uuid}%::quests::*}
    delete {player::%{_uuid}%::quest_progress::*}
    
    # Archive completed quests
    loop {player::%{_uuid}%::completed_quests::*}:
        add loop-value to {player::%{_uuid}%::quest_history::*}
    
    # Clear completed quests
    delete {player::%{_uuid}%::completed_quests::*}

# Function to generate quests
function generateQuests(p: player, count: number):
    set {_uuid} to {_p}'s uuid
    
    # Generate quests
    loop count times:
        set {_quest_id} to "quest_%{_uuid}%_%{loop-index}%"
        
        # Choose random quest type
        set {_type} to random element of {@quest_types::*}
        
        # Set quest parameters
        switch {_type}:
            case "Click Challenge":
                set {_target} to random number between 1000 and 5000
                set {_reward} to random number between 100 and 500
                set {_difficulty} to random number between 1 and 3
                set {_description} to "Click %{_target}% times"
                break
            case "Race Challenge":
                set {_target} to random number between 3 and 10
                set {_reward} to random number between 200 and 800
                set {_difficulty} to random number between 2 and 4
                set {_description} to "Win %{_target}% races"
                break
            case "Track Challenge":
                set {_target} to random number between 5 and 15
                set {_reward} to random number between 150 and 600
                set {_difficulty} to random number between 2 and 4
                set {_description} to "Complete %{_target}% tracks"
                break
            case "Achievement Challenge":
                set {_target} to random number between 1 and 5
                set {_reward} to random number between 100 and 300
                set {_difficulty} to random number between 2 and 4
                set {_description} to "Unlock %{_target}% achievements"
                break
            case "Social Challenge":
                set {_target} to random number between 5 and 20
                set {_reward} to random number between 50 and 200
                set {_difficulty} to random number between 1 and 3
                set {_description} to "Make %{_target}% friends"
                break
            case "Event Challenge":
                set {_target} to random number between 1 and 3
                set {_reward} to random number between 200 and 500
                set {_difficulty} to random number between 2 and 4
                set {_description} to "Complete %{_target}% events"
                break
            case "Combo Challenge":
                set {_target} to random number between 50 and 200
                set {_reward} to random number between 100 and 400
                set {_difficulty} to random number between 2 and 4
                set {_description} to "Achieve %{_target}% combo"
                break
            case "Speed Challenge":
                set {_target} to random number between 100 and 500
                set {_reward} to random number between 150 and 600
                set {_difficulty} to random number between 2 and 4
                set {_description} to "Reach %{_target}% speed"
                break
            case "Power Challenge":
                set {_target} to random number between 50 and 200
                set {_reward} to random number between 100 and 400
                set {_difficulty} to random number between 2 and 4
                set {_description} to "Achieve %{_target}% power"
                break
        
        # Store quest data
        set {quest::%{_quest_id}%::type} to {_type}
        set {quest::%{_quest_id}%::target} to {_target}
        set {quest::%{_quest_id}%::reward} to {_reward}
        set {quest::%{_quest_id}%::difficulty} to {_difficulty}
        set {quest::%{_quest_id}%::description} to {_description}
        add {_quest_id} to {player::%{_uuid}%::quests::*}
        set {player::%{_uuid}%::quest_progress::%{_quest_id}%} to 0
    
    # Send quest notification
    send "{@prefix} &aNew quests generated! Check your quest log!" to {_p}

# Function to check quest progress
every 1 tick:
    loop all players:
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        
        # Check all quests
        loop {player::%{_uuid}%::quests::*}:
            set {_quest_id} to loop-value
            set {_type} to {quest::%{_quest_id}%::type}
            
            # Check progress based on quest type
            switch {_type}:
                case "Click Challenge":
                    add {player::%{_uuid}%::clicks} to {player::%{_uuid}%::quest_progress::%{_quest_id}%}
                    break
                case "Race Challenge":
                    add {player::%{_uuid}%::races_won} to {player::%{_uuid}%::quest_progress::%{_quest_id}%}
                    break
                case "Track Challenge":
                    add {player::%{_uuid}%::tracks_completed} to {player::%{_uuid}%::quest_progress::%{_quest_id}%}
                    break
                case "Achievement Challenge":
                    add {player::%{_uuid}%::achievements_unlocked} to {player::%{_uuid}%::quest_progress::%{_quest_id}%}
                    break
                case "Social Challenge":
                    add {player::%{_uuid}%::friends_added} to {player::%{_uuid}%::quest_progress::%{_quest_id}%}
                    break
                case "Event Challenge":
                    add {player::%{_uuid}%::events_completed} to {player::%{_uuid}%::quest_progress::%{_quest_id}%}
                    break
                case "Combo Challenge":
                    if {player::%{_uuid}%::max_combo} >= {quest::%{_quest_id}%::target}:
                        set {player::%{_uuid}%::quest_progress::%{_quest_id}%} to {quest::%{_quest_id}%::target}
                    break
                case "Speed Challenge":
                    if {player::%{_uuid}%::speed} >= {quest::%{_quest_id}%::target}:
                        set {player::%{_uuid}%::quest_progress::%{_quest_id}%} to {quest::%{_quest_id}%::target}
                    break
                case "Power Challenge":
                    if {player::%{_uuid}%::power} >= {quest::%{_quest_id}%::target}:
                        set {player::%{_uuid}%::quest_progress::%{_quest_id}%} to {quest::%{_quest_id}%::target}
                    break
            
            # Check if quest is complete
            if {player::%{_uuid}%::quest_progress::%{_quest_id}%} >= {quest::%{_quest_id}%::target}:
                completeQuest({_p}, {_quest_id})

# Function to complete quest
function completeQuest(p: player, quest_id: text):
    set {_uuid} to {_p}'s uuid
    
    # Give quest reward
    add {quest::%{quest_id}%::reward} to {player::%{_uuid}%::clickcoins}
    
    # Add quest to completed
    add quest_id to {player::%{_uuid}%::completed_quests::*}
    
    # Remove quest
    remove quest_id from {player::%{_uuid}%::quests::*}
    delete {player::%{_uuid}%::quest_progress::%{quest_id}%}
    
    # Send completion message
    send "{@prefix} &aCompleted quest: %{quest::%{quest_id}%::description}%" to {_p}
    send "{@prefix} &aReward: %{quest::%{quest_id}%::reward}% ClickCoins!" to {_p}
    
    # Check quest achievements
    checkQuestAchievements({_p})

# Function to check quest achievements
function checkQuestAchievements(p: player):
    set {_uuid} to {_p}'s uuid
    set {_completed} to size of {player::%{_uuid}%::completed_quests::*}
    
    # Quest completion achievements
    loop [10, 50, 100, 200, 500]:
        if {_completed} >= loop-value:
            if {player::%{_uuid}%::achievements::quests_%{loop-value}%} is not true:
                unlockAchievement({_p}, "Quest Master %{loop-value}%")

# Function to get quest status
function getQuestStatus(p: player) :: text:
    set {_uuid} to {_p}'s uuid
    set {_status} to "&6Quest Status:\n"
    
    # Active quests
    if {player::%{_uuid}%::quests::*} is not empty:
        append "&eActive Quests:\n" to {_status}
        loop {player::%{_uuid}%::quests::*}:
            set {_quest_id} to loop-value
            set {_progress} to {player::%{_uuid}%::quest_progress::%{_quest_id}%}
            set {_target} to {quest::%{_quest_id}%::target}
            set {_reward} to {quest::%{_quest_id}%::reward}
            set {_description} to {quest::%{_quest_id}%::description}
            append "&7- %{_description}%: &a%{_progress}%/%{_target}% &e(Reward: %{_reward}% ClickCoins)\n" to {_status}
    else:
        append "&cNo active quests!" to {_status}
    
    # Completed quests
    if {player::%{_uuid}%::completed_quests::*} is not empty:
        append "&eCompleted Quests:\n" to {_status}
        loop {player::%{_uuid}%::completed_quests::*}:
            set {_quest_id} to loop-value
            set {_description} to {quest::%{_quest_id}%::description}
            append "&7- %{_description}%\n" to {_status}
    
    return {_status}

# Command to view quests
command /quests:
    trigger:
        send "{@prefix} %{getQuestStatus(player)}%" to player

# Command to view quest rewards
command /questrewards:
    trigger:
        send "{@prefix} &6Quest Rewards:\n" to player
        send "&eDaily Quests: &a%{@quest_rewards::daily}% ClickCoins" to player
        send "&eWeekly Quests: &a%{@quest_rewards::weekly}% ClickCoins" to player
        send "&eMonthly Quests: &a%{@quest_rewards::monthly}% ClickCoins" to player
        send "&eSpecial Quests: &a%{@quest_rewards::special}% ClickCoins" to player

# Command to view quest history
command /questhistory:
    trigger:
        set {_uuid} to player's uuid
        if {player::%{_uuid}%::quest_history::*} is not empty:
            send "{@prefix} &6Quest History:\n" to player
            loop {player::%{_uuid}%::quest_history::*}:
                set {_quest_id} to loop-value
                set {_description} to {quest::%{_quest_id}%::description}
                send "&7- %{_description}%" to player
        else:
            send "{@prefix} &cNo quest history!" to player

# Special event quests
on event start:
    set {_event} to event::current_event
    set {_quest_id} to "event_quest_%{_event}%"
    
    # Generate event quest
    set {quest::%{_quest_id}%::type} to "Event Challenge"
    set {quest::%{_quest_id}%::target} to 1
    set {quest::%{_quest_id}%::reward} to {@quest_rewards::special}
    set {quest::%{_quest_id}%::difficulty} to 5
    set {quest::%{_quest_id}%::description} to "Complete the %{_event}% event"
    
    # Give quest to all players
    loop all players:
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        add {_quest_id} to {player::%{_uuid}%::quests::*}
        set {player::%{_uuid}%::quest_progress::%{_quest_id}%} to 0
        send "{@prefix} &aNew event quest available! Check your quest log!" to {_p}

# Achievement quests
on achievement unlock:
    set {_p} to player
    set {_uuid} to {_p}'s uuid
    
    # Check achievement quest
    if {player::%{_uuid}%::achievements_unlocked} >= 5:
        set {_quest_id} to "achievement_quest"
        
        # Generate achievement quest
        set {quest::%{_quest_id}%::type} to "Achievement Challenge"
        set {quest::%{_quest_id}%::target} to 5
        set {quest::%{_quest_id}%::reward} to {@quest_rewards::special}
        set {quest::%{_quest_id}%::difficulty} to 4
        set {quest::%{_quest_id}%::description} to "Unlock 5 achievements"
        
        # Give quest if not already completed
        if {_quest_id} is not in {player::%{_uuid}%::completed_quests::*}:
            add {_quest_id} to {player::%{_uuid}%::quests::*}
            set {player::%{_uuid}%::quest_progress::%{_quest_id}%} to 5
            completeQuest({_p}, {_quest_id})

# Social quests
on friend request accept:
    set {_p} to player
    set {_uuid} to {_p}'s uuid
    
    # Check social quest
    if {player::%{_uuid}%::friends_added} >= 5:
        set {_quest_id} to "social_quest"
        
        # Generate social quest
        set {quest::%{_quest_id}%::type} to "Social Challenge"
        set {quest::%{_quest_id}%::target} to 5
        set {quest::%{_quest_id}%::reward} to {@quest_rewards::special}
        set {quest::%{_quest_id}%::difficulty} to 3
        set {quest::%{_quest_id}%::description} to "Make 5 friends"
        
        # Give quest if not already completed
        if {_quest_id} is not in {player::%{_uuid}%::completed_quests::*}:
            add {_quest_id} to {player::%{_uuid}%::quests::*}
            set {player::%{_uuid}%::quest_progress::%{_quest_id}%} to 5
            completeQuest({_p}, {_quest_id})

# Quest completion achievements
on quest complete:
    set {_p} to player
    set {_uuid} to {_p}'s uuid
    
    # Check quest completion achievements
    set {_completed} to size of {player::%{_uuid}%::completed_quests::*}
    loop [10, 50, 100, 200, 500]:
        if {_completed} >= loop-value:
            if {player::%{_uuid}%::achievements::quests_%{loop-value}%} is not true:
                unlockAchievement({_p}, "Quest Master %{loop-value}%")

# Function to unlock achievement
function unlockAchievement(p: player, achievement: text):
    set {_uuid} to {_p}'s uuid
    set {player::%{_uuid}%::achievements::%{achievement.lower}%} to true
    
    # Give achievement reward
    giveAchievementReward({_p}, achievement)
    
    # Send achievement message
    send "{@prefix} &aUnlocked Achievement: %{achievement}%" to {_p}
    broadcast "{@prefix} &6%{_p}% unlocked achievement: %{achievement}%" to players with permission "raceclicker.achievements"

# Function to give achievement reward
function giveAchievementReward(p: player, achievement: text):
    set {_uuid} to {_p}'s uuid
    
    # Base reward
    set {_reward} to 100
    
    # Special rewards
    switch achievement:
        case "Quest Master 500":
            set {_reward} to 500
            break
        case "Quest Master 200":
            set {_reward} to 300
            break
        case "Quest Master 100":
            set {_reward} to 200
            break
    
    # Add reward
    add {_reward} to {player::%{_uuid}%::clickcoins}
    send "{@prefix} &aEarned %{@achievement_bonus}% ClickCoins for achievement!" to {_p}
# File: race_clicker.sk
# Path: race-clicker/race_clicker.sk
# Description: Consolidated Skript file for Race Clicker. Contains all functionality in a single file.

options:
    prefix: &6&lRaceClicker &8»
    version: "0.1.0-alpha"
    debug_mode: true
    admin_permission: "raceclicker.admin"
    default_race_length: 1000
    countdown_seconds: 5
    max_players_per_race: 10
    min_players_to_start: 1

# --- Global Variables ---
# Race State
# {race::active} - boolean, true if a race is currently in countdown or progress
# {race::track_id} - string, ID of the current/upcoming track
# {race::status} - string, e.g., "lobby", "countdown", "inprogress", "finished"
# {race::players::*} - list of players participating in the current race
# {race::finished_players::*} - list of players who have finished, with their times/ranks
# {race::start_time} - timestamp when the race actually began (after countdown)

# Player-specific race variables
# {player::%uuid%::in_race} - boolean
# {player::%uuid%::current_track_id} - string
# {player::%uuid%::race_progress_current_race} - number (0 to track_length)
# {player::%uuid%::race_start_time_personal} - timestamp for personal race duration
# {player::%uuid%::race_citizen_entity_id} - from citizens integration

# Track Data
# {tracks::%track_id%::name} - Display name
# {tracks::%track_id%::length} - Total progress units needed to finish
# {tracks::%track_id%::start_location} - Location for spawning citizens
# {tracks::%track_id%::waypoints::*} - List of locations defining the path
# {tracks::%track_id%::finish_region} - A region defining the finish line
# {tracks::%track_id%::difficulty} - e.g., "Easy", "Medium", "Hard"
# {tracks::%track_id%::obstacles::*} - List of locations for obstacles
# {tracks::%track_id%::boost_pads::*} - List of locations for boost pads

# --- Initialization ---
on load:
    send console "&a[RaceClicker] Loading Race Clicker Skript v%{_version}%..."
    send console "&a[RaceClicker] Initializing core systems..."
    send console "&a[RaceClicker] Initializing race mechanics..."
    send console "&a[RaceClicker] Initializing player systems..."
    send console "&a[RaceClicker] Initializing admin tools..."
    
    # Initialize default track if none exists
    if not {tracks::testtrack1::name} is set:
        set {tracks::testtrack1::name} to "Test Track Alpha"
        set {tracks::testtrack1::length} to 500
        set {tracks::testtrack1::start_location} to location(0, 64, 0, "world")
        add location(10, 64, 0, "world") to {tracks::testtrack1::waypoints::*}
        add location(20, 64, 10, "world") to {tracks::testtrack1::waypoints::*}
        add location(20, 64, 20, "world") to {tracks::testtrack1::waypoints::*}
        set {tracks::testtrack1::finish_region_loc1} to location(18, 63, 28, "world")
        set {tracks::testtrack1::finish_region_loc2} to location(22, 68, 32, "world")
        send console "[RaceClicker] Initialized default track 'testtrack1'"
    
    set {race::status} to "lobby"
    send console "&a[RaceClicker] Skript loaded successfully. Debug mode is %{_debug_mode} ? "&aenabled" : "&cdisabled"%&a."

# --- Player Events ---
on join:
    wait 1 tick
    send "{@prefix} &7Welcome to Race Clicker! Type &e/rc help &7for commands." to player

on quit:
    if {player::%player's uuid%::in_race} is true:
        set {player::%player's uuid%::in_race} to false
        remove player from {race::players::*}
        if {race::status} is "inprogress" and size of {race::players::*} < {@min_players_to_start}:
            broadcast "{@prefix} &cAll players have left the race. Ending race."
            triggerRaceEnd()

# --- Race Mechanics ---
function startRaceCountdown(track_id: text):
    if not {race::status} is "lobby":
        broadcast "{@prefix} &cCannot start race: A race is already in progress or countdown (%{race::status}%)."
        return
    if not {_track_id} is set or not {tracks::%{_track_id}%::name} is set:
        broadcast "{@prefix} &cCannot start race: Track ID '%{_track_id}%' is invalid or not found."
        return
    if size of {race::players::*} < {@min_players_to_start}:
        broadcast "{@prefix} &cCannot start race: Not enough players. Need %{@min_players_to_start}%, have %{size of {race::players::*}}%"
        return

    set {race::track_id} to {_track_id}
    set {race::status} to "countdown"
    broadcast "{@prefix} &eRace on track &6%{tracks::%{_track_id}%::name}% &estarting in %{@countdown_seconds}% seconds!"

    loop {@countdown_seconds} times:
        set {_remaining_time} to {@countdown_seconds} - (loop-number - 1)
        broadcast "{@prefix} &eRace starting in &c%{_remaining_time}%..."
        loop {race::players::*}:
            set {_p_in_loop} to loop-value-1
            send title "&c%{_remaining_time}%" to {_p_in_loop} for 20 ticks
            play sound "block.note_block.pling" to {_p_in_loop} with pitch ((loop-number / {@countdown_seconds}) * 0.5) + 0.5
        wait 1 second
    
    triggerRaceStart({_track_id})

function triggerRaceStart(track_id: text):
    if not {race::status} is "countdown" or not {race::track_id} is {_track_id}:
        broadcast "{@prefix} &cRace start failed: Race status mismatch or track ID mismatch."
        return
    
    set {race::status} to "inprogress"
    set {race::start_time} to now
    clear {race::finished_players::*}
    
    loop {race::players::*}:
        set {_p} to loop-value-1
        set {_uuid} to {_p}'s uuid
        
        set {player::%{_uuid}%::in_race} to true
        set {player::%{_uuid}%::current_track_id} to {_track_id}
        set {player::%{_uuid}%::race_progress_current_race} to 0
        set {player::%{_uuid}%::race_start_time_personal} to now
        
        send "{@prefix} &aRace started! Good luck!" to {_p}
        send title "&a&lGO!" to {_p} with subtitle "&eRace has started!" for 40 ticks
        play sound "entity.ender_dragon.growl" to {_p} with pitch 1.2

function playerFinishRace(p: player):
    if not {player::%{_p}'s uuid%::in_race} is true or not {race::status} is "inprogress":
        return

    set {_time_taken} to now - {player::%{_p}'s uuid%::race_start_time_personal}
    add {_p} to {race::finished_players::*}
    set {_rank} to size of {race::finished_players::*}
    set {race::finished_players::%{_p}%::time} to {_time_taken}
    set {race::finished_players::%{_p}%::rank} to {_rank}

    set {player::%{_p}'s uuid%::in_race} to false
    add 1 to {player::%{_p}'s uuid%::total_races_participated}

    broadcast "{@prefix} &6%{_p}% &ehas finished the race in position &a#%size of {race::finished_players::*}% &ewith a time of &b%formatTimespan({_time_taken})%&e!"
    send "{@prefix} &aYou finished! Rank: #%size of {race::finished_players::*}%. Time: %formatTimespan({_time_taken})%" to {_p}
    send title "&6&lFINISHED!" to {_p} with subtitle "&eRank #%size of {race::finished_players::*}% | Time: %formatTimespan({_time_taken})%" for 80 ticks
    play sound "entity.player.levelup" to {_p}

    # Distribute rewards based on rank
    set {_rank} to {race::finished_players::%{_p}%::rank}
    set {_reward_clicks} to 0
    if {_rank} is 1:
        set {_reward_clicks} to 100
        add 1 to {player::%{_p}'s uuid%::races_won_global}
    else if {_rank} is 2:
        set {_reward_clicks} to 50
    else if {_rank} is 3:
        set {_reward_clicks} to 25
    else:
        set {_reward_clicks} to 10
    
    if {_reward_clicks} > 0:
        add {_reward_clicks} to {player::%{_p}'s uuid%::clicks}
        send "{@prefix} &eYou earned &6%{_reward_clicks}% clicks &efor finishing rank &a#%{_rank}%!" to {_p}

    # Check if all players finished
    if size of {race::finished_players::*} is equal to size of {race::players::*}:
        triggerRaceEnd()

function triggerRaceEnd():
    if not {race::status} is "inprogress" and not {race::status} is "finished":
        return
    broadcast "{@prefix} &eThe race on &6%{tracks::%{race::track_id}%::name}% &ehas concluded!"
    set {race::status} to "finished"

    # Display leaderboard for the race
    broadcast "{@prefix} &lRace Results:"
    sort {race::finished_players::*} by {race::finished_players::%loop-value%::time} numerically
    loop {race::finished_players::*}:
        set {_player} to loop-value
        broadcast "&7- &e#%loop-index%: &b%{_player}% &7(&a%formatTimespan({race::finished_players::%{_player}%::time})%&7)"

    # Cleanup remaining players
    loop {race::players::*}:
        if {player::%loop-value's uuid%::in_race} is true:
            set {player::%loop-value's uuid%::in_race} to false
            send "{@prefix} &cThe race has ended." to loop-value

    clear {race::players::*}
    set {race::status} to "lobby"

# --- Race Movement Update Loop ---
every 10 ticks:
    if {race::status} is not "inprogress":
        stop

    loop {race::players::*}:
        set {_player} to loop-value-1
        if {player::%{_player}'s uuid%::in_race} is true:
            set {_progress} to {player::%{_player}'s uuid%::race_progress_current_race} ? 0
            set {_track_id} to {player::%{_player}'s uuid%::current_track_id}
            set {_track_length} to {tracks::%{_track_id}%::length} ? {@default_race_length}

            # Update progress (simplified for example)
            add 1 to {player::%{_player}'s uuid%::race_progress_current_race}
            send action bar "&7Progress: %.1f / %.1f" to {_player} with arguments {_progress}, {_track_length}

            # Check for finish
            if {_progress} >= {_track_length}:
                if {player::%{_player}'s uuid%::in_race} is true:
                    playerFinishRace({_player})

# --- Commands ---
command /race [<join|leave|info|list>] [<text>]:
    trigger:
        if arg-1 is not set or arg-1 is "info":
            send "{@prefix} &7Current race status: &e%{race::status}%"
            if {race::status} is not "lobby":
                send "{@prefix} &7Track: &6%{tracks::%{race::track_id}%::name}%"
                send "{@prefix} &7Players: &b%size of {race::players::*}% / %{@max_players_per_race}%"
            send "{@prefix} &7Available tracks: (use /race list)"
            send "{@prefix} &7Commands: /race join <track_id>, /race leave"
            stop

        if arg-1 is "list":
            send "{@prefix} &eAvailable Race Tracks:"
            if size of {tracks::*} is 0:
                send "&c - No tracks defined yet. An admin needs to create them."
                stop
            loop {tracks::*}:
                send "&7 - &b%loop-index%&7: &a%loop-value::name% &7(Length: %loop-value::length ? {@default_race_length}%, Difficulty: %loop-value::difficulty ? "N/A"%)"
            stop

        if arg-1 is "join":
            if {race::status} is not "lobby":
                send "{@prefix} &cCannot join: A race is already in %{race::status}% state."
                stop
            if size of {race::players::*} >= {@max_players_per_race}:
                send "{@prefix} &cCannot join: The race lobby is full (%{@max_players_per_race}% players)."
                stop
            if player is in {race::players::*}:
                send "{@prefix} &cYou are already in the race lobby."
                stop
            add player to {race::players::*}
            broadcast "{@prefix} &b%player% &ehas joined the race lobby! (&a%size of {race::players::*}%/%{@max_players_per_race}%&e)"
            stop

        if arg-1 is "leave":
            if player is not in {race::players::*}:
                send "{@prefix} &cYou are not in the race lobby or current race."
                stop
            if {race::status} is "inprogress" and {player::%player's uuid%::in_race} is true:
                set {player::%player's uuid%::in_race} to false
                send "{@prefix} &cYou have left the race."
                broadcast "{@prefix} &b%player% &chas left the ongoing race."
                remove player from {race::players::*}
                if {race::status} is "inprogress" and size of {race::players::*} < {@min_players_to_start} and size of {race::players::*} < 1:
                    broadcast "{@prefix} &cAll players have left the race. Ending race."
                    triggerRaceEnd()
                stop

            remove player from {race::players::*}
            broadcast "{@prefix} &b%player% &ehas left the race lobby. (&a%size of {race::players::*}%/%{@max_players_per_race}%&e)"
            stop

command /rcadmin race [<text>] [<text>] [<text>] [<text>] [<text>] [<text>]:
    permission: {@admin_permission}
    trigger:
        if arg-1 is "start":
            if arg-2 is not set:
                send "{@prefix} &cUsage: /rcadmin race start <track_id>"
                stop
            startRaceCountdown(arg-2)
            stop

        if arg-1 is "stop":
            if {race::status} is "lobby" or {race::status} is "finished":
                send "{@prefix} &cNo race is currently active to stop."
                stop
            broadcast "{@prefix} &cThe current race has been stopped by an administrator!"
            triggerRaceEnd()
            stop

        if arg-1 is "createtrack":
            if arg-2 is not set:
                send "{@prefix} &cUsage: /rcadmin race createtrack <track_id> <Track Name>"
                stop
            if {tracks::%arg-2%::name} is set:
                send "{@prefix} &cTrack ID '%arg-2%' already exists."
                stop
            set {tracks::%arg-2%::name} to arg-3 ? arg-2
            set {tracks::%arg-2%::length} to {@default_race_length}
            send "{@prefix} &aTrack '%arg-3%' (ID: %arg-2%) created with default length."
            stop

        if arg-1 is "deletetrack":
            if arg-2 is not set or {tracks::%arg-2%::name} is not set:
                send "{@prefix} &cUsage: /rcadmin race deletetrack <track_id>. Track not found."
                stop
            clear {tracks::%arg-2%::*}
            send "{@prefix} &aTrack '%arg-2%' deleted."
            stop

        if arg-1 is "setpoint":
            if arg-2 is not set or arg-3 is not set:
                send "{@prefix} &cUsage: /rcadmin race setpoint <track_id> <type> [value/here]"
                send "{@prefix} &cTypes: start, waypoint, finish1, finish2, length, name, difficulty"
                stop
            set {_track_id} to arg-2
            if {tracks::%{_track_id}%::name} is not set:
                send "{@prefix} &cTrack ID '%{_track_id}%' not found. Create it first."
                stop
            set {_point_type} to lowercased arg-3

            if {_point_type} is "start":
                set {tracks::%{_track_id}%::start_location} to player's location
                send "{@prefix} &aStart point for track '%{_track_id}%' set to your location."
            else if {_point_type} is "waypoint":
                add player's location to {tracks::%{_track_id}%::waypoints::*}
                send "{@prefix} &aWaypoint #%size of {tracks::%{_track_id}%::waypoints::*}% for track '%{_track_id}%' added at your location."
            else if {_point_type} is "finish1":
                set {tracks::%{_track_id}%::finish_region_loc1} to player's location
                send "{@prefix} &aFinish region corner 1 for track '%{_track_id}%' set."
            else if {_point_type} is "finish2":
                set {tracks::%{_track_id}%::finish_region_loc2} to player's location
                send "{@prefix} &aFinish region corner 2 for track '%{_track_id}%' set."
            else if {_point_type} is "length":
                set {_len} to arg-4 parsed as number
                if {_len} is not set or {_len} <= 0:
                    send "{@prefix} &cInvalid length: %arg-4%"
                    stop
                set {tracks::%{_track_id}%::length} to {_len}
                send "{@prefix} &aTrack '%{_track_id}%' length set to %{_len}% units."
            else if {_point_type} is "name":
                set {tracks::%{_track_id}%::name} to arg-4
                send "{@prefix} &aTrack '%{_track_id}%' name set to '%arg-4%'."
            else if {_point_type} is "difficulty":
                set {tracks::%{_track_id}%::difficulty} to arg-4
                send "{@prefix} &aTrack '%{_track_id}%' difficulty set to '%arg-4%'."
            else:
                send "{@prefix} &cInvalid setpoint type. Use: start, waypoint, finish1, finish2, length, name, difficulty."
            stop

        if arg-1 is "trackinfo":
            if arg-2 is not set or {tracks::%arg-2%::name} is not set:
                send "{@prefix} &cUsage: /rcadmin race trackinfo <track_id>. Track not found."
                stop
            set {_track_id} to arg-2
            send "{@prefix} &6Track Info for: %{_track_id}% (%{tracks::%{_track_id}%::name}%)"
            send "&e - Length: &b%{tracks::%{_track_id}%::length}% units"
            send "&e - Difficulty: &b%{tracks::%{_track_id}%::difficulty ? "N/A"}%"
            send "&e - Start Location: &b%{tracks::%{_track_id}%::start_location}%"
            send "&e - Waypoints (%size of {tracks::%{_track_id}%::waypoints::*}%):"
            loop {tracks::%{_track_id}%::waypoints::*}:
                send "&7  - %loop-value%"
            send "&e - Finish Region Corner 1: &b%{tracks::%{_track_id}%::finish_region_loc1}%"
            send "&e - Finish Region Corner 2: &b%{tracks::%{_track_id}%::finish_region_loc2}%"
            stop

        send "{@prefix} &cUnknown race admin command. See /rcadmin help"

# --- Utility Functions ---
function formatTimespan(t: timespan) :: text:
    set {_seconds} to total seconds of {_t}
    set {_minutes} to floor({_seconds} / 60)
    set {_remaining_seconds} to {_seconds} mod 60
    return "%%02d:%%.2f" formatted with {_minutes}, {_remaining_seconds}

# --- Main Command ---
command /raceclicker [<text>] [<text>]:
    aliases: rc, rclicker
    trigger:
        if arg-1 is not set or arg-1 is "help":
            send "{@prefix} &7Available Commands:"
            send "&e/race &7- Race commands (join, leave, info, list)"
            send "&e/rcadmin &7- Admin commands (requires permission)"
            send "&e/rc version &7- Shows the current Skript version."
            stop

        if arg-1 is "version":
            send "{@prefix} &7You are running Race Clicker Skript &ev%{_version}%&7."
            if {@debug_mode} is true:
                send "{@prefix} &eDebug mode is currently active."
            stop

        send "{@prefix} &cUnknown command. Type &e/rc help &cfor a list of commands."
# File: seasonal_system.sk
# Description: Seasonal system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Season settings
    season_duration: 3 months # Duration of each season
    season_start: "2025-01-01" # Start date of first season
    
    # Season types
    season_types:
        - "Spring Sprint"
        - "Summer Speed"
        - "Autumn Achievement"
        - "Winter Wonder"
        - "Spring Special"
        - "Summer Spectacular"
        - "Autumn Adventure"
        - "Winter Wonders"
    
    # Season rewards
    season_rewards:
        bronze: 1000
        silver: 2500
        gold: 5000
        platinum: 10000
        diamond: 20000
    
    # Season requirements
    season_requirements:
        bronze: 10000
        silver: 50000
        gold: 100000
        platinum: 250000
        diamond: 500000
    
    # Seasonal bonuses
    seasonal_bonuses:
        spring: 1.2
        summer: 1.3
        autumn: 1.4
        winter: 1.5

# Variables:
# {season::current_season} = text (current season)
# {season::start_date} = text (season start date)
# {season::end_date} = text (season end date)
# {player::%uuid%::season_points} = number (season points)
# {player::%uuid%::season_rank} = text (season rank)
# {player::%uuid%::season_rewards} = number (season rewards)

# Function to start season
every {@season_duration}:
    set {_date} to date now
    set {_month} to month of {_date}
    
    # Determine season type
    if {_month} is "january", "february", or "march":
        set {_season} to "Spring Sprint"
    else if {_month} is "april", "may", or "june":
        set {_season} to "Summer Speed"
    else if {_month} is "july", "august", or "september":
        set {_season} to "Autumn Achievement"
    else if {_month} is "october", "november", or "december":
        set {_season} to "Winter Wonder"
    
    # Start new season
    startSeason({_season})

# Function to start season
function startSeason(season: text):
    # Set season dates
    set {_start_date} to date now
    set {_end_date} to {_start_date} + {@season_duration}
    
    # Update season variables
    set {season::current_season} to {_season}
    set {season::start_date} to {_start_date}
    set {season::end_date} to {_end_date}
    
    # Announce season start
    broadcast "{@prefix} &6Season Announcement: %{_season}% has begun!" to all players
    broadcast "{@prefix} &6Duration: %{_end_date}%" to all players
    broadcast "{@prefix} &6Rewards: Up to %{@season_rewards::diamond}% ClickCoins!" to all players
    
    # Distribute rewards from previous season
    if {season::current_season} is set:
        loop all players:
            set {_p} to loop-value
            set {_uuid} to {_p}'s uuid
            if {player::%{_uuid}%::season_rewards} > 0:
                add {player::%{_uuid}%::season_rewards} to {player::%{_uuid}%::clickcoins}
                send "{@prefix} &aReceived %{player::%{_uuid}%::season_rewards}% ClickCoins from last season!" to {_p}
                set {player::%{_uuid}%::season_rewards} to 0
    
    # Reset season points
    loop all players:
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        set {player::%{_uuid}%::season_points} to 0
        set {player::%{_uuid}%::season_rank} to "bronze"

# Function to calculate season points
every 1 tick:
    loop all players:
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        
        # Check if season is active
        if not {season::current_season} is set:
            return
            
        # Get player stats
        if not {player::%{_uuid}%::clicks} is set:
            set {player::%{_uuid}%::clicks} to 0
        if not {player::%{_uuid}%::races} is set:
            set {player::%{_uuid}%::races} to 0
        if not {player::%{_uuid}%::wins} is set:
            set {player::%{_uuid}%::wins} to 0
            
        set {_clicks} to {player::%{_uuid}%::clicks}
        set {_races} to {player::%{_uuid}%::races}
        set {_wins} to {player::%{_uuid}%::wins}
        
        # Calculate points
        set {_points} to 0
        add {_clicks} * 0.1 to {_points} # 0.1 point per click
        add {_races} * 5 to {_points} # 5 points per race
        add {_wins} * 10 to {_points} # 10 points per win
        
        # Apply seasonal bonus
        set {_season} to {season::current_season}
        if {_season} contains "Spring":
            set {_points} to {_points} * {@seasonal_bonuses::spring}
        else if {_season} contains "Summer":
            set {_points} to {_points} * {@seasonal_bonuses::summer}
        else if {_season} contains "Autumn":
            set {_points} to {_points} * {@seasonal_bonuses::autumn}
        else if {_season} contains "Winter":
            set {_points} to {_points} * {@seasonal_bonuses::winter}
        
        # Update points
        add {_points} to {player::%{_uuid}%::season_points}
        
        # Reset stats
        set {player::%{_uuid}%::clicks} to 0
        set {player::%{_uuid}%::races} to 0
        set {player::%{_uuid}%::wins} to 0
        
        # Update season rank
        updateSeasonRank({_p})

# Function to update season rank
function updateSeasonRank(p: player):
    set {_uuid} to {_p}'s uuid
    set {_points} to {player::%{_uuid}%::season_points}
    
    # Update rank based on points
    if {_points} >= {@season_requirements::diamond}:
        set {player::%{_uuid}%::season_rank} to "diamond"
        set {player::%{_uuid}%::season_rewards} to {@season_rewards::diamond}
    else if {_points} >= {@season_requirements::platinum}:
        set {player::%{_uuid}%::season_rank} to "platinum"
        set {player::%{_uuid}%::season_rewards} to {@season_rewards::platinum}
    else if {_points} >= {@season_requirements::gold}:
        set {player::%{_uuid}%::season_rank} to "gold"
        set {player::%{_uuid}%::season_rewards} to {@season_rewards::gold}
    else if {_points} >= {@season_requirements::silver}:
        set {player::%{_uuid}%::season_rank} to "silver"
        set {player::%{_uuid}%::season_rewards} to {@season_rewards::silver}
    else:
        set {player::%{_uuid}%::season_rank} to "bronze"
        set {player::%{_uuid}%::season_rewards} to {@season_rewards::bronze}
    
    # Send rank update
    send "{@prefix} &aSeason Rank: %{player::%{_uuid}%::season_rank}%" to {_p}
    send "{@prefix} &aSeason Points: %{player::%{_uuid}%::season_points}%" to {_p}

# Function to get season status
function getSeasonStatus() :: text:
    if {season::current_season} is not set:
        return "&cNo season active!"
    
    set {_status} to "&6Season: %{season::current_season}%\n"
    append "&eStart: &a%{season::start_date}%\n" to {_status}
    append "&eEnd: &a%{season::end_date}%\n" to {_status}
    append "&eRewards: &a%{@season_rewards::diamond}% ClickCoins\n" to {_status}
    return {_status}

# Command to view season status
command /season:
    trigger:
        send "{@prefix} %{getSeasonStatus()}%" to player

# Command to view season leaderboard
command /seasonleaderboard:
    trigger:
        set {_leaderboard} to []
        
        # Get top players
        loop all players sorted by {player::%{_uuid}%::season_points} descending:
            if size of {_leaderboard} >= 10:
                break
            set {_p} to loop-value
            set {_uuid} to {_p}'s uuid
            add "&e%{_p}%: &a%{player::%{_uuid}%::season_points}% (%{player::%{_uuid}%::season_rank}%)" to {_leaderboard}
        
        # Send leaderboard
        send "{@prefix} &6Season Leaderboard:" to player
        loop {_leaderboard}:
            send "&7- %{loop-value}%" to player

# Seasonal achievements
on season end:
    loop all players:
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        set {_rank} to {player::%{_uuid}%::season_rank}
        
        # Give season rewards
        add {player::%{_uuid}%::season_rewards} to {player::%{_uuid}%::clickcoins}
        
        # Unlock season achievements
        unlockSeasonAchievement({_p}, {_rank})
        
        # Reset season stats
        set {player::%{_uuid}%::season_points} to 0
        set {player::%{_uuid}%::season_rank} to "bronze"
        set {player::%{_uuid}%::season_rewards} to 0

# Function to unlock season achievement
function unlockSeasonAchievement(p: player, rank: text):
    set {_uuid} to {_p}'s uuid
    set {_achievement} to "Season %{rank}%"
    
    # Unlock achievement
    set {player::%{_uuid}%::achievements::%{_achievement.lower}%} to true
    
    # Give achievement reward
    giveAchievementReward({_p}, {_achievement})
    
    # Send achievement message
    send "{@prefix} &aUnlocked Achievement: %{_achievement}%" to {_p}
    broadcast "{@prefix} &6%{_p}% unlocked achievement: %{_achievement}%" to players with permission "raceclicker.achievements"

# Function to give achievement reward
# Removing duplicate function since it exists in event_system.sk
    set {_uuid} to {_p}'s uuid
    
    # Base reward
    set {_reward} to 100
    
    # Special rewards
    switch achievement:
        case "Season Diamond":
            set {_reward} to 500
            break
        case "Season Platinum":
            set {_reward} to 300
            break
        case "Season Gold":
            set {_reward} to 200
            break
    
    # Add reward
    add {_reward} to {player::%{_uuid}%::clickcoins}
    send "{@prefix} &aEarned %{@achievement_bonus}% ClickCoins for achievement!" to {_p}

# Seasonal events
on season start:
    # Generate season-specific events
    set {_event_count} to random number between 3 and 5
    loop {_event_count} times:
        set {_event_id} to "season_event_%{loop-index}%"
        
        # Choose random event type
        set {_type} to random element of {@event_types::*}
        
        # Set event parameters
        switch {_type}:
            case "Double Clicks":
                set {_duration} to random number between 30 and 60
                set {_reward} to random number between 1000 and 5000
                break
            case "Speed Boost":
                set {_duration} to random number between 15 and 30
                set {_reward} to random number between 2000 and 8000
                break
            case "Power Surge":
                set {_duration} to random number between 20 and 40
                set {_reward} to random number between 1500 and 7000
                break
        
        # Store event data
        set {event::%{_event_id}%::type} to {_type}
        set {event::%{_event_id}%::duration} to {_duration}
        set {event::%{_event_id}%::reward} to {_reward}
        set {event::%{_event_id}%::start_time} to now + (loop-index * 24 hours)
        
        # Announce event
        broadcast "{@prefix} &6Season Event: %{_type}% starting in %{_duration}% minutes!" to all players

# Seasonal rewards
on season end:
    loop all players:
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        
        # Give season rewards
        add {player::%{_uuid}%::season_rewards} to {player::%{_uuid}%::clickcoins}
        
        # Give special season rewards
        if {player::%{_uuid}%::season_rank} is "diamond":
            giveSeasonReward({_p}, "diamond")
        else if {player::%{_uuid}%::season_rank} is "platinum":
            giveSeasonReward({_p}, "platinum")
        else if {player::%{_uuid}%::season_rank} is "gold":
            giveSeasonReward({_p}, "gold")

# Function to give season reward
function giveSeasonReward(p: player, rank: text):
    set {_uuid} to {_p}'s uuid
    
    # Give rank-specific rewards
    switch rank:
        case "diamond":
            add 10000 to {player::%{_uuid}%::clickcoins}
            add 10 to {player::%{_uuid}%::prestige_level}
            break
        case "platinum":
            add 5000 to {player::%{_uuid}%::clickcoins}
            add 5 to {player::%{_uuid}%::prestige_level}
            break
        case "gold":
            add 2000 to {player::%{_uuid}%::clickcoins}
            add 2 to {player::%{_uuid}%::prestige_level}
            break
    
    # Send reward message
    send "{@prefix} &aReceived %{rank}% season rewards!" to {_p}

# Seasonal challenges
on season start:
    loop all players:
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        
        # Generate season challenges
        set {_challenge_count} to random number between 3 and 5
        loop {_challenge_count} times:
            set {_challenge_id} to "season_challenge_%{loop-index}%"
            
            # Choose random challenge type
            set {_type} to random element of {@challenge_types::*}
            
            # Set challenge parameters
            switch {_type}:
                case "Click Challenge":
                    set {_target} to random number between 100000 and 500000
                    set {_reward} to random number between 1000 and 5000
                    break
                case "Race Challenge":
                    set {_target} to random number between 10 and 50
                    set {_reward} to random number between 2000 and 8000
                    break
                case "Track Challenge":
                    set {_target} to random number between 20 and 100
                    set {_reward} to random number between 1500 and 7000
                    break
            
            # Store challenge data
            set {challenge::%{_challenge_id}%::type} to {_type}
            set {challenge::%{_challenge_id}%::target} to {_target}
            set {challenge::%{_challenge_id}%::reward} to {_reward}
            add {_challenge_id} to {player::%{_uuid}%::season_challenges::*}
            
            # Send challenge notification
            send "{@prefix} &aNew season challenge: %{_type}% (%{_target}% target)" to {_p}

# Seasonal achievements
on season end:
    loop all players:
        set {_p} to loop-value
        set {_uuid} to {_p}'s uuid
        
        # Check season achievements
        loop [1, 2, 3, 4, 5]:
            if {player::%{_uuid}%::season_challenges_completed} >= loop-value:
                if {player::%{_uuid}%::achievements::season_challenges_%{loop_value}%} is not true:
                    unlockAchievement({_p}, "Season Challenge %{loop-value}%")

# Seasonal rewards GUI
command /seasonrewards:
    trigger:
        set {_uuid} to player's uuid
        
        # Create GUI
        open chest with 6 rows named "&6Season Rewards" to player
        
        # Add reward items
        set {_slot} to 0
        loop all ranks:
            set {_rank} to loop-value
            set {_reward} to {@season_rewards::%{_rank}%}
            
            # Create item
            set {_item} to diamond
            if {_rank} is "diamond":
                set {_item} to diamond_block
            else if {_rank} is "platinum":
                set {_item} to netherite_ingot
            else if {_rank} is "gold":
                set {_item} to gold_ingot
            else if {_rank} is "silver":
                set {_item} to iron_ingot
            else:
                set {_item} to copper_ingot
            
            # Add item to GUI
            set slot {_slot} of player's current inventory to {_item} named "&6%{_rank}% Rank" with lore "&eClickCoins: &a%{_reward}%" and "&eRequired Points: &a%{@season_requirements::%{_rank}%}%"
            
            add 1 to {_slot}
        
        # Add close button
        set slot 53 of player's current inventory to red_stained_glass_pane named "&cClose" with lore "&eClick to close"

# Seasonal effects
every 1 tick:
    if {season::current_season} is set:
        loop all players:
            set {_p} to loop-value
            set {_uuid} to {_p}'s uuid
            
            # Apply season-specific effects
            switch {season::current_season}:
                case "Spring Sprint":
                    set {_speed} to {player::%{_uuid}%::speed} * {@seasonal_bonuses::spring}
                    set {player::%{_uuid}%::speed} to {_speed}
                    break
                case "Summer Speed":
                    set {_power} to {player::%{_uuid}%::power} * {@seasonal_bonuses::summer}
                    set {player::%{_uuid}%::power} to {_power}
                    break
                case "Autumn Achievement":
                    set {_accuracy} to {player::%{_uuid}%::accuracy} * {@seasonal_bonuses::autumn}
                    set {player::%{_uuid}%::accuracy} to {_accuracy}
                    break
                case "Winter Wonder":
                    set {_combo} to {player::%{_uuid}%::combo} * {@seasonal_bonuses::winter}
                    set {player::%{_uuid}%::combo} to {_combo}
                    break
# File: anti_cheat.sk
# Description: Anti-cheat system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Anti-cheat settings
    max_clicks_per_second: 20 # Maximum clicks allowed per second
    max_combo_multiplier: 10 # Maximum allowed combo multiplier
    max_speed_multiplier: 2.0 # Maximum allowed speed multiplier
    max_power_multiplier: 5.0 # Maximum allowed power multiplier
    
    # Detection thresholds
    click_pattern_threshold: 0.8 # Pattern matching threshold
    speed_threshold: 1.5 # Speed detection threshold
    power_threshold: 4.0 # Power detection threshold
    combo_threshold: 8.0 # Combo detection threshold
    
    # Punishment settings
    ban_duration: 1 day # Default ban duration
    warning_cooldown: 1 hour # Warning cooldown
    max_warnings: 3 # Maximum warnings before ban
    
# Variables:
# {player::%uuid%::click_history::*} = number (list of click timestamps)
# {player::%uuid%::warnings} = number (warning count)
# {player::%uuid%::last_warning} = timestamp (last warning time)
# {player::%uuid%::detected_cheats::*} = text (list of detected cheats)

# Function to check click pattern
every 1 tick:
    loop all players:
        set {_p} to loop-player
        set {_uuid} to {_p}'s uuid
        
        if {player::%{_uuid}%::click_history::*} is set:
            set {_clicks} to size of {player::%{_uuid}%::click_history::*}
            set {_time} to now
            
            # Clean up old clicks
            loop {player::%{_uuid}%::click_history::*}:
                if {_time} - loop-value > 1000 ticks:
                    remove loop-value from {player::%{_uuid}%::click_history::*}
            
            # Check click rate
            set {_click_rate} to {_clicks} / (1000 / 20) # 20 ticks per second
            if {_click_rate} > {@max_clicks_per_second}:
                detectCheat({_p}, "Fast Clicking")
            
            # Check click pattern
            if {_clicks} >= 10:
                set {_pattern} to calculateClickPattern({_p})
                if {_pattern} > {@click_pattern_threshold}:
                    detectCheat({_p}, "Pattern Clicking")

# Function to check speed
every 1 tick:
    loop all players:
        if {player::%{_uuid}%::in_race} is true:
            set {_speed} to calculateSpeed({_p})
            if {_speed} > {@max_speed_multiplier}:
                detectCheat({_p}, "Speed Hack")

# Function to check power
every 1 tick:
    loop all players:
        set {_power} to calculatePower({_p})
        if {_power} > {@max_power_multiplier}:
            detectCheat({_p}, "Power Hack")

# Function to check combo
every 1 tick:
    loop all players:
        set {_combo} to calculateCombo({_p})
        if {_combo} > {@max_combo_multiplier}:
            detectCheat({_p}, "Combo Hack")

# Function to detect cheat
function detectCheat(p: player, cheat_type: text):
    set {_uuid} to {_p}'s uuid
    
    # Check warning cooldown
    if now - {player::%{_uuid}%::last_warning} < {@warning_cooldown}:
        return
    
    # Add warning
    add 1 to {player::%{_uuid}%::warnings}
    set {player::%{_uuid}%::last_warning} to now
    
    # Add detected cheat
    add {_cheat_type} to {player::%{_uuid}%::detected_cheats::*}
    
    # Send warning
    send "{@prefix} &cWarning: %{_cheat_type}% detected!" to {_p}
    send "{@prefix} &cYou have %{player::%{_uuid}%::warnings}% warnings." to {_p}
    
    # Check for ban
    if {player::%{_uuid}%::warnings} >= {@max_warnings}:
        banPlayer({_p})

# Function to ban player
function banPlayer(p: player):
    set {_uuid} to {_p}'s uuid
    
    # Ban player
    ban {_p} for {@ban_duration} with reason "Multiple cheating attempts"
    
    # Log ban
    logBan({_p})
    
    # Reset warnings
    set {player::%{_uuid}%::warnings} to 0
    set {player::%{_uuid}%::detected_cheats::*} to []

# Function to calculate click pattern
function calculateClickPattern(p: player) :: number:
    set {_uuid} to {_p}'s uuid
    set {_pattern} to 0
    
    if {player::%{_uuid}%::click_history::*} is set:
        set {_clicks} to {player::%{_uuid}%::click_history::*}
        set {_size} to size of {_clicks}
        
        if {_size} >= 10:
            set {_sum} to 0
            loop {_clicks}:
                add loop-value to {_sum}
            
            set {_avg} to {_sum} / {_size}
            set {_variance} to 0
            
            loop {_clicks}:
                set {_diff} to (loop-value - {_avg}) ^ 2
                add {_diff} to {_variance}
            
            set {_variance} to {_variance} / {_size}
            set {_pattern} to 1 - sqrt({_variance}) / {_avg}
    
    return {_pattern}

# Function to calculate speed
function calculateSpeed(p: player) :: number:
    set {_uuid} to {_p}'s uuid
    set {_speed} to 1
    
    if {player::%{_uuid}%::speed_multiplier} is set:
        set {_speed} to {player::%{_uuid}%::speed_multiplier}
    
    return {_speed}

# Function to calculate power
function calculatePower(p: player) :: number:
    set {_uuid} to {_p}'s uuid
    set {_power} to 1
    
    if {player::%{_uuid}%::power_multiplier} is set:
        set {_power} to {player::%{_uuid}%::power_multiplier}
    
    return {_power}

# Function to calculate combo
function calculateCombo(p: player) :: number:
    set {_uuid} to {_p}'s uuid
    set {_combo} to 1
    
    if {player::%{_uuid}%::combo_multiplier} is set:
        set {_combo} to {player::%{_uuid}%::combo_multiplier}
    
    return {_combo}

# Function to log ban
function logBan(p: player):
    set {_uuid} to {_p}'s uuid
    set {_timestamp} to now in "yyyy-MM-dd HH:mm:ss"
    
    # Write to ban log
    append line "[%{_timestamp}%] %{_p}% (UUID: %{_uuid}%) banned for cheating" to file "raceclicker_bans.log"
    
    # Broadcast to admins
    broadcast "{@prefix} &c%{_p}% has been banned for cheating!" to players with permission "raceclicker.admin"

# Command to check player's warnings
command /checkcheat <player>:
    permission: raceclicker.admin
    trigger:
        set {_target} to arg-1
        set {_uuid} to {_target}'s uuid
        
        send "{@prefix} &6Cheat Detection for %{_target}%:" to player
        send "&eWarnings: &a%{player::%{_uuid}%::warnings}%" to player
        send "&eDetected Cheats: &a%{player::%{_uuid}%::detected_cheats::*}%" to player
        
        # Show detailed stats
        send "&eClick Rate: &a%{calculateClickPattern(_target)}%" to player
        send "&eSpeed: &a%{calculateSpeed(_target)}%" to player
        send "&ePower: &a%{calculatePower(_target)}%" to player
        send "&eCombo: &a%{calculateCombo(_target)}%" to player

# Command to reset warnings
command /resetwarnings <player>:
    permission: raceclicker.admin
    trigger:
        set {_target} to arg-1
        set {_uuid} to {_target}'s uuid
        
        set {player::%{_uuid}%::warnings} to 0
        set {player::%{_uuid}%::detected_cheats::*} to []
        
        send "{@prefix} &aReset warnings for %{_target}%" to player
        broadcast "{@prefix} &6%{_target}% has been pardoned by %{player}%" to players with permission "raceclicker.admin"
# File: social_system.sk
# Description: Social system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Social settings
    max_friends: 100 # Maximum friends per player
    max_party_size: 8 # Maximum party size
    friend_request_cooldown: 5 minutes # Cooldown between friend requests
    
    # Party settings
    party_leader_prefix: "&6[Party Leader] " # Party leader prefix
    party_member_prefix: "&e[Party Member] " # Party member prefix
    
    # Chat settings
    chat_color: "&7" # Default chat color
    team_chat_color: "&a" # Team chat color
    
# Variables:
# {player::%uuid%::friends::*} = text (list of friends)
# {player::%uuid%::party} = text (party name)
# {player::%uuid%::party_role} = text (party role)
# {player::%uuid%::last_friend_request} = timestamp (last friend request time)
# {player::%uuid%::last_party_invite} = timestamp (last party invite time)

# Function to add friend
function addFriend(p: player, target: player):
    set {_uuid} to {_p}'s uuid
    set {_target_uuid} to {_target}'s uuid
    
    # Check friend limit
    if size of {player::%{_uuid}%::friends::*} >= {@max_friends}:
        send "{@prefix} &cYou've reached your friend limit!" to {_p}
        return
    
    # Add friend
    add {_target}'s name to {player::%{_uuid}%::friends::*}
    add {_p}'s name to {player::%{_target_uuid}%::friends::*}
    
    # Send messages
    send "{@prefix} &aYou're now friends with %{_target}%!" to {_p}
    send "{@prefix} &a%{_p}% is now your friend!" to {_target}

# Function to remove friend
function removeFriend(p: player, target: player):
    set {_uuid} to {_p}'s uuid
    set {_target_uuid} to {_target}'s uuid
    
    # Remove friend
    remove {_target}'s name from {player::%{_uuid}%::friends::*}
    remove {_p}'s name from {player::%{_target_uuid}%::friends::*}
    
    # Send messages
    send "{@prefix} &cYou're no longer friends with %{_target}%!" to {_p}
    send "{@prefix} &c%{_p}% is no longer your friend!" to {_target}

# Function to create party
function createParty(p: player, name: text):
    set {_uuid} to {_p}'s uuid
    
    # Check if already in party
    if {player::%{_uuid}%::party} is set:
        send "{@prefix} &cYou're already in a party!" to {_p}
        return
    
    # Create party
    set {player::%{_uuid}%::party} to {_name}
    set {player::%{_uuid}%::party_role} to "leader"
    set {party::%{_name}%::leader} to {_p}
    set {party::%{_name}%::members::*} to {_p}'s name
    
    # Send message
    send "{@prefix} &aCreated party: %{_name}%" to {_p}
    broadcast "{@prefix} &6%{_p}% created party: %{_name}%" to players with permission "raceclicker.party"

# Function to join party
function joinParty(p: player, name: text):
    set {_uuid} to {_p}'s uuid
    
    # Check if party exists
    if {party::%{_name}%::leader} is not set:
        send "{@prefix} &cParty not found!" to {_p}
        return
    
    # Check party size
    if size of {party::%{_name}%::members::*} >= {@max_party_size}:
        send "{@prefix} &cParty is full!" to {_p}
        return
    
    # Join party
    set {player::%{_uuid}%::party} to {_name}
    set {player::%{_uuid}%::party_role} to "member"
    add {_p}'s name to {party::%{_name}%::members::*}
    
    # Send message
    send "{@prefix} &aJoined party: %{_name}%" to {_p}
    broadcast "{@prefix} &6%{_p}% joined party: %{_name}%" to players with permission "raceclicker.party"

# Function to leave party
function leaveParty(p: player):
    set {_uuid} to {_p}'s uuid
    set {_party} to {player::%{_uuid}%::party}
    
    # Check if in party
    if {_party} is not set:
        send "{@prefix} &cYou're not in a party!" to {_p}
        return
    
    # Remove from party
    remove {_p}'s name from {party::%{_party}%::members::*}
    delete {player::%{_uuid}%::party}
    delete {player::%{_uuid}%::party_role}
    
    # If leader, transfer leadership or disband
    if {player::%{_uuid}%::party_role} is "leader":
        if size of {party::%{_party}%::members::*} > 0:
            set {_new_leader} to first value of {party::%{_party}%::members::*}
            set {party::%{_party}%::leader} to {_new_leader}
            send "{@prefix} &6Leadership transferred to %{_new_leader}%" to {_new_leader}
        else:
            delete {party::%{_party}%::*}
    
    # Send message
    send "{@prefix} &aLeft party: %{_party}%" to {_p}
    broadcast "{@prefix} &6%{_p}% left party: %{_party}%" to players with permission "raceclicker.party"

# Function to send friend request
function sendFriendRequest(p: player, target: player):
    set {_uuid} to {_p}'s uuid
    set {_target_uuid} to {_target}'s uuid
    
    # Check cooldown
    if now - {player::%{_uuid}%::last_friend_request} < {@friend_request_cooldown}:
        send "{@prefix} &cPlease wait before sending another friend request!" to {_p}
        return
    
    # Send request
    send "{@prefix} &6%{_p}% wants to be friends! Use /accept %{_p}% to accept." to {_target}
    set {player::%{_uuid}%::last_friend_request} to now
    
    # Send confirmation
    send "{@prefix} &aFriend request sent to %{_target}%!" to {_p}

# Function to accept friend request
function acceptFriendRequest(p: player, target: player):
    set {_uuid} to {_p}'s uuid
    
    # Add friend
    addFriend({_p}, {_target})

# Chat system
on chat:
    set {_p} to sender
    set {_uuid} to {_p}'s uuid
    
    # Check party chat
    if message starts with "!":
        if {player::%{_uuid}%::party} is set:
            set {_party} to {player::%{_uuid}%::party}
            set {_message} to message without "!"
            
            # Send to party members
            loop {party::%{_party}%::members::*}:
                set {_member} to player from name loop-value
                if {_member} is not null:
                    send "&6[Party] %{party_member_prefix}%%{_p}%: %{_message}%" to {_member}
            
            # Cancel normal chat
            cancel event
            return
    
    # Normal chat
    send "&6[Global] %{chat_color}%%{_p}%: %{message}%" to all players

# Social commands
command /friend <player>:
    trigger:
        sendFriendRequest(player, arg-1)

command /accept <player>:
    trigger:
        acceptFriendRequest(player, arg-1)

command /party create <text>:
    permission: raceclicker.party
    trigger:
        createParty(player, arg-1)

command /party join <text>:
    permission: raceclicker.party
    trigger:
        joinParty(player, arg-1)

command /party leave:
    permission: raceclicker.party
    trigger:
        leaveParty(player)

command /friends:
    trigger:
        set {_uuid} to player's uuid
        if {player::%{_uuid}%::friends::*} is not set:
            send "{@prefix} &cYou have no friends!" to player
            return
        
        send "{@prefix} &6Your Friends:" to player
        loop {player::%{_uuid}%::friends::*}:
            send "&e- %{loop-value}%" to player

command /partyinfo:
    permission: raceclicker.party
    trigger:
        set {_uuid} to player's uuid
        set {_party} to {player::%{_uuid}%::party}
        
        if {_party} is not set:
            send "{@prefix} &cYou're not in a party!" to player
            return
        
        send "{@prefix} &6Party Info - %{_party}%" to player
        send "&eLeader: &a%{party::%{_party}%::leader}%" to player
        send "&eMembers: &a%{size of {party::%{_party}%::members::*}}%/%{@max_party_size}%" to player
        
        send "&eMembers:" to player
        loop {party::%{_party}%::members::*}:
            send "&7- %{loop-value}%" to player
# File: stats_tracking.sk
# Description: Statistics tracking system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Stats settings
    stats_update_interval: 1 minute # How often to update stats
    leaderboard_size: 10 # Size of leaderboards
    
    # Achievement thresholds
    clicks_achievement_thresholds: [1000, 10000, 100000, 1000000, 10000000]
    races_achievement_thresholds: [1, 10, 50, 100, 500]
    tracks_achievement_thresholds: [1, 5, 10, 25, 50]
    achievements_achievement_thresholds: [1, 5, 10, 25, 50]
    
    # Stat categories
    stat_categories:
        - "Clicks"
        - "Races Won"
        - "Tracks Completed"
        - "Achievements"
        - "Prestige"
        - "ClickCoins"
        - "Combo"
        - "Accuracy"
        - "Speed"
        - "Power"

# Variables:
# {player::%uuid%::stats::*} = number (player's stats)
# {leaderboard::%category%::*} = text (list of leaderboard entries)
# {player::%uuid%::last_stats_update} = timestamp (last stats update time)

# Function to update stats
every {@stats_update_interval}:
    loop all players:
        set {_p} to loop-player
        set {_uuid} to {_p}'s uuid
        
        # Update stats
        updatePlayerStats({_p})
        
        # Update leaderboards
        updateLeaderboards()
        
        # Check achievements
        checkAchievements({_p})

# Function to update player stats
function updatePlayerStats(p: player):
    set {_uuid} to {_p}'s uuid
    
    # Update basic stats
    if {player::%{_uuid}%::clicks} is set:
        add {player::%{_uuid}%::clicks} to {player::%{_uuid}%::stats::clicks}
        set {player::%{_uuid}%::clicks} to 0
    
    if {player::%{_uuid}%::races_won} is set:
        add {player::%{_uuid}%::races_won} to {player::%{_uuid}%::stats::races_won}
    
    if {player::%{_uuid}%::tracks_completed} is set:
        add {player::%{_uuid}%::tracks_completed} to {player::%{_uuid}%::stats::tracks_completed}
    
    # Update advanced stats
    set {player::%{_uuid}%::stats::max_combo} to {player::%{_uuid}%::max_combo} ? 0
    set {player::%{_uuid}%::stats::accuracy} to {player::%{_uuid}%::accuracy} ? 0
    set {player::%{_uuid}%::stats::speed} to {player::%{_uuid}%::speed} ? 0
    set {player::%{_uuid}%::stats::power} to {player::%{_uuid}%::power} ? 0
    
    # Update prestige stats
    set {player::%{_uuid}%::stats::prestige} to {player::%{_uuid}%::prestige_level} ? 0
    
    # Update ClickCoins
    set {player::%{_uuid}%::stats::clickcoins} to {player::%{_uuid}%::clickcoins} ? 0

# Function to update leaderboards
function updateLeaderboards():
    loop {@stat_categories::*}:
        set {_category} to loop-value
        set {_leaderboard} to []
        
        # Get top players
        set {_players} to all players sorted by {player::%{_uuid}%::stats::%{_category}%} descending
        loop {_players}:
            if size of {_leaderboard} >= {@leaderboard_size}:
                break
            set {_p} to loop-value
            set {_uuid} to {_p}'s uuid
            add "&e%{_p}%: &a%{player::%{_uuid}%::stats::%{_category}%}" to {_leaderboard}
        
        # Update leaderboard
        set {leaderboard::%{_category}%::*} to {_leaderboard}

# Function to check achievements
function checkAchievements(p: player):
    set {_uuid} to {_p}'s uuid
    
    # Check click achievements
    loop {@clicks_achievement_thresholds::*}:
        if {player::%{_uuid}%::stats::clicks} >= loop-value:
            if {player::%{_uuid}%::achievements::clicks_%{loop-value}%} is not true:
                unlockAchievement({_p}, "Click Master %{loop-value}%")
    
    # Check race achievements
    loop {@races_achievement_thresholds::*}:
        if {player::%{_uuid}%::stats::races_won} >= loop-value:
            if {player::%{_uuid}%::achievements::races_%{loop-value}%} is not true:
                unlockAchievement({_p}, "Race Winner %{loop-value}%")
    
    # Check track achievements
    loop {@tracks_achievement_thresholds::*}:
        if {player::%{_uuid}%::stats::tracks_completed} >= loop-value:
            if {player::%{_uuid}%::achievements::tracks_%{loop-value}%} is not true:
                unlockAchievement({_p}, "Track Master %{loop-value}%")
    
    # Check achievement achievements
    set {_ach_count} to 0
    loop all keys of {achievements_list::*}:
        if {player::%{_uuid}%::achievements::%loop-value%} is true:
            add 1 to {_ach_count}
    
    loop {@achievements_achievement_thresholds::*}:
        if {_ach_count} >= loop-value:
            if {player::%{_uuid}%::achievements::achievements_%{loop-value}%} is not true:
                unlockAchievement({_p}, "Achievement Master %{loop-value}%")

# Function to unlock achievement
function unlockAchievement(p: player, achievement: text):
    set {_uuid} to {_p}'s uuid
    set {player::%{_uuid}%::achievements::%{achievement.lower}%} to true
    
    # Give achievement reward
    giveAchievementReward({_p}, achievement)
    
    # Send achievement message
    send "{@prefix} &aUnlocked Achievement: %{achievement}%" to {_p}
    broadcast "{@prefix} &6%{_p}% unlocked achievement: %{achievement}%" to players with permission "raceclicker.achievements"

# Function to give achievement reward
function giveAchievementReward(p: player, achievement: text):
    set {_uuid} to {_p}'s uuid
    
    # Base reward
    set {_reward} to 100
    
    # Special rewards
    switch achievement:
        case "Click Master 1000000":
            set {_reward} to 500
            break
        case "Race Winner 100":
            set {_reward} to 250
            break
        case "Track Master 50":
            set {_reward} to 300
            break
        case "Achievement Master 50":
            set {_reward} to 1000
            break
    
    # Add reward
    add {_reward} to {player::%{_uuid}%::clickcoins}
    send "{@prefix} &aEarned %{@achievement_bonus}% ClickCoins for achievement!" to {_p}

# Function to get player stats
function getPlayerStats(p: player) :: text:
    set {_uuid} to {_p}'s uuid
    set {_stats} to "&6Player Stats:\n"
    
    # Basic stats
    append "&eClicks: &a%{player::%{_uuid}%::stats::clicks}%\n" to {_stats}
    append "&eRaces Won: &a%{player::%{_uuid}%::stats::races_won}%\n" to {_stats}
    append "&eTracks Completed: &a%{player::%{_uuid}%::stats::tracks_completed}%\n" to {_stats}
    
    # Advanced stats
    append "&eMax Combo: &a%{player::%{_uuid}%::stats::max_combo}%\n" to {_stats}
    append "&eAccuracy: &a%{player::%{_uuid}%::stats::accuracy}%\n" to {_stats}
    append "&eSpeed: &a%{player::%{_uuid}%::stats::speed}%\n" to {_stats}
    append "&ePower: &a%{player::%{_uuid}%::stats::power}%\n" to {_stats}
    
    # Prestige and ClickCoins
    append "&ePrestige: &a%{player::%{_uuid}%::stats::prestige}%\n" to {_stats}
    append "&eClickCoins: &a%{player::%{_uuid}%::stats::clickcoins}%\n" to {_stats}
    
    return {_stats}

# Command to view stats
command /stats:
    trigger:
        send "{@prefix} %{getPlayerStats(player)}%" to player

# Command to view leaderboard
command /leaderboard <text>:
    trigger:
        set {_category} to arg-1
        if {_category} is not in {@stat_categories::*}:
            send "{@prefix} &cInvalid category! Use: %{@stat_categories::*}%" to player
            return
        
        send "{@prefix} &6Top %{@leaderboard_size}% %{_category}%:" to player
        loop {leaderboard::%{_category}%::*}:
            send "&7- %{loop-value}%" to player

# Command to view achievements
command /achievements:
    trigger:
        set {_uuid} to player's uuid
        set {_ach_count} to 0
        set {_ach_list} to []
        
        # Get unlocked achievements
        loop all keys of {achievements_list::*}:
            if {player::%{_uuid}%::achievements::%loop-value%} is true:
                add 1 to {_ach_count}
                add "&e- %{loop-value}%" to {_ach_list}
        
        # Send achievements
        send "{@prefix} &6Your Achievements (%{_ach_count}%/%{size of {achievements_list::*}}%):" to player
        loop {_ach_list}:
            send loop-value to player
# File: tournament_system.sk
# Description: Tournament system for Race Clicker

options:
    prefix: &6&lRaceClicker &8»
    # Tournament settings
    tournament_duration: 1 hour # Duration of tournament
    tournament_cooldown: 1 day # Cooldown between tournaments
    tournament_entry_fee: 1000 # Entry fee in ClickCoins
    
    # Tournament types
    tournament_types:
        - "Speed Challenge"
        - "Power Challenge"
        - "Combo Challenge"
        - "Track Challenge"
        - "Race Challenge"
        - "Prestige Challenge"
    
    # Prize pool distribution
    prize_pool:
        first: 50
        second: 30
        third: 15
        fourth: 5
    
    # Tournament requirements
    tournament_requirements:
        min_players: 8
        max_players: 32
        min_level: 10
        max_level: 100
    
    # Tournament brackets
    tournament_brackets:
        bronze: [1, 10]
        silver: [11, 25]
        gold: [26, 50]
        platinum: [51, 75]
        diamond: [76, 100]

# Variables:
# {tournament::current} = text (current tournament type)
# {tournament::start_time} = timestamp (tournament start time)
# {tournament::end_time} = timestamp (tournament end time)
# {tournament::entry_fee} = number (tournament entry fee)
# {tournament::prize_pool} = number (tournament prize pool)
# {tournament::participants::*} = text (list of participants)
# {tournament::scores::*} = number (list of scores)
# {player::%uuid%::tournament_score} = number (player's tournament score)

# Function to start tournament
every {@tournament_cooldown}:
    if now - {tournament::last_tournament} >= {@tournament_cooldown}:
        startTournament()

# Function to start tournament
function startTournament():
    # Choose random tournament type
    set {_type} to random element of {@tournament_types::*}
    
    # Set tournament variables
    set {tournament::current} to {_type}
    set {tournament::start_time} to now
    set {tournament::end_time} to now + {@tournament_duration}
    set {tournament::entry_fee} to {@tournament_entry_fee}
    set {tournament::prize_pool} to 0
    
    # Announce tournament
    broadcast "{@prefix} &6Tournament Announcement: %{_type}% tournament starting!" to all players
    broadcast "{@prefix} &6Duration: %{@tournament_duration}%" to all players
    broadcast "{@prefix} &6Entry Fee: %{@tournament_entry_fee}% ClickCoins" to all players
    broadcast "{@prefix} &6Prize Pool: Up to %{tournament::prize_pool}% ClickCoins!" to all players
    
    # Reset tournament variables
    delete {tournament::participants::*}
    delete {tournament::scores::*}
    
    # Set tournament status
    set {tournament::status} to "open"

# Function to join tournament
command /join:
    permission: raceclicker.tournament.join
    trigger:
        if {tournament::status} is "open":
            set {_uuid} to player's uuid
            
            # Check requirements
            if {player::%{_uuid}%::level} < {@tournament_requirements::min_level}:
                send "{@prefix} &cYou need level %{tournament_requirements::min_level}% to join!" to player
                return
            
            if {player::%{_uuid}%::level} > {@tournament_requirements::max_level}:
                send "{@prefix} &cYou need level %{tournament_requirements::max_level}% or lower to join!" to player
                return
            
            # Check entry fee
            if {player::%{_uuid}%::clickcoins} < {@tournament_entry_fee}:
                send "{@prefix} &cYou don't have enough ClickCoins!" to player
                return
            
            # Check participant limit
            if size of {tournament::participants::*} >= {@tournament_requirements::max_players}:
                send "{@prefix} &cTournament is full!" to player
                return
            
            # Join tournament
            add player to {tournament::participants::*}
            add {@tournament_entry_fee} to {tournament::prize_pool}
            subtract {@tournament_entry_fee} from {player::%{_uuid}%::clickcoins}
            set {player::%{_uuid}%::tournament_score} to 0
            
            # Send join message
            send "{@prefix} &aJoined tournament! Good luck!" to player
            broadcast "{@prefix} &6%{player}% joined the tournament!" to all players
        else:
            send "{@prefix} &cTournament registration is closed!" to player

# Function to calculate tournament scores
every 1 tick:
    if {tournament::status} is "in_progress":
        loop {tournament::participants::*}:
            set {_p} to loop-value
            set {_uuid} to {_p}'s uuid
            
            # Calculate score based on tournament type
            switch {tournament::current}:
                case "Speed Challenge":
                    add {player::%{_uuid}%::speed} to {player::%{_uuid}%::tournament_score}
                    break
                case "Power Challenge":
                    add {player::%{_uuid}%::power} to {player::%{_uuid}%::tournament_score}
                    break
                case "Combo Challenge":
                    add {player::%{_uuid}%::combo} to {player::%{_uuid}%::tournament_score}
                    break
                case "Track Challenge":
                    add {player::%{_uuid}%::tracks_completed} to {player::%{_uuid}%::tournament_score}
                    break
                case "Race Challenge":
                    add {player::%{_uuid}%::races_won} to {player::%{_uuid}%::tournament_score}
                    break
                case "Prestige Challenge":
                    add {player::%{_uuid}%::prestige_level} to {player::%{_uuid}%::tournament_score}
                    break

# Function to end tournament
function endTournament():
    if {tournament::status} is "in_progress":
        # Calculate final scores
        loop {tournament::participants::*}:
            set {_p} to loop-value
            set {_uuid} to {_p}'s uuid
            add {_uuid} to {tournament::scores::*}
        
        # Sort scores
        sort {tournament::scores::*} by {player::%{_uuid}%::tournament_score} descending
        
        # Calculate prizes
        set {_prize_pool} to {tournament::prize_pool}
        set {_first} to {_prize_pool} * {@prize_pool::first} / 100
        set {_second} to {_prize_pool} * {@prize_pool::second} / 100
        set {_third} to {_prize_pool} * {@prize_pool::third} / 100
        set {_fourth} to {_prize_pool} * {@prize_pool::fourth} / 100
        
        # Award prizes
        loop {tournament::scores::*}:
            set {_uuid} to loop-value
            set {_rank} to loop-index
            
            switch {_rank}:
                case 1:
                    add {_first} to {player::%{_uuid}%::clickcoins}
                    broadcast "{@prefix} &61st Place: %{player::%{_uuid}%::name}% - %{_first}% ClickCoins!" to all players
                    break
                case 2:
                    add {_second} to {player::%{_uuid}%::clickcoins}
                    broadcast "{@prefix} &62nd Place: %{player::%{_uuid}%::name}% - %{_second}% ClickCoins!" to all players
                    break
                case 3:
                    add {_third} to {player::%{_uuid}%::clickcoins}
                    broadcast "{@prefix} &63rd Place: %{player::%{_uuid}%::name}% - %{_third}% ClickCoins!" to all players
                    break
                case 4:
                    add {_fourth} to {player::%{_uuid}%::clickcoins}
                    broadcast "{@prefix} &64th Place: %{player::%{_uuid}%::name}% - %{_fourth}% ClickCoins!" to all players
                    break
        
        # Give tournament achievements
        loop {tournament::scores::*}:
            set {_uuid} to loop-value
            set {_rank} to loop-index
            unlockTournamentAchievement(player, {_rank})
        
        # Reset tournament
        set {tournament::status} to "closed"
        set {tournament::last_tournament} to now
        delete {tournament::participants::*}
        delete {tournament::scores::*}
        delete {tournament::prize_pool}
        
        # Announce tournament end
        broadcast "{@prefix} &6Tournament has ended!" to all players

# Function to unlock tournament achievement
function unlockTournamentAchievement(p: player, rank: number):
    set {_uuid} to {_p}'s uuid
    set {_achievement} to "Tournament Rank %{rank}%"
    
    # Unlock achievement
    set {player::%{_uuid}%::achievements::%{_achievement.lower}%} to true
    
    # Give achievement reward
    giveAchievementReward({_p}, {_achievement})
    
    # Send achievement message
    send "{@prefix} &aUnlocked Achievement: %{_achievement}%" to {_p}
    broadcast "{@prefix} &6%{_p}% unlocked achievement: %{_achievement}%" to players with permission "raceclicker.achievements"

# Function to give achievement reward
function giveAchievementReward(p: player, achievement: text):
    set {_uuid} to {_p}'s uuid
    
    # Base reward
    set {_reward} to 100
    
    # Special rewards
    switch achievement:
        case "Tournament Rank 1":
            set {_reward} to 500
            break
        case "Tournament Rank 2":
            set {_reward} to 300
            break
        case "Tournament Rank 3":
            set {_reward} to 200
            break
    
    # Add reward
    add {_reward} to {player::%{_uuid}%::clickcoins}
    send "{@prefix} &aEarned %{@achievement_bonus}% ClickCoins for achievement!" to {_p}

# Function to get tournament status
function getTournamentStatus() :: text:
    if {tournament::status} is not set:
        return "&cNo tournament active!"
    
    set {_status} to "&6Tournament: %{tournament::current}%\n"
    append "&eStatus: &a%{tournament::status}%\n" to {_status}
    append "&eParticipants: &a%{size of {tournament::participants::*}}%\n" to {_status}
    append "&ePrize Pool: &a%{tournament::prize_pool}% ClickCoins\n" to {_status}
    
    # Add participant list
    if size of {tournament::participants::*} > 0:
        append "&eParticipants:\n" to {_status}
        loop {tournament::participants::*}:
            set {_p} to loop-value
            set {_uuid} to {_p}'s uuid
            append "&7- %{_p}%: &a%{player::%{_uuid}%::tournament_score}%\n" to {_status}
    
    return {_status}

# Command to view tournament status
command /tournament:
    permission: raceclicker.tournament.view
    trigger:
        send "{@prefix} %{getTournamentStatus()}%" to player

# Command to view tournament leaderboard
command /tournamentleaderboard:
    permission: raceclicker.tournament.view
    trigger:
        if {tournament::status} is "in_progress":
            set {_leaderboard} to []
            
            # Get top players
            loop {tournament::participants::*} sorted by {player::%{_uuid}%::tournament_score} descending:
                if size of {_leaderboard} >= 10:
                    break
                set {_p} to loop-value
                set {_uuid} to {_p}'s uuid
                add "&e%{_p}%: &a%{player::%{_uuid}%::tournament_score}%" to {_leaderboard}
            
            # Send leaderboard
            send "{@prefix} &6Tournament Leaderboard:" to player
            loop {_leaderboard}:
                send "&7- %{loop-value}%" to player
        else:
            send "{@prefix} &cNo tournament in progress!" to player

# Tournament brackets
command /tournamentbracket:
    permission: raceclicker.tournament.view
    trigger:
        set {_uuid} to player's uuid
        set {_level} to {player::%{_uuid}%::level}
        
        # Determine bracket
        if {_level} is between {@tournament_brackets::bronze::0} and {@tournament_brackets::bronze::1}:
            send "{@prefix} &6Your Tournament Bracket: &aBronze" to player
        else if {_level} is between {@tournament_brackets::silver::0} and {@tournament_brackets::silver::1}:
            send "{@prefix} &6Your Tournament Bracket: &aSilver" to player
        else if {_level} is between {@tournament_brackets::gold::0} and {@tournament_brackets::gold::1}:
            send "{@prefix} &6Your Tournament Bracket: &aGold" to player
        else if {_level} is between {@tournament_brackets::platinum::0} and {@tournament_brackets::platinum::1}:
            send "{@prefix} &6Your Tournament Bracket: &aPlatinum" to player
        else if {_level} is between {@tournament_brackets::diamond::0} and {@tournament_brackets::diamond::1}:
            send "{@prefix} &6Your Tournament Bracket: &aDiamond" to player
        else:
            send "{@prefix} &cInvalid level for tournaments!" to player

# Tournament rewards GUI
command /tournamentrewards:
    permission: raceclicker.tournament.view
    trigger:
        # Create GUI
        open chest with 6 rows named "&6Tournament Rewards" to player
        
        # Add reward items
        set {_slot} to 0
        loop all ranks:
            set {_rank} to loop-value
            
            # Calculate reward
            set {_reward} to {tournament::prize_pool} * {@prize_pool::%{_rank}%} / 100
            
            # Create item
            set {_item} to diamond
            if {_rank} is "first":
                set {_item} to diamond_block
            else if {_rank} is "second":
                set {_item} to netherite_ingot
            else if {_rank} is "third":
                set {_item} to gold_ingot
            else if {_rank} is "fourth":
                set {_item} to iron_ingot
            
            # Add item to GUI
            set slot {_slot} of player's current inventory to {_item} named "&6%{_rank}% Place" with lore "&eReward: &a%{_reward}% ClickCoins"
            
            add 1 to {_slot}
        
        # Add close button
        set slot 53 of player's current inventory to red_stained_glass_pane named "&cClose" with lore "&eClick to close"

# Tournament effects
every 1 tick:
    if {tournament::status} is "in_progress":
        loop {tournament::participants::*}:
            set {_p} to loop-value
            set {_uuid} to {_p}'s uuid
            
            # Apply tournament effects
            switch {tournament::current}:
                case "Speed Challenge":
                    set {_speed} to {player::%{_uuid}%::speed} * 1.2
                    set {player::%{_uuid}%::speed} to {_speed}
                    break
                case "Power Challenge":
                    set {_power} to {player::%{_uuid}%::power} * 1.2
                    set {player::%{_uuid}%::power} to {_power}
                    break
                case "Combo Challenge":
                    set {_combo} to {player::%{_uuid}%::combo} * 1.2
                    set {player::%{_uuid}%::combo} to {_combo}
                    break
                case "Track Challenge":
                    set {_tracks} to {player::%{_uuid}%::tracks_completed} * 1.2
                    set {player::%{_uuid}%::tracks_completed} to {_tracks}
                    break
                case "Race Challenge":
                    set {_races} to {player::%{_uuid}%::races_won} * 1.2
                    set {player::%{_uuid}%::races_won} to {_races}
                    break
                case "Prestige Challenge":
                    set {_prestige} to {player::%{_uuid}%::prestige_level} * 1.2
                    set {player::%{_uuid}%::prestige_level} to {_prestige}
                    break
# File: limited_time_upgrades.sk
# Description: Limited-time upgrade system with special power-ups

options:
    prefix: &6&lRaceClicker &8»
    upgrade_spawn_interval: 30 seconds # How often to spawn upgrades
    upgrade_duration: 15 seconds # Duration of upgrade effects
    upgrade_radius: 2 blocks # Radius around upgrade
    upgrade_types: "speed,combo,accuracy,click_power" # Available upgrade types
    
# Variables:
# {upgrade::%id%::location} = location (upgrade location)
# {upgrade::%id%::type} = text (upgrade type)
# {upgrade::%id%::end_time} = timestamp (when upgrade expires)
# {player::%uuid%::active_upgrades::*} = text (list of active upgrades)

# Function to spawn a new upgrade
function spawnUpgrade(location: location) :: text:
    set {_id} to "upgrade_%{now}%"
    
    # Choose random upgrade type
    set {_type} to choose from {@upgrade_types}
    
    # Set upgrade variables
    set {upgrade::%{_id}%::location} to {_location}
    set {upgrade::%{_id}%::type} to {_type}
    set {upgrade::%{_id}%::end_time} to now + {@upgrade_duration}
    
    # Create upgrade particle effect
    loop 10 times:
        set {_angle} to loop-number * (360 / 10)
        set {_offset} to vector(sin({_angle}), 0, cos({_angle})) multiply {@upgrade_radius}
        
        if {_type} is "speed":
            spawn particle "speed" at {_location} add {_offset}
        else if {_type} is "combo":
            spawn particle "crit" at {_location} add {_offset}
        else if {_type} is "accuracy":
            spawn particle "redstone" at {_location} add {_offset}
        else if {_type} is "click_power":
            spawn particle "happy_villager" at {_location} add {_offset}
    
    return {_id}

# Function to apply upgrade effects
function applyUpgrade(p: player, upgrade_id: text):
    set {_uuid} to {_p}'s uuid
    set {_type} to {upgrade::%{_upgrade_id}%::type}
    
    # Add to active upgrades list
    add {_type} to {player::%{_uuid}%::active_upgrades::*}
    
    # Apply effects based on type
    if {_type} is "speed":
        # Increase speed level temporarily
        set {_speed_bonus} to 5
        set {player::%{_uuid}%::speed_bonus} to {_speed_bonus}
        send "{@prefix} &aSpeed Boost! &e+%{_speed_bonus}% speed for %{@upgrade_duration}% seconds!" to {_p}
    else if {_type} is "combo":
        # Increase combo multiplier
        set {_combo_bonus} to 1.5
        set {player::%{_uuid}%::combo_bonus} to {_combo_bonus}
        send "{@prefix} &aCombo Boost! &e+%{_combo_bonus}x combo multiplier for %{@upgrade_duration}% seconds!" to {_p}
    else if {_type} is "accuracy":
        # Increase accuracy chance
        set {_accuracy_bonus} to 0.3
        set {player::%{_uuid}%::accuracy_bonus} to {_accuracy_bonus}
        send "{@prefix} &aAccuracy Boost! &e+%{_accuracy_bonus}x accuracy for %{@upgrade_duration}% seconds!" to {_p}
    else if {_type} is "click_power":
        # Increase click power
        set {_power_bonus} to 2.0
        set {player::%{_uuid}%::power_bonus} to {_power_bonus}
        send "{@prefix} &aPower Boost! &e+%{_power_bonus}x click power for %{@upgrade_duration}% seconds!" to {_p}
    
    # Play sound
    play sound "minecraft:entity.experience_orb.pickup" to {_p} with volume 1 pitch 1.2

# Function to remove upgrade effects
function removeUpgrade(p: player, upgrade_type: text):
    set {_uuid} to {_p}'s uuid
    
    # Remove from active upgrades
    remove {_upgrade_type} from {player::%{_uuid}%::active_upgrades::*}
    
    # Remove effects
    if {_upgrade_type} is "speed":
        set {player::%{_uuid}%::speed_bonus} to 0
    else if {_upgrade_type} is "combo":
        set {player::%{_uuid}%::combo_bonus} to 1
    else if {_upgrade_type} is "accuracy":
        set {player::%{_uuid}%::accuracy_bonus} to 1
    else if {_upgrade_type} is "click_power":
        set {player::%{_uuid}%::power_bonus} to 1
    
    send "{@prefix} &cUpgrade effect expired!" to {_p}

# Event handler for upgrade collection
every 1 tick:
    loop all players:
        if {player::%loop-player's uuid%::in_race} is true:
            # Check for nearby upgrades
            loop all keys of {upgrade::%*%::location}:
                set {_id} to loop-value
                set {_upgrade_loc} to {upgrade::%{_id}%::location}
                set {_player_loc} to location of loop-player
                
                # Check if upgrade is still valid
                if {upgrade::%{_id}%::end_time} is set and {upgrade::%{_id}%::end_time} < now:
                    # Upgrade expired, remove it
                    remove {_id} from {upgrade::%*%::location}
                    remove {_id} from {upgrade::%*%::type}
                    remove {_id} from {upgrade::%*%::end_time}
                    continue
                
                # Check if player is close enough
                if distance between {_player_loc} and {_upgrade_loc} <= {@upgrade_radius}:
                    applyUpgrade(loop-player, {_id})
                    remove {_id} from {upgrade::%*%::location}
                    remove {_id} from {upgrade::%*%::type}
                    remove {_id} from {upgrade::%*%::end_time}

# Periodically spawn upgrades
every {@upgrade_spawn_interval}:
    loop all players:
        if {player::%loop-player's uuid%::in_race} is true:
            set {_loc} to location of loop-player add vector(0, 1, 0)
            spawnUpgrade({_loc})

# Function to get upgrade bonus for click power calculation
function getUpgradeBonus(p: player, upgrade_type: text) :: number:
    set {_uuid} to {_p}'s uuid
    
    if {_upgrade_type} is "speed":
        return {player::%{_uuid}%::speed_bonus} ? 0
    else if {_upgrade_type} is "combo":
        return {player::%{_uuid}%::combo_bonus} ? 1
    else if {_upgrade_type} is "accuracy":
        return {player::%{_uuid}%::accuracy_bonus} ? 1
    else if {_upgrade_type} is "power":
        return {player::%{_uuid}%::power_bonus} ? 1
    return 1
