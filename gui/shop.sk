# File: shop.sk
# Path: race-clicker/gui/shop.sk
# Description: Upgrade shop interface

options:
    prefix: &6&lRaceClicker &8Â»
    speedUpgradeBaseCost: 100
    speedUpgradeCostMultiplier: 1.5 # Cost increases by 50% each level
    autoclickerUpgradeBaseCost: 250
    autoclickerUpgradeCostMultiplier: 1.75 # Cost increases by 75% each level
    autoclickerClicksPerLevel: 1

# Command to open the shop
command /shop:
    aliases: /upgrades, /rcshop
    trigger:
        openUpgradeShop(player)

# Function to calculate speed upgrade cost
function calculateSpeedCost(level: number) :: number:
    return floor({@speedUpgradeBaseCost} * ({@speedUpgradeCostMultiplier}^{_level}))

# Function to calculate auto-clicker upgrade cost
function calculateAutoClickerCost(level: number) :: number:
    return floor({@autoclickerUpgradeBaseCost} * ({@autoclickerUpgradeCostMultiplier}^{_level}))

# Function to open the main upgrade shop GUI
function openUpgradeShop(p: player):
    set {_uuid} to {_p}'s uuid
    create a gui with virtual chest inventory with 3 rows named "&8&nRace Upgrades":
        # Decorative items
        loop 27 times:
            if loop-number - 1 is 0 or 1 or 2 or 3 or 4 or 5 or 6 or 7 or 8 or 9 or 17 or 18 or 19 or 20 or 21 or 23 or 24 or 25 or 26:
                if gui-inventory is not set for slot (loop-number - 1) of current gui:
                    make gui slot (loop-number - 1) with gray stained glass pane named " "

        # Speed Upgrade
        set {_speed_level} to {player::%{_uuid}%::speed-level} ? 0
        set {_speed_cost} to calculateSpeedCost({_speed_level})
        make gui slot 10 with lime stained clay named "&a&lSpeed Upgrade" with lore "&7Increases your click power per click." and "" and "&7Current Level: &e%{player::%{_uuid}%::speed-level}%" and "&7Next Level Cost: &c%{_speed_cost}% clicks" and "" and "&eClick to purchase!" to run function purchaseSpeedUpgrade({_p}, {_speed_cost})

        # Auto-Clicker Upgrade
        set {_autoclicker_level} to {player::%{_uuid}%::autoclicker-level} ? 0
        set {_autoclicker_cost} to calculateAutoClickerCost({_autoclicker_level})
        set {_clicks_per_sec} to {_autoclicker_level} * {@autoclickerClicksPerLevel}
        set {_next_clicks_per_sec} to ({_autoclicker_level} + 1) * {@autoclickerClicksPerLevel}
        make gui slot 14 with light blue stained clay named "&b&lAuto-Clicker Upgrade" with lore "&7Automatically clicks for you over time." and "" and "&7Current Level: &e%{player::%{_uuid}%::autoclicker-level}%" and "&7Current Clicks/sec: &e%{_clicks_per_sec}%" and "&7Next Level Clicks/sec: &e%{_next_clicks_per_sec}%" and "&7Next Level Cost: &c%{_autoclicker_cost}% clicks" and "" and "&eClick to purchase!" to run function purchaseAutoClickerUpgrade({_p}, {_autoclicker_cost})

        # Prestige Option
        # TODO: Add more detailed prestige eligibility check (e.g., minimum level for some upgrades)
        set {_prestige_points_on_prestige} to {player::%{_uuid}%::prestige-points-on-prestige} ? 0 # This should be calculated in prestige.sk
        make gui slot 22 with nether star named "&d&lPrestige" with lore "&7Reset progress for powerful bonuses!" and "&7You will gain ~%{_prestige_points_on_prestige}% Prestige Points." and "" and "&eClick to learn more!" to run function openPrestigeConfirmationGUI({_p}) # Calls function from prestige.sk

    open last gui to {_p}

# Function to handle speed upgrade purchase
function purchaseSpeedUpgrade(p: player, cost: number):
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::clicks} >= {_cost}:
        subtract {_cost} from {player::%{_uuid}%::clicks}
        add 1 to {player::%{_uuid}%::speed-level}
        send "{@prefix} &aSuccessfully upgraded speed to level %{player::%{_uuid}%::speed-level}%!" to {_p}
        play sound "minecraft:entity.experience_orb.pickup" to {_p} with volume 1 pitch 1.5
        # Particle effect at player's location
        spawn 10 of particle crit at location of {_p} offset by vector(0, 1, 0) # Spawn slightly above feet
        openUpgradeShop({_p}) # Re-open to show updated values and costs
    else:
        send "{@prefix} &cNot enough clicks! You need %{_cost}% clicks." to {_p}
        play sound "minecraft:entity.villager.no" to {_p} with volume 1 pitch 1

# Function to handle auto-clicker upgrade purchase
function purchaseAutoClickerUpgrade(p: player, cost: number):
    set {_uuid} to {_p}'s uuid
    if {player::%{_uuid}%::clicks} >= {_cost}:
        subtract {_cost} from {player::%{_uuid}%::clicks}
        add 1 to {player::%{_uuid}%::autoclicker-level}
        send "{@prefix} &aSuccessfully upgraded auto-clicker to level %{player::%{_uuid}%::autoclicker-level}%!" to {_p}
        play sound "minecraft:entity.experience_orb.pickup" to {_p} with volume 1 pitch 1.5
        spawn 10 of particle villager happy at location of {_p} offset by vector(0, 1, 0) # Spawn slightly above feet
        openUpgradeShop({_p}) # Re-open
    else:
        send "{@prefix} &cNot enough clicks! You need %{_cost}% clicks." to {_p}
        play sound "minecraft:entity.villager.no" to {_p} with volume 1 pitch 1

# Note: openPrestigeConfirmationGUI is defined in features/prestige.sk
# The call in openUpgradeShop now correctly points to it.

# --- Phase 7: Optimize Skript Performance ---
# Optimize GUI updates
# - GUI is re-opened on purchase, which is a common and acceptable way in Skript for updates.
# - Caching GUI layouts: Skript's GUI creation is generally efficient for this scale.
#   Further optimization here might be over-engineering unless performance issues are observed.
# - Minimized inventory recreations: Achieved by functions like openUpgradeShop refreshing the view.

# TODO: Add upgrade preview system (e.g., show next level's benefit more clearly if complex)
# TODO: Consider adding a 'max buy' option for upgrades.