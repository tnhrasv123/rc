# File: leaderboards.sk
# Path: race-clicker/gui/leaderboards.sk
# Description: Ranking systems for Race Clicker

options:
    prefix: &6&lRaceClicker &8Â»
    leaderboardSize: 10 # Number of players to show on leaderboards
    leaderboardRefreshRate: 300 # Seconds (5 minutes)
    leaderboardTypes: "clicks", "races_won", "prestige_level"

# Initialize leaderboard variables on script load
on load:
    loop {@leaderboardTypes}:
        set {_type} to loop-value
        loop {@leaderboardSize} times:
            delete {leaderboard::%{_type}%::top::%loop-number-1%::uuid}
            delete {leaderboard::%{_type}%::top::%loop-number-1%::value}
            delete {leaderboard::%{_type}%::top::%loop-number-1%::name}
    broadcast "&7[Debug] Leaderboard variables initialized."
    # Initial population can be slow, consider doing it async or on first request if performance is an issue
    # For now, let's schedule a refresh shortly after load
    wait 10 seconds
    refreshAllLeaderboards()

# Command to open the leaderboards GUI
command /leaderboard [<text>]:
    aliases: /lb, /top, /rcleaderboard
    trigger:
        set {_type} to arg-1 ? "clicks"
        if {_type} is not "clicks" and {_type} is not "races_won" and {_type} is not "prestige_level":
            send "{@prefix} &cInvalid leaderboard type. Available: clicks, races_won, prestige_level." to player
            stop
        openLeaderboardGUI(player, {_type})

# Function to open the leaderboard GUI
function openLeaderboardGUI(p: player, type: text):
    set {_gui_title} to "&8&nLeaderboard - %capitalize({_type})%"
    replace all "_" with " " in {_gui_title}
    create a gui with virtual chest inventory with 6 rows named {_gui_title}:
        # Display top players
        loop {@leaderboardSize} times:
            set {_rank} to loop-number
            set {_slot} to 9 + (floor((_rank - 1) / 7)) * 9 + ((_rank - 1) mod 7) + 1 # Center items a bit
            if {_rank} > 7:
                set {_slot} = {_slot} + 2 # Shift second row of items
            if {_rank} > 14:
                set {_slot} = {_slot} + 2 # Shift third row if we had more items
            
            # Create item for this rank
            set {_player_uuid} to {leaderboard::%{_type}%::top::%{_rank}%::uuid}
            set {_player_value} to {leaderboard::%{_type}%::top::%{_rank}%::value}
            set {_player_name} to {leaderboard::%{_type}%::top::%{_rank}%::name}

            if {_player_uuid} is set and {_player_value} is set and {_player_name} is set:
                make gui slot {_slot} with player head of ({_player_uuid} parsed as offline player) named "&a&l#%{_rank}% %{_player_name}%" with lore "&7%capitalize({_type})%: &e%{_player_value}%"
            else:
                make gui slot {_slot} with barrier named "&c&l#%{_rank}%" with lore "&7No player data"

        # Sorting options
        make gui slot 48 with paper named "&eSort by Clicks" with lore "&7View top players by Clicks" to run function openLeaderboardGUI({_p}, "clicks")
        make gui slot 49 with emerald named "&eSort by Races Won" with lore "&7View top players by Races Won" to run function openLeaderboardGUI({_p}, "races_won")
        make gui slot 50 with nether star named "&eSort by Prestige Level" with lore "&7View top players by Prestige Level" to run function openLeaderboardGUI({_p}, "prestige_level")

        # Refresh button
        make gui slot 53 with clock named "&6Refresh Leaderboard" with lore "&7Click to manually update this view." to run function refreshAndReopenLeaderboard({_p}, {_type})

        # Fill border
        loop 54 times:
            set {_slot_index} to loop-number - 1
            if gui slot {_slot_index} is not set:
                if {_slot_index} < 9 or {_slot_index} > 44 or {_slot_index} mod 9 is 0 or {_slot_index} mod 9 is 8:
                    make gui slot {_slot_index} with gray stained glass pane named " "
    open last gui to {_p}

function refreshAndReopenLeaderboard(p: player, type: text):
    send "{@prefix} &7Refreshing leaderboard data..." to {_p}
    refreshLeaderboardData({_type}) # Refresh specific leaderboard
    wait 1 tick # Allow refresh to process
    openLeaderboardGUI({_p}, {_type})

# --- Leaderboard Data Management ---

# Function to update a player's score for a specific leaderboard type
# This should be called by other scripts when relevant data changes
# e.g., from clicking.sk for clicks, racing.sk for races_won, prestige.sk for prestige_level
function updatePlayerLeaderboardScore(p: player, type: text, value: number):
    if {_type} is not an element of {@leaderboardTypes}:
        send debug "&c[Leaderboard] Attempted to update invalid leaderboard type: %{_type}%"
        stop

    set {_uuid} to {_p}'s uuid
    set {_name} to name of {_p}

    # This is a simplified update. For true sorted insertion, it's more complex.
    # We'll rely on the periodic refresh to sort properly.
    # For now, just store the player's latest value for potential use in refresh.
    set {playerdata::%{_uuid}%::leaderboard::%{_type}%} to {_value}
    set {playerdata::%{_uuid}%::name} to {_name} # Keep name updated

    # Trigger a refresh for this specific leaderboard type if the value might be a new top score
    # This is a heuristic. A full check is done by refreshLeaderboardData.
    set {_current_lowest_top_score} to {leaderboard::%{_type}%::top::%{@leaderboardSize}%::value} ? 0
    if {_value} > {_current_lowest_top_score}:
        refreshLeaderboardData({_type})

# Periodically refresh all leaderboards
every {@leaderboardRefreshRate} seconds:
    refreshAllLeaderboards()

function refreshAllLeaderboards():
    # send debug "&7[Leaderboard] Starting periodic refresh of all leaderboards..."
    loop {@leaderboardTypes}:
        refreshLeaderboardData(loop-value)
    # send debug "&a[Leaderboard] All leaderboards refreshed."

# Core function to refresh a specific leaderboard type
function refreshLeaderboardData(type: text):
    # send debug "&7[Leaderboard] Refreshing leaderboard: %{_type}%..."
    # 1. Collect all relevant player data
    # This is the hardest part in Skript without database/YAML addons for *all* server players.
    # We will iterate known players who have data for this type.
    # This assumes {playerdata::UUID::leaderboard::TYPE} and {playerdata::UUID::name} are populated elsewhere.

    delete {_all_scores::*}
    loop all players:
        set {_uuid} to loop-player's uuid
        if {playerdata::%{_uuid}%::leaderboard::%{_type}%} is set:
            set {_all_scores::%{_uuid}%::value} to {playerdata::%{_uuid}%::leaderboard::%{_type}%}
            set {_all_scores::%{_uuid}%::name} to {playerdata::%{_uuid}%::name} ? name of loop-player
    
    # If you have a list of all player UUIDs that ever joined (e.g. {all_player_uuids::*}):
    # loop {all_player_uuids::*}:
    #     set {_uuid} to loop-value
    #     if {playerdata::%{_uuid}%::leaderboard::%{_type}%} is set:
    #         set {_all_scores::%{_uuid}%::value} to {playerdata::%{_uuid}%::leaderboard::%{_type}%}
    #         set {_all_scores::%{_uuid}%::name} to {playerdata::%{_uuid}%::name}

    # 2. Sort the data (simple bubble sort for demonstration, can be slow for many players)
    set {_sorted_uuids::*} to indices of {_all_scores::*}
    set {_size} to size of {_sorted_uuids::*}
    if {_size} < 1:
        # send debug "&e[Leaderboard] No data to sort for %{_type}%."
        # Clear existing top list for this type
        loop {@leaderboardSize} times:
            delete {leaderboard::%{_type}%::top::%loop-number%::uuid}
            delete {leaderboard::%{_type}%::top::%loop-number%::value}
            delete {leaderboard::%{_type}%::top::%loop-number%::name}
        stop

    loop {_size} times:
        set {_swapped} to false
        loop ({_size} - loop-value-1) times:
            set {_idx1} to loop-value-2 # current index in _sorted_uuids
            set {_idx2} to loop-value-1 # next index in _sorted_uuids
            set {_uuid1} to {_sorted_uuids::%{_idx1}%}
            set {_uuid2} to {_sorted_uuids::%{_idx2}%}
            if {_all_scores::%{_uuid1}%::value} < {_all_scores::%{_uuid2}%::value}: # Sort descending
                set {_temp_uuid} to {_sorted_uuids::%{_idx1}%}
                set {_sorted_uuids::%{_idx1}%} to {_sorted_uuids::%{_idx2}%}
                set {_sorted_uuids::%{_idx2}%} to {_temp_uuid}
                set {_swapped} to true
        if not {_swapped}:
            break

    # 3. Store the top N players
    loop {@leaderboardSize} times:
        set {_rank} to loop-number
        if {_sorted_uuids::%{_rank}%} is set:
            set {_top_uuid} to {_sorted_uuids::%{_rank}%}
            set {leaderboard::%{_type}%::top::%{_rank}%::uuid} to {_top_uuid}
            set {leaderboard::%{_type}%::top::%{_rank}%::value} to {_all_scores::%{_top_uuid}%::value}
            set {leaderboard::%{_type}%::top::%{_rank}%::name} to {_all_scores::%{_top_uuid}%::name}
        else:
            delete {leaderboard::%{_type}%::top::%{_rank}%::uuid}
            delete {leaderboard::%{_type}%::top::%{_rank}%::value}
            delete {leaderboard::%{_type}%::top::%{_rank}%::name}
    # send debug "&a[Leaderboard] Finished refreshing %{_type}%."

# Admin command to manually refresh leaderboards
command /rclbadmin <text>:
    permission: raceclicker.admin
    trigger:
        if arg-1 is "refreshall":
            send "{@prefix} &7Manually refreshing all leaderboards..." to sender
            refreshAllLeaderboards()
            send "{@prefix} &aAll leaderboards refreshed." to sender
        else if arg-1 is "refresh":
            if arg-2 is not set:
                send "{@prefix} &cUsage: /rclbadmin refresh <type>" to sender
                stop
            if arg-2 is not an element of {@leaderboardTypes}:
                send "{@prefix} &cInvalid leaderboard type. Available: %{@leaderboardTypes}%" to sender
                stop
            send "{@prefix} &7Manually refreshing %arg-2% leaderboard..." to sender
            refreshLeaderboardData(arg-2)
            send "{@prefix} &a%arg-2% leaderboard refreshed." to sender
        else if arg-1 is "testupdate": # For debugging
            if player is not set:
                send "{@prefix} &cThis command must be run by a player." to sender
                stop
            set {_random_score} to random integer between 100 and 10000
            updatePlayerLeaderboardScore(player, "clicks", {_random_score})
            send "{@prefix} &7Updated your 'clicks' score to %{_random_score}% for testing." to player

# Note on Player Heads:
# `player head of ({_uuid} parsed as offline player)` should work for displaying heads if the server
# can resolve the UUID to a skin. Ensure player data like names are stored/updated correctly.

# TODO: For a production server with many players, this Skript-native sorting can be very slow.
# Consider using Skript addons like Skript-YAML with custom sorting functions or Skript-DB (e.g., SQLite)
# for more efficient data storage and querying (ORDER BY clauses).
# TODO: The current refreshLeaderboardData only considers online players or those explicitly in {playerdata::*}.
# A robust system would need a list of all UUIDs that have ever played and have relevant data.
# This could be maintained in data.sk or by iterating player save files (if accessible and performant, usually not recommended directly from Skript).